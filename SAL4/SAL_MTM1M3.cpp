
//#include <chrono>
#include <sys/time.h>
#include <stdexcept>
#include <time.h>
#include <sys/types.h>
#include <unistd.h>
#include "SAL_MTM1M3.h"
#include "QosProvider.h"
using namespace MTM1M3;

SAL_MTM1M3::SAL_MTM1M3(int aKey)
{
   int v1,v2,v3,v4;
   bool tuneableQos = 1;
   char *dname = getenv("LSST_DDS_DOMAIN");
   char *qname = getenv("LSST_DDS_QOS");
   char *sname = getenv("LSST_DDS_HISTORYSYNC");
   char *ipaddr = getenv("LSST_DDS_IP");
   if ( dname != NULL ) {
      strncpy(domainName, dname, 128);
   } else {
      strncpy(domainName, "LSST", 128);
   }
   if ( qname != NULL ) {
      QosProvider qosProvider(qname,"DDS DefaultQosProfile");
      tuneableQos = 0;
   }
   if ( sname != NULL ) {
      sscanf(sname,"%d",&historySync);
   } else {
      historySync = 30;
   }
   ddsIPaddress = rand();
   if (ipaddr != NULL) {
      sscanf(ipaddr,"%d.%d.%d.%d", &v1 , &v2 , &v3 , &v4);
      ddsIPaddress = 256*256*256*v1 + 256*256*v2 + 256*v3 + v4;
   } 
   hasReader = false;
   hasWriter = false;
   hasCommand = false;
   hasProcessor = false;
   hasEventReader = false;
   hasEventWriter = false;
   subsystemID = aKey;
   debugLevel = 1;
   initSalActors(tuneableQos);
}

SAL_MTM1M3::SAL_MTM1M3()
{
   int v1,v2,v3,v4;
   int tuneableQos = 1;
   char *dname = getenv("LSST_DDS_DOMAIN");
   char *qname = getenv("LSST_DDS_QOS");
   char *sname = getenv("LSST_DDS_HISTORYSYNC");
   char *ipaddr = getenv("LSST_DDS_IP");
   if ( dname != NULL ) {
      strncpy(domainName, dname, 128);
   } else {
      strncpy(domainName, "LSST", 128);
   }
   if ( qname != NULL ) {
      QosProvider qosProvider(qname,"DDS DefaultQosProfile");
      tuneableQos = 0;
   }
   if ( sname != NULL ) {
      sscanf(sname,"%d",&historySync);
   } else {
      historySync = 30;
   }
   ddsIPaddress = 1;
   if (ipaddr != NULL) {
      sscanf(ipaddr,"%d.%d.%d.%d", &v1 , &v2, &v3, &v4);
      ddsIPaddress = 256*256*256*v1 + 256*256*v2 + 256*v3 + v4;
   } 
   hasReader = false;
   hasWriter = false;
   hasCommand = false;
   hasEventReader = false;
   hasEventWriter = false;
   hasProcessor = false;
   subsystemID = 0;
   debugLevel = 1;
   initSalActors(tuneableQos);
}

/**
 * Returns the name of an error code.
 **/
string SAL_MTM1M3::getErrorName(DDS::ReturnCode_t status)
{
  return RetCodeName[status];
}

/**
 * Check the return status for errors. If there is an error, then terminate.
 **/
void SAL_MTM1M3::checkStatus(DDS::ReturnCode_t status, const char *info)
{


  if (status != DDS::RETCODE_OK && status != DDS::RETCODE_NO_DATA)
  {
    cerr << "Error in " << info << ": " << getErrorName(status).c_str() << endl;
    throw std::runtime_error(getErrorName(status).c_str());
  }
}

/**
 * Check whether a valid handle has been returned. If not, then terminate.
 **/
void SAL_MTM1M3::checkHandle(void *handle, string info)
{

  if (!handle)
  {
    cerr << "Error in " << info.c_str() << ": Creation failed: invalid handle" << endl;
    throw std::runtime_error("Creation failed: invalid handle");
  }
}


double SAL_MTM1M3::getCurrentTime()
{
   struct timex tx;
   struct timespec now;
   double taiTime;

   memset(&tx, 0, sizeof(tx));
   adjtimex(&tx);
   clock_gettime(CLOCK_TAI,&now);
   taiTime = (double)now.tv_sec + (double)now.tv_nsec/1000000000.;
   return taiTime;
}

int SAL_MTM1M3::getLeapSeconds()
{
   struct timex tx;

   memset(&tx, 0, sizeof(tx));
   adjtimex(&tx);
   return tx.tai;
}


double SAL_MTM1M3::getRcvdTime(char *topicName)
{
    int actorIdx;
    actorIdx = getActorIndex(topicName);
    return sal[actorIdx].rcvStamp;
}

double SAL_MTM1M3::getSentTime(char *topicName)
{
    int actorIdx;
    actorIdx = getActorIndex(topicName);
    return sal[actorIdx].sndStamp;
}


void SAL_MTM1M3::setTuneableQos (char *topicName) {
    int actorIdx;
    actorIdx = getActorIndex(topicName);
    if (actorIdx > 0) {
       sal[actorIdx].tuneableQos = true;
    }
}


void SAL_MTM1M3::setDefaultQos (char *topicName) {
    int actorIdx;
    actorIdx = getActorIndex(topicName);
    if (actorIdx > 0) {
       sal[actorIdx].tuneableQos = false;
    }
}


int SAL_MTM1M3::getActorIndex (char *topicName)
{
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
     if ( strlen(topicName) == strlen(sal[i].topicName) )  {
       if ( strcmp(topicName,sal[i].topicName) == 0 )  {
          return i;
       }
     }
  }
  throw std::runtime_error("Unknown topic");
  return SAL__ERROR;
}

bool SAL_MTM1M3::actorActive(int actorIdx) {
  if ( sal[actorIdx].isActive ) {
     return true;
  }
  return false;
}

bool SAL_MTM1M3::actorReader(int actorIdx) {
  if ( sal[actorIdx].isReader ) {
     return true;
  }
  return false;
}

bool SAL_MTM1M3::actorWriter(int actorIdx) {
  if ( sal[actorIdx].isWriter ) {
     return true;
  }
  return false;
}

bool SAL_MTM1M3::actorCommand(int actorIdx) {
  if ( sal[actorIdx].isCommand ) {
     return true;
  }
  return false;
}

bool SAL_MTM1M3::actorEventReader(int actorIdx) {
  if ( sal[actorIdx].isEventReader ) {
     return true;
  }
  return false;
}

bool SAL_MTM1M3::actorEventWriter(int actorIdx) {
  if ( sal[actorIdx].isEventWriter ) {
     return true;
  }
  return false;
}

bool SAL_MTM1M3::actorProcessor(int actorIdx) {
  if ( sal[actorIdx].isProcessor ) {
     return true;
  }
  return false;
}


int SAL_MTM1M3::getIntProperty(int actorIdx,salCHAR *property)
{
  if (strcmp("ack", property) == 0) {return sal[actorIdx].ack;}
  if (strcmp("error", property) == 0) {return sal[actorIdx].error;}
  if (strcmp("rcvSeqNum", property) == 0) {return sal[actorIdx].rcvSeqNum;}
  return SAL__OK;
}




#define SAL__MTM1M3_accelerometerData_ACTOR    0
#define SAL__MTM1M3_ackcmd_ACTOR    1
#define SAL__MTM1M3_command_abort_ACTOR    2
#define SAL__MTM1M3_command_abortProfile_ACTOR    3
#define SAL__MTM1M3_command_abortRaiseM1M3_ACTOR    4
#define SAL__MTM1M3_command_applyAberrationForces_ACTOR    5
#define SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR    6
#define SAL__MTM1M3_command_applyActiveOpticForces_ACTOR    7
#define SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR    8
#define SAL__MTM1M3_command_applyOffsetForces_ACTOR    9
#define SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR    10
#define SAL__MTM1M3_command_clearAberrationForces_ACTOR    11
#define SAL__MTM1M3_command_clearActiveOpticForces_ACTOR    12
#define SAL__MTM1M3_command_clearOffsetForces_ACTOR    13
#define SAL__MTM1M3_command_disable_ACTOR    14
#define SAL__MTM1M3_command_disableHardpointChase_ACTOR    15
#define SAL__MTM1M3_command_disableHardpointCorrections_ACTOR    16
#define SAL__MTM1M3_command_enable_ACTOR    17
#define SAL__MTM1M3_command_enableHardpointChase_ACTOR    18
#define SAL__MTM1M3_command_enableHardpointCorrections_ACTOR    19
#define SAL__MTM1M3_command_enterControl_ACTOR    20
#define SAL__MTM1M3_command_enterEngineering_ACTOR    21
#define SAL__MTM1M3_command_exitControl_ACTOR    22
#define SAL__MTM1M3_command_exitEngineering_ACTOR    23
#define SAL__MTM1M3_command_lowerM1M3_ACTOR    24
#define SAL__MTM1M3_command_modbusTransmit_ACTOR    25
#define SAL__MTM1M3_command_moveHardpointActuators_ACTOR    26
#define SAL__MTM1M3_command_positionM1M3_ACTOR    27
#define SAL__MTM1M3_command_programILC_ACTOR    28
#define SAL__MTM1M3_command_raiseM1M3_ACTOR    29
#define SAL__MTM1M3_command_resetPID_ACTOR    30
#define SAL__MTM1M3_command_runMirrorForceProfile_ACTOR    31
#define SAL__MTM1M3_command_setLogLevel_ACTOR    32
#define SAL__MTM1M3_command_setSimulationMode_ACTOR    33
#define SAL__MTM1M3_command_setThermalSetpoint_ACTOR    34
#define SAL__MTM1M3_command_setValue_ACTOR    35
#define SAL__MTM1M3_command_shutdown_ACTOR    36
#define SAL__MTM1M3_command_standby_ACTOR    37
#define SAL__MTM1M3_command_start_ACTOR    38
#define SAL__MTM1M3_command_stopHardpointMotion_ACTOR    39
#define SAL__MTM1M3_command_testAir_ACTOR    40
#define SAL__MTM1M3_command_testForceActuator_ACTOR    41
#define SAL__MTM1M3_command_testHardpoint_ACTOR    42
#define SAL__MTM1M3_command_translateM1M3_ACTOR    43
#define SAL__MTM1M3_command_turnAirOff_ACTOR    44
#define SAL__MTM1M3_command_turnAirOn_ACTOR    45
#define SAL__MTM1M3_command_turnLightsOff_ACTOR    46
#define SAL__MTM1M3_command_turnLightsOn_ACTOR    47
#define SAL__MTM1M3_command_turnPowerOff_ACTOR    48
#define SAL__MTM1M3_command_turnPowerOn_ACTOR    49
#define SAL__MTM1M3_command_updatePID_ACTOR    50
#define SAL__MTM1M3_forceActuatorData_ACTOR    51
#define SAL__MTM1M3_gyroData_ACTOR    52
#define SAL__MTM1M3_hardpointActuatorData_ACTOR    53
#define SAL__MTM1M3_hardpointMonitorData_ACTOR    54
#define SAL__MTM1M3_imsData_ACTOR    55
#define SAL__MTM1M3_inclinometerData_ACTOR    56
#define SAL__MTM1M3_logevent_accelerometerWarning_ACTOR    57
#define SAL__MTM1M3_logevent_airSupplyStatus_ACTOR    58
#define SAL__MTM1M3_logevent_airSupplyWarning_ACTOR    59
#define SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR    60
#define SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR    61
#define SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR    62
#define SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR    63
#define SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR    64
#define SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR    65
#define SAL__MTM1M3_logevent_appliedElevationForces_ACTOR    66
#define SAL__MTM1M3_logevent_appliedForces_ACTOR    67
#define SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR    68
#define SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR    69
#define SAL__MTM1M3_logevent_appliedStaticForces_ACTOR    70
#define SAL__MTM1M3_logevent_appliedThermalForces_ACTOR    71
#define SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR    72
#define SAL__MTM1M3_logevent_cellLightStatus_ACTOR    73
#define SAL__MTM1M3_logevent_cellLightWarning_ACTOR    74
#define SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR    75
#define SAL__MTM1M3_logevent_detailedState_ACTOR    76
#define SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR    77
#define SAL__MTM1M3_logevent_errorCode_ACTOR    78
#define SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR    79
#define SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR    80
#define SAL__MTM1M3_logevent_forceActuatorState_ACTOR    81
#define SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR    82
#define SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR    83
#define SAL__MTM1M3_logevent_gyroWarning_ACTOR    84
#define SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR    85
#define SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR    86
#define SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR    87
#define SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR    88
#define SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR    89
#define SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR    90
#define SAL__MTM1M3_logevent_heartbeat_ACTOR    91
#define SAL__MTM1M3_logevent_ilcWarning_ACTOR    92
#define SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR    93
#define SAL__MTM1M3_logevent_interlockStatus_ACTOR    94
#define SAL__MTM1M3_logevent_interlockWarning_ACTOR    95
#define SAL__MTM1M3_logevent_logLevel_ACTOR    96
#define SAL__MTM1M3_logevent_logMessage_ACTOR    97
#define SAL__MTM1M3_logevent_modbusResponse_ACTOR    98
#define SAL__MTM1M3_logevent_pidInfo_ACTOR    99
#define SAL__MTM1M3_logevent_powerStatus_ACTOR    100
#define SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR    101
#define SAL__MTM1M3_logevent_powerWarning_ACTOR    102
#define SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR    103
#define SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR    104
#define SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR    105
#define SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR    106
#define SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR    107
#define SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR    108
#define SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR    109
#define SAL__MTM1M3_logevent_rejectedForces_ACTOR    110
#define SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR    111
#define SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR    112
#define SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR    113
#define SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR    114
#define SAL__MTM1M3_logevent_settingVersions_ACTOR    115
#define SAL__MTM1M3_logevent_settingsApplied_ACTOR    116
#define SAL__MTM1M3_logevent_simulationMode_ACTOR    117
#define SAL__MTM1M3_logevent_softwareVersions_ACTOR    118
#define SAL__MTM1M3_logevent_summaryState_ACTOR    119
#define SAL__MTM1M3_outerLoopData_ACTOR    120
#define SAL__MTM1M3_pidData_ACTOR    121
#define SAL__MTM1M3_powerSupplyData_ACTOR    122

void SAL_MTM1M3::initSalActors (int qos)
{
    for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
      sal[i].isReader = false;
      sal[i].isWriter = false;
      sal[i].isCommand = false;
      sal[i].isEventReader = false;
      sal[i].isProcessor = false;
      sal[i].isEventReader = false;
      sal[i].isEventWriter = false;
      sal[i].isActive = false;
      sal[i].maxSamples = LENGTH_UNLIMITED;
      sal[i].sampleAge = 1.0e20;
      sal[i].historyDepth = 100;
      sal[i].tuneableQos = qos;
    }

    strcpy(sal[0].topicHandle,"MTM1M3_accelerometerData_9537e860");
    strcpy(sal[0].topicName,"MTM1M3_accelerometerData");
    sal[0].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[1].topicHandle,"MTM1M3_ackcmd_004df1cb");
    strcpy(sal[1].topicName,"MTM1M3_ackcmd");
    sal[1].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[2].topicHandle,"MTM1M3_command_abort_62d3a8d0");
    strcpy(sal[2].topicName,"MTM1M3_command_abort");
    sal[2].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[3].topicHandle,"MTM1M3_command_abortProfile_88b2fb6a");
    strcpy(sal[3].topicName,"MTM1M3_command_abortProfile");
    sal[3].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[4].topicHandle,"MTM1M3_command_abortRaiseM1M3_7afaba9d");
    strcpy(sal[4].topicName,"MTM1M3_command_abortRaiseM1M3");
    sal[4].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[5].topicHandle,"MTM1M3_command_applyAberrationForces_4f7ead34");
    strcpy(sal[5].topicName,"MTM1M3_command_applyAberrationForces");
    sal[5].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[6].topicHandle,"MTM1M3_command_applyAberrationForcesByBendingModes_ef2ea53d");
    strcpy(sal[6].topicName,"MTM1M3_command_applyAberrationForcesByBendingModes");
    sal[6].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[7].topicHandle,"MTM1M3_command_applyActiveOpticForces_c79b863f");
    strcpy(sal[7].topicName,"MTM1M3_command_applyActiveOpticForces");
    sal[7].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[8].topicHandle,"MTM1M3_command_applyActiveOpticForcesByBendingModes_3b76ff5b");
    strcpy(sal[8].topicName,"MTM1M3_command_applyActiveOpticForcesByBendingModes");
    sal[8].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[9].topicHandle,"MTM1M3_command_applyOffsetForces_c715c535");
    strcpy(sal[9].topicName,"MTM1M3_command_applyOffsetForces");
    sal[9].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[10].topicHandle,"MTM1M3_command_applyOffsetForcesByMirrorForce_4d09c953");
    strcpy(sal[10].topicName,"MTM1M3_command_applyOffsetForcesByMirrorForce");
    sal[10].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[11].topicHandle,"MTM1M3_command_clearAberrationForces_58d2b112");
    strcpy(sal[11].topicName,"MTM1M3_command_clearAberrationForces");
    sal[11].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[12].topicHandle,"MTM1M3_command_clearActiveOpticForces_d4ffa42c");
    strcpy(sal[12].topicName,"MTM1M3_command_clearActiveOpticForces");
    sal[12].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[13].topicHandle,"MTM1M3_command_clearOffsetForces_0d7f285d");
    strcpy(sal[13].topicName,"MTM1M3_command_clearOffsetForces");
    sal[13].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[14].topicHandle,"MTM1M3_command_disable_04faa884");
    strcpy(sal[14].topicName,"MTM1M3_command_disable");
    sal[14].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[15].topicHandle,"MTM1M3_command_disableHardpointChase_dbe9a16b");
    strcpy(sal[15].topicName,"MTM1M3_command_disableHardpointChase");
    sal[15].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[16].topicHandle,"MTM1M3_command_disableHardpointCorrections_07d1f2ea");
    strcpy(sal[16].topicName,"MTM1M3_command_disableHardpointCorrections");
    sal[16].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[17].topicHandle,"MTM1M3_command_enable_c128bf47");
    strcpy(sal[17].topicName,"MTM1M3_command_enable");
    sal[17].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[18].topicHandle,"MTM1M3_command_enableHardpointChase_49c0d4e1");
    strcpy(sal[18].topicName,"MTM1M3_command_enableHardpointChase");
    sal[18].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[19].topicHandle,"MTM1M3_command_enableHardpointCorrections_dae9c1ec");
    strcpy(sal[19].topicName,"MTM1M3_command_enableHardpointCorrections");
    sal[19].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[20].topicHandle,"MTM1M3_command_enterControl_417c941a");
    strcpy(sal[20].topicName,"MTM1M3_command_enterControl");
    sal[20].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[21].topicHandle,"MTM1M3_command_enterEngineering_89e1ff1c");
    strcpy(sal[21].topicName,"MTM1M3_command_enterEngineering");
    sal[21].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[22].topicHandle,"MTM1M3_command_exitControl_e2ea247d");
    strcpy(sal[22].topicName,"MTM1M3_command_exitControl");
    sal[22].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[23].topicHandle,"MTM1M3_command_exitEngineering_01073d21");
    strcpy(sal[23].topicName,"MTM1M3_command_exitEngineering");
    sal[23].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[24].topicHandle,"MTM1M3_command_lowerM1M3_69afda69");
    strcpy(sal[24].topicName,"MTM1M3_command_lowerM1M3");
    sal[24].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[25].topicHandle,"MTM1M3_command_modbusTransmit_a3c81bde");
    strcpy(sal[25].topicName,"MTM1M3_command_modbusTransmit");
    sal[25].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[26].topicHandle,"MTM1M3_command_moveHardpointActuators_4d114fab");
    strcpy(sal[26].topicName,"MTM1M3_command_moveHardpointActuators");
    sal[26].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[27].topicHandle,"MTM1M3_command_positionM1M3_fa7ca786");
    strcpy(sal[27].topicName,"MTM1M3_command_positionM1M3");
    sal[27].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[28].topicHandle,"MTM1M3_command_programILC_7dde50ee");
    strcpy(sal[28].topicName,"MTM1M3_command_programILC");
    sal[28].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[29].topicHandle,"MTM1M3_command_raiseM1M3_f0a54745");
    strcpy(sal[29].topicName,"MTM1M3_command_raiseM1M3");
    sal[29].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[30].topicHandle,"MTM1M3_command_resetPID_bc5508ce");
    strcpy(sal[30].topicName,"MTM1M3_command_resetPID");
    sal[30].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[31].topicHandle,"MTM1M3_command_runMirrorForceProfile_33f2be6c");
    strcpy(sal[31].topicName,"MTM1M3_command_runMirrorForceProfile");
    sal[31].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[32].topicHandle,"MTM1M3_command_setLogLevel_346fd770");
    strcpy(sal[32].topicName,"MTM1M3_command_setLogLevel");
    sal[32].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[33].topicHandle,"MTM1M3_command_setSimulationMode_dccc3b3c");
    strcpy(sal[33].topicName,"MTM1M3_command_setSimulationMode");
    sal[33].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[34].topicHandle,"MTM1M3_command_setThermalSetpoint_ca5041e8");
    strcpy(sal[34].topicName,"MTM1M3_command_setThermalSetpoint");
    sal[34].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[35].topicHandle,"MTM1M3_command_setValue_56638307");
    strcpy(sal[35].topicName,"MTM1M3_command_setValue");
    sal[35].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[36].topicHandle,"MTM1M3_command_shutdown_46d06e01");
    strcpy(sal[36].topicName,"MTM1M3_command_shutdown");
    sal[36].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[37].topicHandle,"MTM1M3_command_standby_9b43256c");
    strcpy(sal[37].topicName,"MTM1M3_command_standby");
    sal[37].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[38].topicHandle,"MTM1M3_command_start_63435b30");
    strcpy(sal[38].topicName,"MTM1M3_command_start");
    sal[38].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[39].topicHandle,"MTM1M3_command_stopHardpointMotion_727b2152");
    strcpy(sal[39].topicName,"MTM1M3_command_stopHardpointMotion");
    sal[39].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[40].topicHandle,"MTM1M3_command_testAir_37cd327c");
    strcpy(sal[40].topicName,"MTM1M3_command_testAir");
    sal[40].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[41].topicHandle,"MTM1M3_command_testForceActuator_f1a37131");
    strcpy(sal[41].topicName,"MTM1M3_command_testForceActuator");
    sal[41].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[42].topicHandle,"MTM1M3_command_testHardpoint_3736f433");
    strcpy(sal[42].topicName,"MTM1M3_command_testHardpoint");
    sal[42].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[43].topicHandle,"MTM1M3_command_translateM1M3_4d0dfbfe");
    strcpy(sal[43].topicName,"MTM1M3_command_translateM1M3");
    sal[43].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[44].topicHandle,"MTM1M3_command_turnAirOff_1054819e");
    strcpy(sal[44].topicName,"MTM1M3_command_turnAirOff");
    sal[44].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[45].topicHandle,"MTM1M3_command_turnAirOn_acc6807c");
    strcpy(sal[45].topicName,"MTM1M3_command_turnAirOn");
    sal[45].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[46].topicHandle,"MTM1M3_command_turnLightsOff_08b6e5a2");
    strcpy(sal[46].topicName,"MTM1M3_command_turnLightsOff");
    sal[46].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[47].topicHandle,"MTM1M3_command_turnLightsOn_89e80426");
    strcpy(sal[47].topicName,"MTM1M3_command_turnLightsOn");
    sal[47].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[48].topicHandle,"MTM1M3_command_turnPowerOff_41dde1fd");
    strcpy(sal[48].topicName,"MTM1M3_command_turnPowerOff");
    sal[48].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[49].topicHandle,"MTM1M3_command_turnPowerOn_7c3fbe06");
    strcpy(sal[49].topicName,"MTM1M3_command_turnPowerOn");
    sal[49].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[50].topicHandle,"MTM1M3_command_updatePID_6e2af9f8");
    strcpy(sal[50].topicName,"MTM1M3_command_updatePID");
    sal[50].durability = VOLATILE_DURABILITY_QOS;
    strcpy(sal[51].topicHandle,"MTM1M3_forceActuatorData_5d276d43");
    strcpy(sal[51].topicName,"MTM1M3_forceActuatorData");
    sal[51].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[52].topicHandle,"MTM1M3_gyroData_52effcca");
    strcpy(sal[52].topicName,"MTM1M3_gyroData");
    sal[52].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[53].topicHandle,"MTM1M3_hardpointActuatorData_e4c2857f");
    strcpy(sal[53].topicName,"MTM1M3_hardpointActuatorData");
    sal[53].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[54].topicHandle,"MTM1M3_hardpointMonitorData_8caedbd0");
    strcpy(sal[54].topicName,"MTM1M3_hardpointMonitorData");
    sal[54].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[55].topicHandle,"MTM1M3_imsData_dd412900");
    strcpy(sal[55].topicName,"MTM1M3_imsData");
    sal[55].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[56].topicHandle,"MTM1M3_inclinometerData_6233a3d3");
    strcpy(sal[56].topicName,"MTM1M3_inclinometerData");
    sal[56].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[57].topicHandle,"MTM1M3_logevent_accelerometerWarning_aa15b0aa");
    strcpy(sal[57].topicName,"MTM1M3_logevent_accelerometerWarning");
    sal[57].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[58].topicHandle,"MTM1M3_logevent_airSupplyStatus_da397eb1");
    strcpy(sal[58].topicName,"MTM1M3_logevent_airSupplyStatus");
    sal[58].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[59].topicHandle,"MTM1M3_logevent_airSupplyWarning_52167fbe");
    strcpy(sal[59].topicName,"MTM1M3_logevent_airSupplyWarning");
    sal[59].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[60].topicHandle,"MTM1M3_logevent_appliedAberrationForces_d72ce7af");
    strcpy(sal[60].topicName,"MTM1M3_logevent_appliedAberrationForces");
    sal[60].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[61].topicHandle,"MTM1M3_logevent_appliedAccelerationForces_e2698a2b");
    strcpy(sal[61].topicName,"MTM1M3_logevent_appliedAccelerationForces");
    sal[61].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[62].topicHandle,"MTM1M3_logevent_appliedActiveOpticForces_4f827b4b");
    strcpy(sal[62].topicName,"MTM1M3_logevent_appliedActiveOpticForces");
    sal[62].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[63].topicHandle,"MTM1M3_logevent_appliedAzimuthForces_7357e272");
    strcpy(sal[63].topicName,"MTM1M3_logevent_appliedAzimuthForces");
    sal[63].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[64].topicHandle,"MTM1M3_logevent_appliedBalanceForces_3f4cca0a");
    strcpy(sal[64].topicName,"MTM1M3_logevent_appliedBalanceForces");
    sal[64].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[65].topicHandle,"MTM1M3_logevent_appliedCylinderForces_b0d7e6d8");
    strcpy(sal[65].topicName,"MTM1M3_logevent_appliedCylinderForces");
    sal[65].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[66].topicHandle,"MTM1M3_logevent_appliedElevationForces_fa715255");
    strcpy(sal[66].topicName,"MTM1M3_logevent_appliedElevationForces");
    sal[66].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[67].topicHandle,"MTM1M3_logevent_appliedForces_1d16999d");
    strcpy(sal[67].topicName,"MTM1M3_logevent_appliedForces");
    sal[67].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[68].topicHandle,"MTM1M3_logevent_appliedOffsetForces_f19befd6");
    strcpy(sal[68].topicName,"MTM1M3_logevent_appliedOffsetForces");
    sal[68].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[69].topicHandle,"MTM1M3_logevent_appliedSettingsMatchStart_30ba5c59");
    strcpy(sal[69].topicName,"MTM1M3_logevent_appliedSettingsMatchStart");
    sal[69].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[70].topicHandle,"MTM1M3_logevent_appliedStaticForces_b210fd2d");
    strcpy(sal[70].topicName,"MTM1M3_logevent_appliedStaticForces");
    sal[70].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[71].topicHandle,"MTM1M3_logevent_appliedThermalForces_ee191da4");
    strcpy(sal[71].topicName,"MTM1M3_logevent_appliedThermalForces");
    sal[71].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[72].topicHandle,"MTM1M3_logevent_appliedVelocityForces_88f33d5e");
    strcpy(sal[72].topicName,"MTM1M3_logevent_appliedVelocityForces");
    sal[72].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[73].topicHandle,"MTM1M3_logevent_cellLightStatus_2a963d17");
    strcpy(sal[73].topicName,"MTM1M3_logevent_cellLightStatus");
    sal[73].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[74].topicHandle,"MTM1M3_logevent_cellLightWarning_0610a3a7");
    strcpy(sal[74].topicName,"MTM1M3_logevent_cellLightWarning");
    sal[74].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[75].topicHandle,"MTM1M3_logevent_commandRejectionWarning_2445d185");
    strcpy(sal[75].topicName,"MTM1M3_logevent_commandRejectionWarning");
    sal[75].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[76].topicHandle,"MTM1M3_logevent_detailedState_72060c57");
    strcpy(sal[76].topicName,"MTM1M3_logevent_detailedState");
    sal[76].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[77].topicHandle,"MTM1M3_logevent_displacementSensorWarning_1035d8b2");
    strcpy(sal[77].topicName,"MTM1M3_logevent_displacementSensorWarning");
    sal[77].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[78].topicHandle,"MTM1M3_logevent_errorCode_8bce170e");
    strcpy(sal[78].topicName,"MTM1M3_logevent_errorCode");
    sal[78].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[79].topicHandle,"MTM1M3_logevent_forceActuatorForceWarning_3a01ad1f");
    strcpy(sal[79].topicName,"MTM1M3_logevent_forceActuatorForceWarning");
    sal[79].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[80].topicHandle,"MTM1M3_logevent_forceActuatorInfo_d0ebe0c5");
    strcpy(sal[80].topicName,"MTM1M3_logevent_forceActuatorInfo");
    sal[80].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[81].topicHandle,"MTM1M3_logevent_forceActuatorState_028222bb");
    strcpy(sal[81].topicName,"MTM1M3_logevent_forceActuatorState");
    sal[81].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[82].topicHandle,"MTM1M3_logevent_forceActuatorWarning_34b69bc9");
    strcpy(sal[82].topicName,"MTM1M3_logevent_forceActuatorWarning");
    sal[82].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[83].topicHandle,"MTM1M3_logevent_forceSetpointWarning_34a43cf6");
    strcpy(sal[83].topicName,"MTM1M3_logevent_forceSetpointWarning");
    sal[83].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[84].topicHandle,"MTM1M3_logevent_gyroWarning_07c44e13");
    strcpy(sal[84].topicName,"MTM1M3_logevent_gyroWarning");
    sal[84].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[85].topicHandle,"MTM1M3_logevent_hardpointActuatorInfo_d713e706");
    strcpy(sal[85].topicName,"MTM1M3_logevent_hardpointActuatorInfo");
    sal[85].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[86].topicHandle,"MTM1M3_logevent_hardpointActuatorState_dfd8f788");
    strcpy(sal[86].topicName,"MTM1M3_logevent_hardpointActuatorState");
    sal[86].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[87].topicHandle,"MTM1M3_logevent_hardpointActuatorWarning_dcc7d946");
    strcpy(sal[87].topicName,"MTM1M3_logevent_hardpointActuatorWarning");
    sal[87].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[88].topicHandle,"MTM1M3_logevent_hardpointMonitorInfo_5dc92c27");
    strcpy(sal[88].topicName,"MTM1M3_logevent_hardpointMonitorInfo");
    sal[88].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[89].topicHandle,"MTM1M3_logevent_hardpointMonitorState_0dad41d1");
    strcpy(sal[89].topicName,"MTM1M3_logevent_hardpointMonitorState");
    sal[89].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[90].topicHandle,"MTM1M3_logevent_hardpointMonitorWarning_d5ab85e8");
    strcpy(sal[90].topicName,"MTM1M3_logevent_hardpointMonitorWarning");
    sal[90].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[91].topicHandle,"MTM1M3_logevent_heartbeat_85347670");
    strcpy(sal[91].topicName,"MTM1M3_logevent_heartbeat");
    sal[91].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[92].topicHandle,"MTM1M3_logevent_ilcWarning_22b9286f");
    strcpy(sal[92].topicName,"MTM1M3_logevent_ilcWarning");
    sal[92].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[93].topicHandle,"MTM1M3_logevent_inclinometerSensorWarning_4d115eb8");
    strcpy(sal[93].topicName,"MTM1M3_logevent_inclinometerSensorWarning");
    sal[93].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[94].topicHandle,"MTM1M3_logevent_interlockStatus_5c0ae7f7");
    strcpy(sal[94].topicName,"MTM1M3_logevent_interlockStatus");
    sal[94].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[95].topicHandle,"MTM1M3_logevent_interlockWarning_bc69e2ea");
    strcpy(sal[95].topicName,"MTM1M3_logevent_interlockWarning");
    sal[95].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[96].topicHandle,"MTM1M3_logevent_logLevel_83d14d18");
    strcpy(sal[96].topicName,"MTM1M3_logevent_logLevel");
    sal[96].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[97].topicHandle,"MTM1M3_logevent_logMessage_60a1ee35");
    strcpy(sal[97].topicName,"MTM1M3_logevent_logMessage");
    sal[97].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[98].topicHandle,"MTM1M3_logevent_modbusResponse_9c022b06");
    strcpy(sal[98].topicName,"MTM1M3_logevent_modbusResponse");
    sal[98].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[99].topicHandle,"MTM1M3_logevent_pidInfo_858eca99");
    strcpy(sal[99].topicName,"MTM1M3_logevent_pidInfo");
    sal[99].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[100].topicHandle,"MTM1M3_logevent_powerStatus_846d5845");
    strcpy(sal[100].topicName,"MTM1M3_logevent_powerStatus");
    sal[100].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[101].topicHandle,"MTM1M3_logevent_powerSupplyStatus_9f37ac09");
    strcpy(sal[101].topicName,"MTM1M3_logevent_powerSupplyStatus");
    sal[101].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[102].topicHandle,"MTM1M3_logevent_powerWarning_cedc8628");
    strcpy(sal[102].topicName,"MTM1M3_logevent_powerWarning");
    sal[102].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[103].topicHandle,"MTM1M3_logevent_rejectedAberrationForces_07bb7050");
    strcpy(sal[103].topicName,"MTM1M3_logevent_rejectedAberrationForces");
    sal[103].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[104].topicHandle,"MTM1M3_logevent_rejectedAccelerationForces_b8520238");
    strcpy(sal[104].topicName,"MTM1M3_logevent_rejectedAccelerationForces");
    sal[104].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[105].topicHandle,"MTM1M3_logevent_rejectedActiveOpticForces_b308b353");
    strcpy(sal[105].topicName,"MTM1M3_logevent_rejectedActiveOpticForces");
    sal[105].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[106].topicHandle,"MTM1M3_logevent_rejectedAzimuthForces_e69b5c03");
    strcpy(sal[106].topicName,"MTM1M3_logevent_rejectedAzimuthForces");
    sal[106].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[107].topicHandle,"MTM1M3_logevent_rejectedBalanceForces_3d81e3db");
    strcpy(sal[107].topicName,"MTM1M3_logevent_rejectedBalanceForces");
    sal[107].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[108].topicHandle,"MTM1M3_logevent_rejectedCylinderForces_f4002407");
    strcpy(sal[108].topicName,"MTM1M3_logevent_rejectedCylinderForces");
    sal[108].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[109].topicHandle,"MTM1M3_logevent_rejectedElevationForces_bf1221a9");
    strcpy(sal[109].topicName,"MTM1M3_logevent_rejectedElevationForces");
    sal[109].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[110].topicHandle,"MTM1M3_logevent_rejectedForces_7969f67b");
    strcpy(sal[110].topicName,"MTM1M3_logevent_rejectedForces");
    sal[110].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[111].topicHandle,"MTM1M3_logevent_rejectedOffsetForces_9ae34670");
    strcpy(sal[111].topicName,"MTM1M3_logevent_rejectedOffsetForces");
    sal[111].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[112].topicHandle,"MTM1M3_logevent_rejectedStaticForces_95f4fc51");
    strcpy(sal[112].topicName,"MTM1M3_logevent_rejectedStaticForces");
    sal[112].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[113].topicHandle,"MTM1M3_logevent_rejectedThermalForces_bda7bbdd");
    strcpy(sal[113].topicName,"MTM1M3_logevent_rejectedThermalForces");
    sal[113].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[114].topicHandle,"MTM1M3_logevent_rejectedVelocityForces_9e4d8b9f");
    strcpy(sal[114].topicName,"MTM1M3_logevent_rejectedVelocityForces");
    sal[114].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[115].topicHandle,"MTM1M3_logevent_settingVersions_679fb179");
    strcpy(sal[115].topicName,"MTM1M3_logevent_settingVersions");
    sal[115].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[116].topicHandle,"MTM1M3_logevent_settingsApplied_61b4dd6e");
    strcpy(sal[116].topicName,"MTM1M3_logevent_settingsApplied");
    sal[116].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[117].topicHandle,"MTM1M3_logevent_simulationMode_a613ee19");
    strcpy(sal[117].topicName,"MTM1M3_logevent_simulationMode");
    sal[117].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[118].topicHandle,"MTM1M3_logevent_softwareVersions_ed013250");
    strcpy(sal[118].topicName,"MTM1M3_logevent_softwareVersions");
    sal[118].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[119].topicHandle,"MTM1M3_logevent_summaryState_f936f3fc");
    strcpy(sal[119].topicName,"MTM1M3_logevent_summaryState");
    sal[119].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[120].topicHandle,"MTM1M3_outerLoopData_0cb4c7ed");
    strcpy(sal[120].topicName,"MTM1M3_outerLoopData");
    sal[120].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[121].topicHandle,"MTM1M3_pidData_0bd588ed");
    strcpy(sal[121].topicName,"MTM1M3_pidData");
    sal[121].durability = TRANSIENT_DURABILITY_QOS;
    strcpy(sal[122].topicHandle,"MTM1M3_powerSupplyData_daf67bc2");
    strcpy(sal[122].topicName,"MTM1M3_powerSupplyData");
    sal[122].durability = TRANSIENT_DURABILITY_QOS;

}

string SAL_MTM1M3::getSALVersion()
{
    return "4.1.0";
}

string SAL_MTM1M3::getXMLVersion()
{
    return "1.0.0";
}

 salReturn SAL_MTM1M3::salTypeSupport(char *topicName)
{
    if (strncmp("MTM1M3",topicName,6) == 0) {

       if ( strcmp("MTM1M3_accelerometerData",topicName) == 0) {
    MTM1M3::accelerometerData_9537e860TypeSupport_var mt = new MTM1M3::accelerometerData_9537e860TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_abort",topicName) == 0) {
    MTM1M3::command_abort_62d3a8d0TypeSupport_var mt = new MTM1M3::command_abort_62d3a8d0TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_abortProfile",topicName) == 0) {
    MTM1M3::command_abortProfile_88b2fb6aTypeSupport_var mt = new MTM1M3::command_abortProfile_88b2fb6aTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_abortRaiseM1M3",topicName) == 0) {
    MTM1M3::command_abortRaiseM1M3_7afaba9dTypeSupport_var mt = new MTM1M3::command_abortRaiseM1M3_7afaba9dTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_applyAberrationForces",topicName) == 0) {
    MTM1M3::command_applyAberrationForces_4f7ead34TypeSupport_var mt = new MTM1M3::command_applyAberrationForces_4f7ead34TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_applyAberrationForcesByBendingModes",topicName) == 0) {
    MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dTypeSupport_var mt = new MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_applyActiveOpticForces",topicName) == 0) {
    MTM1M3::command_applyActiveOpticForces_c79b863fTypeSupport_var mt = new MTM1M3::command_applyActiveOpticForces_c79b863fTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_applyActiveOpticForcesByBendingModes",topicName) == 0) {
    MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bTypeSupport_var mt = new MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_applyOffsetForces",topicName) == 0) {
    MTM1M3::command_applyOffsetForces_c715c535TypeSupport_var mt = new MTM1M3::command_applyOffsetForces_c715c535TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_applyOffsetForcesByMirrorForce",topicName) == 0) {
    MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953TypeSupport_var mt = new MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_clearAberrationForces",topicName) == 0) {
    MTM1M3::command_clearAberrationForces_58d2b112TypeSupport_var mt = new MTM1M3::command_clearAberrationForces_58d2b112TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_clearActiveOpticForces",topicName) == 0) {
    MTM1M3::command_clearActiveOpticForces_d4ffa42cTypeSupport_var mt = new MTM1M3::command_clearActiveOpticForces_d4ffa42cTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_clearOffsetForces",topicName) == 0) {
    MTM1M3::command_clearOffsetForces_0d7f285dTypeSupport_var mt = new MTM1M3::command_clearOffsetForces_0d7f285dTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_disable",topicName) == 0) {
    MTM1M3::command_disable_04faa884TypeSupport_var mt = new MTM1M3::command_disable_04faa884TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_disableHardpointChase",topicName) == 0) {
    MTM1M3::command_disableHardpointChase_dbe9a16bTypeSupport_var mt = new MTM1M3::command_disableHardpointChase_dbe9a16bTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_disableHardpointCorrections",topicName) == 0) {
    MTM1M3::command_disableHardpointCorrections_07d1f2eaTypeSupport_var mt = new MTM1M3::command_disableHardpointCorrections_07d1f2eaTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_enable",topicName) == 0) {
    MTM1M3::command_enable_c128bf47TypeSupport_var mt = new MTM1M3::command_enable_c128bf47TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_enableHardpointChase",topicName) == 0) {
    MTM1M3::command_enableHardpointChase_49c0d4e1TypeSupport_var mt = new MTM1M3::command_enableHardpointChase_49c0d4e1TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_enableHardpointCorrections",topicName) == 0) {
    MTM1M3::command_enableHardpointCorrections_dae9c1ecTypeSupport_var mt = new MTM1M3::command_enableHardpointCorrections_dae9c1ecTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_enterControl",topicName) == 0) {
    MTM1M3::command_enterControl_417c941aTypeSupport_var mt = new MTM1M3::command_enterControl_417c941aTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_enterEngineering",topicName) == 0) {
    MTM1M3::command_enterEngineering_89e1ff1cTypeSupport_var mt = new MTM1M3::command_enterEngineering_89e1ff1cTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_exitControl",topicName) == 0) {
    MTM1M3::command_exitControl_e2ea247dTypeSupport_var mt = new MTM1M3::command_exitControl_e2ea247dTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_exitEngineering",topicName) == 0) {
    MTM1M3::command_exitEngineering_01073d21TypeSupport_var mt = new MTM1M3::command_exitEngineering_01073d21TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_lowerM1M3",topicName) == 0) {
    MTM1M3::command_lowerM1M3_69afda69TypeSupport_var mt = new MTM1M3::command_lowerM1M3_69afda69TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_modbusTransmit",topicName) == 0) {
    MTM1M3::command_modbusTransmit_a3c81bdeTypeSupport_var mt = new MTM1M3::command_modbusTransmit_a3c81bdeTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_moveHardpointActuators",topicName) == 0) {
    MTM1M3::command_moveHardpointActuators_4d114fabTypeSupport_var mt = new MTM1M3::command_moveHardpointActuators_4d114fabTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_positionM1M3",topicName) == 0) {
    MTM1M3::command_positionM1M3_fa7ca786TypeSupport_var mt = new MTM1M3::command_positionM1M3_fa7ca786TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_programILC",topicName) == 0) {
    MTM1M3::command_programILC_7dde50eeTypeSupport_var mt = new MTM1M3::command_programILC_7dde50eeTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_raiseM1M3",topicName) == 0) {
    MTM1M3::command_raiseM1M3_f0a54745TypeSupport_var mt = new MTM1M3::command_raiseM1M3_f0a54745TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_resetPID",topicName) == 0) {
    MTM1M3::command_resetPID_bc5508ceTypeSupport_var mt = new MTM1M3::command_resetPID_bc5508ceTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_runMirrorForceProfile",topicName) == 0) {
    MTM1M3::command_runMirrorForceProfile_33f2be6cTypeSupport_var mt = new MTM1M3::command_runMirrorForceProfile_33f2be6cTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_setLogLevel",topicName) == 0) {
    MTM1M3::command_setLogLevel_346fd770TypeSupport_var mt = new MTM1M3::command_setLogLevel_346fd770TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_setSimulationMode",topicName) == 0) {
    MTM1M3::command_setSimulationMode_dccc3b3cTypeSupport_var mt = new MTM1M3::command_setSimulationMode_dccc3b3cTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_setThermalSetpoint",topicName) == 0) {
    MTM1M3::command_setThermalSetpoint_ca5041e8TypeSupport_var mt = new MTM1M3::command_setThermalSetpoint_ca5041e8TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_setValue",topicName) == 0) {
    MTM1M3::command_setValue_56638307TypeSupport_var mt = new MTM1M3::command_setValue_56638307TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_shutdown",topicName) == 0) {
    MTM1M3::command_shutdown_46d06e01TypeSupport_var mt = new MTM1M3::command_shutdown_46d06e01TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_standby",topicName) == 0) {
    MTM1M3::command_standby_9b43256cTypeSupport_var mt = new MTM1M3::command_standby_9b43256cTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_start",topicName) == 0) {
    MTM1M3::command_start_63435b30TypeSupport_var mt = new MTM1M3::command_start_63435b30TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_stopHardpointMotion",topicName) == 0) {
    MTM1M3::command_stopHardpointMotion_727b2152TypeSupport_var mt = new MTM1M3::command_stopHardpointMotion_727b2152TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_testAir",topicName) == 0) {
    MTM1M3::command_testAir_37cd327cTypeSupport_var mt = new MTM1M3::command_testAir_37cd327cTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_testForceActuator",topicName) == 0) {
    MTM1M3::command_testForceActuator_f1a37131TypeSupport_var mt = new MTM1M3::command_testForceActuator_f1a37131TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_testHardpoint",topicName) == 0) {
    MTM1M3::command_testHardpoint_3736f433TypeSupport_var mt = new MTM1M3::command_testHardpoint_3736f433TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_translateM1M3",topicName) == 0) {
    MTM1M3::command_translateM1M3_4d0dfbfeTypeSupport_var mt = new MTM1M3::command_translateM1M3_4d0dfbfeTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_turnAirOff",topicName) == 0) {
    MTM1M3::command_turnAirOff_1054819eTypeSupport_var mt = new MTM1M3::command_turnAirOff_1054819eTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_turnAirOn",topicName) == 0) {
    MTM1M3::command_turnAirOn_acc6807cTypeSupport_var mt = new MTM1M3::command_turnAirOn_acc6807cTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_turnLightsOff",topicName) == 0) {
    MTM1M3::command_turnLightsOff_08b6e5a2TypeSupport_var mt = new MTM1M3::command_turnLightsOff_08b6e5a2TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_turnLightsOn",topicName) == 0) {
    MTM1M3::command_turnLightsOn_89e80426TypeSupport_var mt = new MTM1M3::command_turnLightsOn_89e80426TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_turnPowerOff",topicName) == 0) {
    MTM1M3::command_turnPowerOff_41dde1fdTypeSupport_var mt = new MTM1M3::command_turnPowerOff_41dde1fdTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_turnPowerOn",topicName) == 0) {
    MTM1M3::command_turnPowerOn_7c3fbe06TypeSupport_var mt = new MTM1M3::command_turnPowerOn_7c3fbe06TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_command_updatePID",topicName) == 0) {
    MTM1M3::command_updatePID_6e2af9f8TypeSupport_var mt = new MTM1M3::command_updatePID_6e2af9f8TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_forceActuatorData",topicName) == 0) {
    MTM1M3::forceActuatorData_5d276d43TypeSupport_var mt = new MTM1M3::forceActuatorData_5d276d43TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_gyroData",topicName) == 0) {
    MTM1M3::gyroData_52effccaTypeSupport_var mt = new MTM1M3::gyroData_52effccaTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_hardpointActuatorData",topicName) == 0) {
    MTM1M3::hardpointActuatorData_e4c2857fTypeSupport_var mt = new MTM1M3::hardpointActuatorData_e4c2857fTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_hardpointMonitorData",topicName) == 0) {
    MTM1M3::hardpointMonitorData_8caedbd0TypeSupport_var mt = new MTM1M3::hardpointMonitorData_8caedbd0TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_imsData",topicName) == 0) {
    MTM1M3::imsData_dd412900TypeSupport_var mt = new MTM1M3::imsData_dd412900TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_inclinometerData",topicName) == 0) {
    MTM1M3::inclinometerData_6233a3d3TypeSupport_var mt = new MTM1M3::inclinometerData_6233a3d3TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_accelerometerWarning",topicName) == 0) {
    MTM1M3::logevent_accelerometerWarning_aa15b0aaTypeSupport_var mt = new MTM1M3::logevent_accelerometerWarning_aa15b0aaTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_airSupplyStatus",topicName) == 0) {
    MTM1M3::logevent_airSupplyStatus_da397eb1TypeSupport_var mt = new MTM1M3::logevent_airSupplyStatus_da397eb1TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_airSupplyWarning",topicName) == 0) {
    MTM1M3::logevent_airSupplyWarning_52167fbeTypeSupport_var mt = new MTM1M3::logevent_airSupplyWarning_52167fbeTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedAberrationForces",topicName) == 0) {
    MTM1M3::logevent_appliedAberrationForces_d72ce7afTypeSupport_var mt = new MTM1M3::logevent_appliedAberrationForces_d72ce7afTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedAccelerationForces",topicName) == 0) {
    MTM1M3::logevent_appliedAccelerationForces_e2698a2bTypeSupport_var mt = new MTM1M3::logevent_appliedAccelerationForces_e2698a2bTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedActiveOpticForces",topicName) == 0) {
    MTM1M3::logevent_appliedActiveOpticForces_4f827b4bTypeSupport_var mt = new MTM1M3::logevent_appliedActiveOpticForces_4f827b4bTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedAzimuthForces",topicName) == 0) {
    MTM1M3::logevent_appliedAzimuthForces_7357e272TypeSupport_var mt = new MTM1M3::logevent_appliedAzimuthForces_7357e272TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedBalanceForces",topicName) == 0) {
    MTM1M3::logevent_appliedBalanceForces_3f4cca0aTypeSupport_var mt = new MTM1M3::logevent_appliedBalanceForces_3f4cca0aTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedCylinderForces",topicName) == 0) {
    MTM1M3::logevent_appliedCylinderForces_b0d7e6d8TypeSupport_var mt = new MTM1M3::logevent_appliedCylinderForces_b0d7e6d8TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedElevationForces",topicName) == 0) {
    MTM1M3::logevent_appliedElevationForces_fa715255TypeSupport_var mt = new MTM1M3::logevent_appliedElevationForces_fa715255TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedForces",topicName) == 0) {
    MTM1M3::logevent_appliedForces_1d16999dTypeSupport_var mt = new MTM1M3::logevent_appliedForces_1d16999dTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedOffsetForces",topicName) == 0) {
    MTM1M3::logevent_appliedOffsetForces_f19befd6TypeSupport_var mt = new MTM1M3::logevent_appliedOffsetForces_f19befd6TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedSettingsMatchStart",topicName) == 0) {
    MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59TypeSupport_var mt = new MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedStaticForces",topicName) == 0) {
    MTM1M3::logevent_appliedStaticForces_b210fd2dTypeSupport_var mt = new MTM1M3::logevent_appliedStaticForces_b210fd2dTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedThermalForces",topicName) == 0) {
    MTM1M3::logevent_appliedThermalForces_ee191da4TypeSupport_var mt = new MTM1M3::logevent_appliedThermalForces_ee191da4TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_appliedVelocityForces",topicName) == 0) {
    MTM1M3::logevent_appliedVelocityForces_88f33d5eTypeSupport_var mt = new MTM1M3::logevent_appliedVelocityForces_88f33d5eTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_cellLightStatus",topicName) == 0) {
    MTM1M3::logevent_cellLightStatus_2a963d17TypeSupport_var mt = new MTM1M3::logevent_cellLightStatus_2a963d17TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_cellLightWarning",topicName) == 0) {
    MTM1M3::logevent_cellLightWarning_0610a3a7TypeSupport_var mt = new MTM1M3::logevent_cellLightWarning_0610a3a7TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_commandRejectionWarning",topicName) == 0) {
    MTM1M3::logevent_commandRejectionWarning_2445d185TypeSupport_var mt = new MTM1M3::logevent_commandRejectionWarning_2445d185TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_detailedState",topicName) == 0) {
    MTM1M3::logevent_detailedState_72060c57TypeSupport_var mt = new MTM1M3::logevent_detailedState_72060c57TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_displacementSensorWarning",topicName) == 0) {
    MTM1M3::logevent_displacementSensorWarning_1035d8b2TypeSupport_var mt = new MTM1M3::logevent_displacementSensorWarning_1035d8b2TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_errorCode",topicName) == 0) {
    MTM1M3::logevent_errorCode_8bce170eTypeSupport_var mt = new MTM1M3::logevent_errorCode_8bce170eTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_forceActuatorForceWarning",topicName) == 0) {
    MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fTypeSupport_var mt = new MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_forceActuatorInfo",topicName) == 0) {
    MTM1M3::logevent_forceActuatorInfo_d0ebe0c5TypeSupport_var mt = new MTM1M3::logevent_forceActuatorInfo_d0ebe0c5TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_forceActuatorState",topicName) == 0) {
    MTM1M3::logevent_forceActuatorState_028222bbTypeSupport_var mt = new MTM1M3::logevent_forceActuatorState_028222bbTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_forceActuatorWarning",topicName) == 0) {
    MTM1M3::logevent_forceActuatorWarning_34b69bc9TypeSupport_var mt = new MTM1M3::logevent_forceActuatorWarning_34b69bc9TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_forceSetpointWarning",topicName) == 0) {
    MTM1M3::logevent_forceSetpointWarning_34a43cf6TypeSupport_var mt = new MTM1M3::logevent_forceSetpointWarning_34a43cf6TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_gyroWarning",topicName) == 0) {
    MTM1M3::logevent_gyroWarning_07c44e13TypeSupport_var mt = new MTM1M3::logevent_gyroWarning_07c44e13TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_hardpointActuatorInfo",topicName) == 0) {
    MTM1M3::logevent_hardpointActuatorInfo_d713e706TypeSupport_var mt = new MTM1M3::logevent_hardpointActuatorInfo_d713e706TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_hardpointActuatorState",topicName) == 0) {
    MTM1M3::logevent_hardpointActuatorState_dfd8f788TypeSupport_var mt = new MTM1M3::logevent_hardpointActuatorState_dfd8f788TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_hardpointActuatorWarning",topicName) == 0) {
    MTM1M3::logevent_hardpointActuatorWarning_dcc7d946TypeSupport_var mt = new MTM1M3::logevent_hardpointActuatorWarning_dcc7d946TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_hardpointMonitorInfo",topicName) == 0) {
    MTM1M3::logevent_hardpointMonitorInfo_5dc92c27TypeSupport_var mt = new MTM1M3::logevent_hardpointMonitorInfo_5dc92c27TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_hardpointMonitorState",topicName) == 0) {
    MTM1M3::logevent_hardpointMonitorState_0dad41d1TypeSupport_var mt = new MTM1M3::logevent_hardpointMonitorState_0dad41d1TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_hardpointMonitorWarning",topicName) == 0) {
    MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8TypeSupport_var mt = new MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_heartbeat",topicName) == 0) {
    MTM1M3::logevent_heartbeat_85347670TypeSupport_var mt = new MTM1M3::logevent_heartbeat_85347670TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_ilcWarning",topicName) == 0) {
    MTM1M3::logevent_ilcWarning_22b9286fTypeSupport_var mt = new MTM1M3::logevent_ilcWarning_22b9286fTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_inclinometerSensorWarning",topicName) == 0) {
    MTM1M3::logevent_inclinometerSensorWarning_4d115eb8TypeSupport_var mt = new MTM1M3::logevent_inclinometerSensorWarning_4d115eb8TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_interlockStatus",topicName) == 0) {
    MTM1M3::logevent_interlockStatus_5c0ae7f7TypeSupport_var mt = new MTM1M3::logevent_interlockStatus_5c0ae7f7TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_interlockWarning",topicName) == 0) {
    MTM1M3::logevent_interlockWarning_bc69e2eaTypeSupport_var mt = new MTM1M3::logevent_interlockWarning_bc69e2eaTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_logLevel",topicName) == 0) {
    MTM1M3::logevent_logLevel_83d14d18TypeSupport_var mt = new MTM1M3::logevent_logLevel_83d14d18TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_logMessage",topicName) == 0) {
    MTM1M3::logevent_logMessage_60a1ee35TypeSupport_var mt = new MTM1M3::logevent_logMessage_60a1ee35TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_modbusResponse",topicName) == 0) {
    MTM1M3::logevent_modbusResponse_9c022b06TypeSupport_var mt = new MTM1M3::logevent_modbusResponse_9c022b06TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_pidInfo",topicName) == 0) {
    MTM1M3::logevent_pidInfo_858eca99TypeSupport_var mt = new MTM1M3::logevent_pidInfo_858eca99TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_powerStatus",topicName) == 0) {
    MTM1M3::logevent_powerStatus_846d5845TypeSupport_var mt = new MTM1M3::logevent_powerStatus_846d5845TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_powerSupplyStatus",topicName) == 0) {
    MTM1M3::logevent_powerSupplyStatus_9f37ac09TypeSupport_var mt = new MTM1M3::logevent_powerSupplyStatus_9f37ac09TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_powerWarning",topicName) == 0) {
    MTM1M3::logevent_powerWarning_cedc8628TypeSupport_var mt = new MTM1M3::logevent_powerWarning_cedc8628TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedAberrationForces",topicName) == 0) {
    MTM1M3::logevent_rejectedAberrationForces_07bb7050TypeSupport_var mt = new MTM1M3::logevent_rejectedAberrationForces_07bb7050TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedAccelerationForces",topicName) == 0) {
    MTM1M3::logevent_rejectedAccelerationForces_b8520238TypeSupport_var mt = new MTM1M3::logevent_rejectedAccelerationForces_b8520238TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedActiveOpticForces",topicName) == 0) {
    MTM1M3::logevent_rejectedActiveOpticForces_b308b353TypeSupport_var mt = new MTM1M3::logevent_rejectedActiveOpticForces_b308b353TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedAzimuthForces",topicName) == 0) {
    MTM1M3::logevent_rejectedAzimuthForces_e69b5c03TypeSupport_var mt = new MTM1M3::logevent_rejectedAzimuthForces_e69b5c03TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedBalanceForces",topicName) == 0) {
    MTM1M3::logevent_rejectedBalanceForces_3d81e3dbTypeSupport_var mt = new MTM1M3::logevent_rejectedBalanceForces_3d81e3dbTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedCylinderForces",topicName) == 0) {
    MTM1M3::logevent_rejectedCylinderForces_f4002407TypeSupport_var mt = new MTM1M3::logevent_rejectedCylinderForces_f4002407TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedElevationForces",topicName) == 0) {
    MTM1M3::logevent_rejectedElevationForces_bf1221a9TypeSupport_var mt = new MTM1M3::logevent_rejectedElevationForces_bf1221a9TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedForces",topicName) == 0) {
    MTM1M3::logevent_rejectedForces_7969f67bTypeSupport_var mt = new MTM1M3::logevent_rejectedForces_7969f67bTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedOffsetForces",topicName) == 0) {
    MTM1M3::logevent_rejectedOffsetForces_9ae34670TypeSupport_var mt = new MTM1M3::logevent_rejectedOffsetForces_9ae34670TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedStaticForces",topicName) == 0) {
    MTM1M3::logevent_rejectedStaticForces_95f4fc51TypeSupport_var mt = new MTM1M3::logevent_rejectedStaticForces_95f4fc51TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedThermalForces",topicName) == 0) {
    MTM1M3::logevent_rejectedThermalForces_bda7bbddTypeSupport_var mt = new MTM1M3::logevent_rejectedThermalForces_bda7bbddTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_rejectedVelocityForces",topicName) == 0) {
    MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fTypeSupport_var mt = new MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_settingVersions",topicName) == 0) {
    MTM1M3::logevent_settingVersions_679fb179TypeSupport_var mt = new MTM1M3::logevent_settingVersions_679fb179TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_settingsApplied",topicName) == 0) {
    MTM1M3::logevent_settingsApplied_61b4dd6eTypeSupport_var mt = new MTM1M3::logevent_settingsApplied_61b4dd6eTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_simulationMode",topicName) == 0) {
    MTM1M3::logevent_simulationMode_a613ee19TypeSupport_var mt = new MTM1M3::logevent_simulationMode_a613ee19TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_softwareVersions",topicName) == 0) {
    MTM1M3::logevent_softwareVersions_ed013250TypeSupport_var mt = new MTM1M3::logevent_softwareVersions_ed013250TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_logevent_summaryState",topicName) == 0) {
    MTM1M3::logevent_summaryState_f936f3fcTypeSupport_var mt = new MTM1M3::logevent_summaryState_f936f3fcTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_outerLoopData",topicName) == 0) {
    MTM1M3::outerLoopData_0cb4c7edTypeSupport_var mt = new MTM1M3::outerLoopData_0cb4c7edTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_pidData",topicName) == 0) {
    MTM1M3::pidData_0bd588edTypeSupport_var mt = new MTM1M3::pidData_0bd588edTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_powerSupplyData",topicName) == 0) {
    MTM1M3::powerSupplyData_daf67bc2TypeSupport_var mt = new MTM1M3::powerSupplyData_daf67bc2TypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }

       if ( strcmp("MTM1M3_ackcmd",topicName) == 0) {
    MTM1M3::ackcmd_004df1cbTypeSupport_var mt = new MTM1M3::ackcmd_004df1cbTypeSupport();
    registerType(mt.in());
          return SAL__OK;
       }
  }
  return SAL__ERR;
}
 salReturn SAL_MTM1M3::salTypeSupport(int actorIdx)
{

       if ( actorIdx == SAL__MTM1M3_accelerometerData_ACTOR ) {
    MTM1M3::accelerometerData_9537e860TypeSupport_var mt = new MTM1M3::accelerometerData_9537e860TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_abort_ACTOR ) {
    MTM1M3::command_abort_62d3a8d0TypeSupport_var mt = new MTM1M3::command_abort_62d3a8d0TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_abortProfile_ACTOR ) {
    MTM1M3::command_abortProfile_88b2fb6aTypeSupport_var mt = new MTM1M3::command_abortProfile_88b2fb6aTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_abortRaiseM1M3_ACTOR ) {
    MTM1M3::command_abortRaiseM1M3_7afaba9dTypeSupport_var mt = new MTM1M3::command_abortRaiseM1M3_7afaba9dTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_applyAberrationForces_ACTOR ) {
    MTM1M3::command_applyAberrationForces_4f7ead34TypeSupport_var mt = new MTM1M3::command_applyAberrationForces_4f7ead34TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR ) {
    MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dTypeSupport_var mt = new MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_applyActiveOpticForces_ACTOR ) {
    MTM1M3::command_applyActiveOpticForces_c79b863fTypeSupport_var mt = new MTM1M3::command_applyActiveOpticForces_c79b863fTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR ) {
    MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bTypeSupport_var mt = new MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_applyOffsetForces_ACTOR ) {
    MTM1M3::command_applyOffsetForces_c715c535TypeSupport_var mt = new MTM1M3::command_applyOffsetForces_c715c535TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR ) {
    MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953TypeSupport_var mt = new MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_clearAberrationForces_ACTOR ) {
    MTM1M3::command_clearAberrationForces_58d2b112TypeSupport_var mt = new MTM1M3::command_clearAberrationForces_58d2b112TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_clearActiveOpticForces_ACTOR ) {
    MTM1M3::command_clearActiveOpticForces_d4ffa42cTypeSupport_var mt = new MTM1M3::command_clearActiveOpticForces_d4ffa42cTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_clearOffsetForces_ACTOR ) {
    MTM1M3::command_clearOffsetForces_0d7f285dTypeSupport_var mt = new MTM1M3::command_clearOffsetForces_0d7f285dTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_disable_ACTOR ) {
    MTM1M3::command_disable_04faa884TypeSupport_var mt = new MTM1M3::command_disable_04faa884TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_disableHardpointChase_ACTOR ) {
    MTM1M3::command_disableHardpointChase_dbe9a16bTypeSupport_var mt = new MTM1M3::command_disableHardpointChase_dbe9a16bTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_disableHardpointCorrections_ACTOR ) {
    MTM1M3::command_disableHardpointCorrections_07d1f2eaTypeSupport_var mt = new MTM1M3::command_disableHardpointCorrections_07d1f2eaTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_enable_ACTOR ) {
    MTM1M3::command_enable_c128bf47TypeSupport_var mt = new MTM1M3::command_enable_c128bf47TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_enableHardpointChase_ACTOR ) {
    MTM1M3::command_enableHardpointChase_49c0d4e1TypeSupport_var mt = new MTM1M3::command_enableHardpointChase_49c0d4e1TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_enableHardpointCorrections_ACTOR ) {
    MTM1M3::command_enableHardpointCorrections_dae9c1ecTypeSupport_var mt = new MTM1M3::command_enableHardpointCorrections_dae9c1ecTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_enterControl_ACTOR ) {
    MTM1M3::command_enterControl_417c941aTypeSupport_var mt = new MTM1M3::command_enterControl_417c941aTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_enterEngineering_ACTOR ) {
    MTM1M3::command_enterEngineering_89e1ff1cTypeSupport_var mt = new MTM1M3::command_enterEngineering_89e1ff1cTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_exitControl_ACTOR ) {
    MTM1M3::command_exitControl_e2ea247dTypeSupport_var mt = new MTM1M3::command_exitControl_e2ea247dTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_exitEngineering_ACTOR ) {
    MTM1M3::command_exitEngineering_01073d21TypeSupport_var mt = new MTM1M3::command_exitEngineering_01073d21TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_lowerM1M3_ACTOR ) {
    MTM1M3::command_lowerM1M3_69afda69TypeSupport_var mt = new MTM1M3::command_lowerM1M3_69afda69TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_modbusTransmit_ACTOR ) {
    MTM1M3::command_modbusTransmit_a3c81bdeTypeSupport_var mt = new MTM1M3::command_modbusTransmit_a3c81bdeTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_moveHardpointActuators_ACTOR ) {
    MTM1M3::command_moveHardpointActuators_4d114fabTypeSupport_var mt = new MTM1M3::command_moveHardpointActuators_4d114fabTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_positionM1M3_ACTOR ) {
    MTM1M3::command_positionM1M3_fa7ca786TypeSupport_var mt = new MTM1M3::command_positionM1M3_fa7ca786TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_programILC_ACTOR ) {
    MTM1M3::command_programILC_7dde50eeTypeSupport_var mt = new MTM1M3::command_programILC_7dde50eeTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_raiseM1M3_ACTOR ) {
    MTM1M3::command_raiseM1M3_f0a54745TypeSupport_var mt = new MTM1M3::command_raiseM1M3_f0a54745TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_resetPID_ACTOR ) {
    MTM1M3::command_resetPID_bc5508ceTypeSupport_var mt = new MTM1M3::command_resetPID_bc5508ceTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_runMirrorForceProfile_ACTOR ) {
    MTM1M3::command_runMirrorForceProfile_33f2be6cTypeSupport_var mt = new MTM1M3::command_runMirrorForceProfile_33f2be6cTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_setLogLevel_ACTOR ) {
    MTM1M3::command_setLogLevel_346fd770TypeSupport_var mt = new MTM1M3::command_setLogLevel_346fd770TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_setSimulationMode_ACTOR ) {
    MTM1M3::command_setSimulationMode_dccc3b3cTypeSupport_var mt = new MTM1M3::command_setSimulationMode_dccc3b3cTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_setThermalSetpoint_ACTOR ) {
    MTM1M3::command_setThermalSetpoint_ca5041e8TypeSupport_var mt = new MTM1M3::command_setThermalSetpoint_ca5041e8TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_setValue_ACTOR ) {
    MTM1M3::command_setValue_56638307TypeSupport_var mt = new MTM1M3::command_setValue_56638307TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_shutdown_ACTOR ) {
    MTM1M3::command_shutdown_46d06e01TypeSupport_var mt = new MTM1M3::command_shutdown_46d06e01TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_standby_ACTOR ) {
    MTM1M3::command_standby_9b43256cTypeSupport_var mt = new MTM1M3::command_standby_9b43256cTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_start_ACTOR ) {
    MTM1M3::command_start_63435b30TypeSupport_var mt = new MTM1M3::command_start_63435b30TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_stopHardpointMotion_ACTOR ) {
    MTM1M3::command_stopHardpointMotion_727b2152TypeSupport_var mt = new MTM1M3::command_stopHardpointMotion_727b2152TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_testAir_ACTOR ) {
    MTM1M3::command_testAir_37cd327cTypeSupport_var mt = new MTM1M3::command_testAir_37cd327cTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_testForceActuator_ACTOR ) {
    MTM1M3::command_testForceActuator_f1a37131TypeSupport_var mt = new MTM1M3::command_testForceActuator_f1a37131TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_testHardpoint_ACTOR ) {
    MTM1M3::command_testHardpoint_3736f433TypeSupport_var mt = new MTM1M3::command_testHardpoint_3736f433TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_translateM1M3_ACTOR ) {
    MTM1M3::command_translateM1M3_4d0dfbfeTypeSupport_var mt = new MTM1M3::command_translateM1M3_4d0dfbfeTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_turnAirOff_ACTOR ) {
    MTM1M3::command_turnAirOff_1054819eTypeSupport_var mt = new MTM1M3::command_turnAirOff_1054819eTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_turnAirOn_ACTOR ) {
    MTM1M3::command_turnAirOn_acc6807cTypeSupport_var mt = new MTM1M3::command_turnAirOn_acc6807cTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_turnLightsOff_ACTOR ) {
    MTM1M3::command_turnLightsOff_08b6e5a2TypeSupport_var mt = new MTM1M3::command_turnLightsOff_08b6e5a2TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_turnLightsOn_ACTOR ) {
    MTM1M3::command_turnLightsOn_89e80426TypeSupport_var mt = new MTM1M3::command_turnLightsOn_89e80426TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_turnPowerOff_ACTOR ) {
    MTM1M3::command_turnPowerOff_41dde1fdTypeSupport_var mt = new MTM1M3::command_turnPowerOff_41dde1fdTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_turnPowerOn_ACTOR ) {
    MTM1M3::command_turnPowerOn_7c3fbe06TypeSupport_var mt = new MTM1M3::command_turnPowerOn_7c3fbe06TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_command_updatePID_ACTOR ) {
    MTM1M3::command_updatePID_6e2af9f8TypeSupport_var mt = new MTM1M3::command_updatePID_6e2af9f8TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_forceActuatorData_ACTOR ) {
    MTM1M3::forceActuatorData_5d276d43TypeSupport_var mt = new MTM1M3::forceActuatorData_5d276d43TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_gyroData_ACTOR ) {
    MTM1M3::gyroData_52effccaTypeSupport_var mt = new MTM1M3::gyroData_52effccaTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_hardpointActuatorData_ACTOR ) {
    MTM1M3::hardpointActuatorData_e4c2857fTypeSupport_var mt = new MTM1M3::hardpointActuatorData_e4c2857fTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_hardpointMonitorData_ACTOR ) {
    MTM1M3::hardpointMonitorData_8caedbd0TypeSupport_var mt = new MTM1M3::hardpointMonitorData_8caedbd0TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_imsData_ACTOR ) {
    MTM1M3::imsData_dd412900TypeSupport_var mt = new MTM1M3::imsData_dd412900TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_inclinometerData_ACTOR ) {
    MTM1M3::inclinometerData_6233a3d3TypeSupport_var mt = new MTM1M3::inclinometerData_6233a3d3TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_accelerometerWarning_ACTOR ) {
    MTM1M3::logevent_accelerometerWarning_aa15b0aaTypeSupport_var mt = new MTM1M3::logevent_accelerometerWarning_aa15b0aaTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_airSupplyStatus_ACTOR ) {
    MTM1M3::logevent_airSupplyStatus_da397eb1TypeSupport_var mt = new MTM1M3::logevent_airSupplyStatus_da397eb1TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_airSupplyWarning_ACTOR ) {
    MTM1M3::logevent_airSupplyWarning_52167fbeTypeSupport_var mt = new MTM1M3::logevent_airSupplyWarning_52167fbeTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR ) {
    MTM1M3::logevent_appliedAberrationForces_d72ce7afTypeSupport_var mt = new MTM1M3::logevent_appliedAberrationForces_d72ce7afTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR ) {
    MTM1M3::logevent_appliedAccelerationForces_e2698a2bTypeSupport_var mt = new MTM1M3::logevent_appliedAccelerationForces_e2698a2bTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR ) {
    MTM1M3::logevent_appliedActiveOpticForces_4f827b4bTypeSupport_var mt = new MTM1M3::logevent_appliedActiveOpticForces_4f827b4bTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR ) {
    MTM1M3::logevent_appliedAzimuthForces_7357e272TypeSupport_var mt = new MTM1M3::logevent_appliedAzimuthForces_7357e272TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR ) {
    MTM1M3::logevent_appliedBalanceForces_3f4cca0aTypeSupport_var mt = new MTM1M3::logevent_appliedBalanceForces_3f4cca0aTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR ) {
    MTM1M3::logevent_appliedCylinderForces_b0d7e6d8TypeSupport_var mt = new MTM1M3::logevent_appliedCylinderForces_b0d7e6d8TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedElevationForces_ACTOR ) {
    MTM1M3::logevent_appliedElevationForces_fa715255TypeSupport_var mt = new MTM1M3::logevent_appliedElevationForces_fa715255TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedForces_ACTOR ) {
    MTM1M3::logevent_appliedForces_1d16999dTypeSupport_var mt = new MTM1M3::logevent_appliedForces_1d16999dTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR ) {
    MTM1M3::logevent_appliedOffsetForces_f19befd6TypeSupport_var mt = new MTM1M3::logevent_appliedOffsetForces_f19befd6TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR ) {
    MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59TypeSupport_var mt = new MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedStaticForces_ACTOR ) {
    MTM1M3::logevent_appliedStaticForces_b210fd2dTypeSupport_var mt = new MTM1M3::logevent_appliedStaticForces_b210fd2dTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedThermalForces_ACTOR ) {
    MTM1M3::logevent_appliedThermalForces_ee191da4TypeSupport_var mt = new MTM1M3::logevent_appliedThermalForces_ee191da4TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR ) {
    MTM1M3::logevent_appliedVelocityForces_88f33d5eTypeSupport_var mt = new MTM1M3::logevent_appliedVelocityForces_88f33d5eTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_cellLightStatus_ACTOR ) {
    MTM1M3::logevent_cellLightStatus_2a963d17TypeSupport_var mt = new MTM1M3::logevent_cellLightStatus_2a963d17TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_cellLightWarning_ACTOR ) {
    MTM1M3::logevent_cellLightWarning_0610a3a7TypeSupport_var mt = new MTM1M3::logevent_cellLightWarning_0610a3a7TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR ) {
    MTM1M3::logevent_commandRejectionWarning_2445d185TypeSupport_var mt = new MTM1M3::logevent_commandRejectionWarning_2445d185TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_detailedState_ACTOR ) {
    MTM1M3::logevent_detailedState_72060c57TypeSupport_var mt = new MTM1M3::logevent_detailedState_72060c57TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR ) {
    MTM1M3::logevent_displacementSensorWarning_1035d8b2TypeSupport_var mt = new MTM1M3::logevent_displacementSensorWarning_1035d8b2TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_errorCode_ACTOR ) {
    MTM1M3::logevent_errorCode_8bce170eTypeSupport_var mt = new MTM1M3::logevent_errorCode_8bce170eTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR ) {
    MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fTypeSupport_var mt = new MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR ) {
    MTM1M3::logevent_forceActuatorInfo_d0ebe0c5TypeSupport_var mt = new MTM1M3::logevent_forceActuatorInfo_d0ebe0c5TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_forceActuatorState_ACTOR ) {
    MTM1M3::logevent_forceActuatorState_028222bbTypeSupport_var mt = new MTM1M3::logevent_forceActuatorState_028222bbTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR ) {
    MTM1M3::logevent_forceActuatorWarning_34b69bc9TypeSupport_var mt = new MTM1M3::logevent_forceActuatorWarning_34b69bc9TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR ) {
    MTM1M3::logevent_forceSetpointWarning_34a43cf6TypeSupport_var mt = new MTM1M3::logevent_forceSetpointWarning_34a43cf6TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_gyroWarning_ACTOR ) {
    MTM1M3::logevent_gyroWarning_07c44e13TypeSupport_var mt = new MTM1M3::logevent_gyroWarning_07c44e13TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR ) {
    MTM1M3::logevent_hardpointActuatorInfo_d713e706TypeSupport_var mt = new MTM1M3::logevent_hardpointActuatorInfo_d713e706TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR ) {
    MTM1M3::logevent_hardpointActuatorState_dfd8f788TypeSupport_var mt = new MTM1M3::logevent_hardpointActuatorState_dfd8f788TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR ) {
    MTM1M3::logevent_hardpointActuatorWarning_dcc7d946TypeSupport_var mt = new MTM1M3::logevent_hardpointActuatorWarning_dcc7d946TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR ) {
    MTM1M3::logevent_hardpointMonitorInfo_5dc92c27TypeSupport_var mt = new MTM1M3::logevent_hardpointMonitorInfo_5dc92c27TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR ) {
    MTM1M3::logevent_hardpointMonitorState_0dad41d1TypeSupport_var mt = new MTM1M3::logevent_hardpointMonitorState_0dad41d1TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR ) {
    MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8TypeSupport_var mt = new MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_heartbeat_ACTOR ) {
    MTM1M3::logevent_heartbeat_85347670TypeSupport_var mt = new MTM1M3::logevent_heartbeat_85347670TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_ilcWarning_ACTOR ) {
    MTM1M3::logevent_ilcWarning_22b9286fTypeSupport_var mt = new MTM1M3::logevent_ilcWarning_22b9286fTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR ) {
    MTM1M3::logevent_inclinometerSensorWarning_4d115eb8TypeSupport_var mt = new MTM1M3::logevent_inclinometerSensorWarning_4d115eb8TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_interlockStatus_ACTOR ) {
    MTM1M3::logevent_interlockStatus_5c0ae7f7TypeSupport_var mt = new MTM1M3::logevent_interlockStatus_5c0ae7f7TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_interlockWarning_ACTOR ) {
    MTM1M3::logevent_interlockWarning_bc69e2eaTypeSupport_var mt = new MTM1M3::logevent_interlockWarning_bc69e2eaTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_logLevel_ACTOR ) {
    MTM1M3::logevent_logLevel_83d14d18TypeSupport_var mt = new MTM1M3::logevent_logLevel_83d14d18TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_logMessage_ACTOR ) {
    MTM1M3::logevent_logMessage_60a1ee35TypeSupport_var mt = new MTM1M3::logevent_logMessage_60a1ee35TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_modbusResponse_ACTOR ) {
    MTM1M3::logevent_modbusResponse_9c022b06TypeSupport_var mt = new MTM1M3::logevent_modbusResponse_9c022b06TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_pidInfo_ACTOR ) {
    MTM1M3::logevent_pidInfo_858eca99TypeSupport_var mt = new MTM1M3::logevent_pidInfo_858eca99TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_powerStatus_ACTOR ) {
    MTM1M3::logevent_powerStatus_846d5845TypeSupport_var mt = new MTM1M3::logevent_powerStatus_846d5845TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR ) {
    MTM1M3::logevent_powerSupplyStatus_9f37ac09TypeSupport_var mt = new MTM1M3::logevent_powerSupplyStatus_9f37ac09TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_powerWarning_ACTOR ) {
    MTM1M3::logevent_powerWarning_cedc8628TypeSupport_var mt = new MTM1M3::logevent_powerWarning_cedc8628TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR ) {
    MTM1M3::logevent_rejectedAberrationForces_07bb7050TypeSupport_var mt = new MTM1M3::logevent_rejectedAberrationForces_07bb7050TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR ) {
    MTM1M3::logevent_rejectedAccelerationForces_b8520238TypeSupport_var mt = new MTM1M3::logevent_rejectedAccelerationForces_b8520238TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR ) {
    MTM1M3::logevent_rejectedActiveOpticForces_b308b353TypeSupport_var mt = new MTM1M3::logevent_rejectedActiveOpticForces_b308b353TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR ) {
    MTM1M3::logevent_rejectedAzimuthForces_e69b5c03TypeSupport_var mt = new MTM1M3::logevent_rejectedAzimuthForces_e69b5c03TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR ) {
    MTM1M3::logevent_rejectedBalanceForces_3d81e3dbTypeSupport_var mt = new MTM1M3::logevent_rejectedBalanceForces_3d81e3dbTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR ) {
    MTM1M3::logevent_rejectedCylinderForces_f4002407TypeSupport_var mt = new MTM1M3::logevent_rejectedCylinderForces_f4002407TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR ) {
    MTM1M3::logevent_rejectedElevationForces_bf1221a9TypeSupport_var mt = new MTM1M3::logevent_rejectedElevationForces_bf1221a9TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedForces_ACTOR ) {
    MTM1M3::logevent_rejectedForces_7969f67bTypeSupport_var mt = new MTM1M3::logevent_rejectedForces_7969f67bTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR ) {
    MTM1M3::logevent_rejectedOffsetForces_9ae34670TypeSupport_var mt = new MTM1M3::logevent_rejectedOffsetForces_9ae34670TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR ) {
    MTM1M3::logevent_rejectedStaticForces_95f4fc51TypeSupport_var mt = new MTM1M3::logevent_rejectedStaticForces_95f4fc51TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR ) {
    MTM1M3::logevent_rejectedThermalForces_bda7bbddTypeSupport_var mt = new MTM1M3::logevent_rejectedThermalForces_bda7bbddTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR ) {
    MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fTypeSupport_var mt = new MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_settingVersions_ACTOR ) {
    MTM1M3::logevent_settingVersions_679fb179TypeSupport_var mt = new MTM1M3::logevent_settingVersions_679fb179TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_settingsApplied_ACTOR ) {
    MTM1M3::logevent_settingsApplied_61b4dd6eTypeSupport_var mt = new MTM1M3::logevent_settingsApplied_61b4dd6eTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_simulationMode_ACTOR ) {
    MTM1M3::logevent_simulationMode_a613ee19TypeSupport_var mt = new MTM1M3::logevent_simulationMode_a613ee19TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_softwareVersions_ACTOR ) {
    MTM1M3::logevent_softwareVersions_ed013250TypeSupport_var mt = new MTM1M3::logevent_softwareVersions_ed013250TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_logevent_summaryState_ACTOR ) {
    MTM1M3::logevent_summaryState_f936f3fcTypeSupport_var mt = new MTM1M3::logevent_summaryState_f936f3fcTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_outerLoopData_ACTOR ) {
    MTM1M3::outerLoopData_0cb4c7edTypeSupport_var mt = new MTM1M3::outerLoopData_0cb4c7edTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_pidData_ACTOR ) {
    MTM1M3::pidData_0bd588edTypeSupport_var mt = new MTM1M3::pidData_0bd588edTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_powerSupplyData_ACTOR ) {
    MTM1M3::powerSupplyData_daf67bc2TypeSupport_var mt = new MTM1M3::powerSupplyData_daf67bc2TypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }

       if ( actorIdx == SAL__MTM1M3_ackcmd_ACTOR ) {
    MTM1M3::ackcmd_004df1cbTypeSupport_var mt = new MTM1M3::ackcmd_004df1cbTypeSupport();
    registerType(actorIdx,mt.in());
          return SAL__OK;
       }
  return SAL__ERR;
}

std::vector<std::string> SAL_MTM1M3::getCommandNames()
{
    std::vector<std::string> it;
    it.push_back("abort");
    it.push_back("abortProfile");
    it.push_back("abortRaiseM1M3");
    it.push_back("applyAberrationForces");
    it.push_back("applyAberrationForcesByBendingModes");
    it.push_back("applyActiveOpticForces");
    it.push_back("applyActiveOpticForcesByBendingModes");
    it.push_back("applyOffsetForces");
    it.push_back("applyOffsetForcesByMirrorForce");
    it.push_back("clearAberrationForces");
    it.push_back("clearActiveOpticForces");
    it.push_back("clearOffsetForces");
    it.push_back("disable");
    it.push_back("disableHardpointChase");
    it.push_back("disableHardpointCorrections");
    it.push_back("enable");
    it.push_back("enableHardpointChase");
    it.push_back("enableHardpointCorrections");
    it.push_back("enterControl");
    it.push_back("enterEngineering");
    it.push_back("exitControl");
    it.push_back("exitEngineering");
    it.push_back("lowerM1M3");
    it.push_back("modbusTransmit");
    it.push_back("moveHardpointActuators");
    it.push_back("positionM1M3");
    it.push_back("programILC");
    it.push_back("raiseM1M3");
    it.push_back("resetPID");
    it.push_back("runMirrorForceProfile");
    it.push_back("setLogLevel");
    it.push_back("setSimulationMode");
    it.push_back("setThermalSetpoint");
    it.push_back("setValue");
    it.push_back("shutdown");
    it.push_back("standby");
    it.push_back("start");
    it.push_back("stopHardpointMotion");
    it.push_back("testAir");
    it.push_back("testForceActuator");
    it.push_back("testHardpoint");
    it.push_back("translateM1M3");
    it.push_back("turnAirOff");
    it.push_back("turnAirOn");
    it.push_back("turnLightsOff");
    it.push_back("turnLightsOn");
    it.push_back("turnPowerOff");
    it.push_back("turnPowerOn");
    it.push_back("updatePID");
    return it;
}


std::vector<std::string> SAL_MTM1M3::getEventNames()
{
    std::vector<std::string> it;
    it.push_back("accelerometerWarning");
    it.push_back("airSupplyStatus");
    it.push_back("airSupplyWarning");
    it.push_back("appliedAberrationForces");
    it.push_back("appliedAccelerationForces");
    it.push_back("appliedActiveOpticForces");
    it.push_back("appliedAzimuthForces");
    it.push_back("appliedBalanceForces");
    it.push_back("appliedCylinderForces");
    it.push_back("appliedElevationForces");
    it.push_back("appliedForces");
    it.push_back("appliedOffsetForces");
    it.push_back("appliedSettingsMatchStart");
    it.push_back("appliedStaticForces");
    it.push_back("appliedThermalForces");
    it.push_back("appliedVelocityForces");
    it.push_back("cellLightStatus");
    it.push_back("cellLightWarning");
    it.push_back("commandRejectionWarning");
    it.push_back("detailedState");
    it.push_back("displacementSensorWarning");
    it.push_back("errorCode");
    it.push_back("forceActuatorForceWarning");
    it.push_back("forceActuatorInfo");
    it.push_back("forceActuatorState");
    it.push_back("forceActuatorWarning");
    it.push_back("forceSetpointWarning");
    it.push_back("gyroWarning");
    it.push_back("hardpointActuatorInfo");
    it.push_back("hardpointActuatorState");
    it.push_back("hardpointActuatorWarning");
    it.push_back("hardpointMonitorInfo");
    it.push_back("hardpointMonitorState");
    it.push_back("hardpointMonitorWarning");
    it.push_back("heartbeat");
    it.push_back("ilcWarning");
    it.push_back("inclinometerSensorWarning");
    it.push_back("interlockStatus");
    it.push_back("interlockWarning");
    it.push_back("logLevel");
    it.push_back("logMessage");
    it.push_back("modbusResponse");
    it.push_back("pidInfo");
    it.push_back("powerStatus");
    it.push_back("powerSupplyStatus");
    it.push_back("powerWarning");
    it.push_back("rejectedAberrationForces");
    it.push_back("rejectedAccelerationForces");
    it.push_back("rejectedActiveOpticForces");
    it.push_back("rejectedAzimuthForces");
    it.push_back("rejectedBalanceForces");
    it.push_back("rejectedCylinderForces");
    it.push_back("rejectedElevationForces");
    it.push_back("rejectedForces");
    it.push_back("rejectedOffsetForces");
    it.push_back("rejectedStaticForces");
    it.push_back("rejectedThermalForces");
    it.push_back("rejectedVelocityForces");
    it.push_back("settingVersions");
    it.push_back("settingsApplied");
    it.push_back("simulationMode");
    it.push_back("softwareVersions");
    it.push_back("summaryState");
    return it;
}


std::vector<std::string> SAL_MTM1M3::getTelemetryNames()
{
    std::vector<std::string> it;
    it.push_back("accelerometerData");
    it.push_back("forceActuatorData");
    it.push_back("gyroData");
    it.push_back("hardpointActuatorData");
    it.push_back("hardpointMonitorData");
    it.push_back("imsData");
    it.push_back("inclinometerData");
    it.push_back("outerLoopData");
    it.push_back("pidData");
    it.push_back("powerSupplyData");
    return it;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::accelerometerData_9537e860 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_accelerometerData");
  }
  MTM1M3::accelerometerData_9537e860DataWriter_var SALWriter = MTM1M3::accelerometerData_9537e860DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("9537e860");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::accelerometerData_9537e860 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::accelerometerData_9537e860DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::accelerometerData_9537e860Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_accelerometerData");
  }
  MTM1M3::accelerometerData_9537e860DataReader_var SALReader = MTM1M3::accelerometerData_9537e860DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::accelerometerData_9537e860DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::accelerometerData_9537e860DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::accelerometerData_9537e860DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_accelerometerData(MTM1M3_accelerometerDataC *data)
{
  int actorIdx = SAL__MTM1M3_accelerometerData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_accelerometerData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_accelerometerData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::accelerometerData_9537e860DataWriter_var SALWriter = MTM1M3::accelerometerData_9537e860DataWriter::_narrow(dwriter.in());
  MTM1M3::accelerometerData_9537e860 Instance;

  Instance.private_revCode = DDS::string_dup("9537e860");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<8;iseq++) {Instance.rawAccelerometer[iseq] = data->rawAccelerometer[iseq];}
    for (int iseq=0;iseq<8;iseq++) {Instance.accelerometer[iseq] = data->accelerometer[iseq];}
    Instance.angularAccelerationX = data->angularAccelerationX;
    Instance.angularAccelerationY = data->angularAccelerationY;
    Instance.angularAccelerationZ = data->angularAccelerationZ;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::accelerometerData_9537e860 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::accelerometerData_9537e860DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_accelerometerData(MTM1M3_accelerometerDataC *data)
{
  MTM1M3::accelerometerData_9537e860Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_accelerometerData");
  }
  int actorIdx = SAL__MTM1M3_accelerometerData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_accelerometerData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::accelerometerData_9537e860DataReader_var SALReader = MTM1M3::accelerometerData_9537e860DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::accelerometerData_9537e860DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_accelerometerData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::accelerometerData_9537e860DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_accelerometerData.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<8;iseq++) {data->rawAccelerometer[iseq] = Instances[j].rawAccelerometer[iseq];}
    for (int iseq=0;iseq<8;iseq++) {lastSample_MTM1M3_accelerometerData.rawAccelerometer[iseq] = Instances[j].rawAccelerometer[iseq];}
    for (int iseq=0;iseq<8;iseq++) {data->accelerometer[iseq] = Instances[j].accelerometer[iseq];}
    for (int iseq=0;iseq<8;iseq++) {lastSample_MTM1M3_accelerometerData.accelerometer[iseq] = Instances[j].accelerometer[iseq];}
    data->angularAccelerationX = Instances[j].angularAccelerationX;
    lastSample_MTM1M3_accelerometerData.angularAccelerationX = Instances[j].angularAccelerationX;
    data->angularAccelerationY = Instances[j].angularAccelerationY;
    lastSample_MTM1M3_accelerometerData.angularAccelerationY = Instances[j].angularAccelerationY;
    data->angularAccelerationZ = Instances[j].angularAccelerationZ;
    lastSample_MTM1M3_accelerometerData.angularAccelerationZ = Instances[j].angularAccelerationZ;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::accelerometerData_9537e860DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_accelerometerData(MTM1M3_accelerometerDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_accelerometerData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_accelerometerData_ACTOR].maxSamples = 1;
    istatus = getSample_accelerometerData(data);
    sal[SAL__MTM1M3_accelerometerData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_accelerometerData(MTM1M3_accelerometerDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_accelerometerData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_accelerometerData.timestamp;
    for (int iseq=0;iseq<8;iseq++) {data->rawAccelerometer[iseq] = lastSample_MTM1M3_accelerometerData.rawAccelerometer[iseq];}
    for (int iseq=0;iseq<8;iseq++) {data->accelerometer[iseq] = lastSample_MTM1M3_accelerometerData.accelerometer[iseq];}
   data->angularAccelerationX = lastSample_MTM1M3_accelerometerData.angularAccelerationX;
   data->angularAccelerationY = lastSample_MTM1M3_accelerometerData.angularAccelerationY;
   data->angularAccelerationZ = lastSample_MTM1M3_accelerometerData.angularAccelerationZ;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_accelerometerData(MTM1M3_accelerometerDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_accelerometerData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_accelerometerData_ACTOR].sampleAge = -1.0;
    istatus = getSample_accelerometerData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_accelerometerData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_abort_62d3a8d0 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_abort");
  }
  MTM1M3::command_abort_62d3a8d0DataWriter_var SALWriter = MTM1M3::command_abort_62d3a8d0DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("62d3a8d0");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_abort_62d3a8d0 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_abort_62d3a8d0DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_abort_62d3a8d0Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_abort");
  }
  MTM1M3::command_abort_62d3a8d0DataReader_var SALReader = MTM1M3::command_abort_62d3a8d0DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abort_62d3a8d0DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_abort_62d3a8d0DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_abort_62d3a8d0DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_abort(MTM1M3_command_abortC *data)
{
  int actorIdx = SAL__MTM1M3_command_abort_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_abort");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_abort");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_abort_62d3a8d0DataWriter_var SALWriter = MTM1M3::command_abort_62d3a8d0DataWriter::_narrow(dwriter.in());
  MTM1M3::command_abort_62d3a8d0 Instance;

  Instance.private_revCode = DDS::string_dup("62d3a8d0");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.value = data->value;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_abort_62d3a8d0 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_abort_62d3a8d0DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_abort(MTM1M3_command_abortC *data)
{
  MTM1M3::command_abort_62d3a8d0Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_abort");
  }
  int actorIdx = SAL__MTM1M3_command_abort_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_abort");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_abort_62d3a8d0DataReader_var SALReader = MTM1M3::command_abort_62d3a8d0DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abort_62d3a8d0DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_abort_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_abort_62d3a8d0DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->value = Instances[j].value;
    lastSample_MTM1M3_command_abort.value = Instances[j].value;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_abort_62d3a8d0DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_abort(MTM1M3_command_abortC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_abort_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_abort_ACTOR].maxSamples = 1;
    istatus = getSample_command_abort(data);
    sal[SAL__MTM1M3_command_abort_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_abort(MTM1M3_command_abortC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_abort(data);
    if (istatus == SAL__NO_UPDATES) {
   data->value = lastSample_MTM1M3_command_abort.value;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_abort(MTM1M3_command_abortC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_abort_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_abort_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_abort(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_abort_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_abortProfile_88b2fb6a data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_abortProfile");
  }
  MTM1M3::command_abortProfile_88b2fb6aDataWriter_var SALWriter = MTM1M3::command_abortProfile_88b2fb6aDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("88b2fb6a");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_abortProfile_88b2fb6a writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_abortProfile_88b2fb6aDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_abortProfile_88b2fb6aSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_abortProfile");
  }
  MTM1M3::command_abortProfile_88b2fb6aDataReader_var SALReader = MTM1M3::command_abortProfile_88b2fb6aDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abortProfile_88b2fb6aDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_abortProfile_88b2fb6aDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_abortProfile_88b2fb6aDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_abortProfile(MTM1M3_command_abortProfileC *data)
{
  int actorIdx = SAL__MTM1M3_command_abortProfile_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_abortProfile");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_abortProfile");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_abortProfile_88b2fb6aDataWriter_var SALWriter = MTM1M3::command_abortProfile_88b2fb6aDataWriter::_narrow(dwriter.in());
  MTM1M3::command_abortProfile_88b2fb6a Instance;

  Instance.private_revCode = DDS::string_dup("88b2fb6a");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.abortProfile = data->abortProfile;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_abortProfile_88b2fb6a writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_abortProfile_88b2fb6aDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_abortProfile(MTM1M3_command_abortProfileC *data)
{
  MTM1M3::command_abortProfile_88b2fb6aSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_abortProfile");
  }
  int actorIdx = SAL__MTM1M3_command_abortProfile_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_abortProfile");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_abortProfile_88b2fb6aDataReader_var SALReader = MTM1M3::command_abortProfile_88b2fb6aDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abortProfile_88b2fb6aDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_abortProfile_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_abortProfile_88b2fb6aDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->abortProfile = Instances[j].abortProfile;
    lastSample_MTM1M3_command_abortProfile.abortProfile = Instances[j].abortProfile;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_abortProfile_88b2fb6aDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_abortProfile(MTM1M3_command_abortProfileC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_abortProfile_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_abortProfile_ACTOR].maxSamples = 1;
    istatus = getSample_command_abortProfile(data);
    sal[SAL__MTM1M3_command_abortProfile_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_abortProfile(MTM1M3_command_abortProfileC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_abortProfile(data);
    if (istatus == SAL__NO_UPDATES) {
   data->abortProfile = lastSample_MTM1M3_command_abortProfile.abortProfile;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_abortProfile(MTM1M3_command_abortProfileC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_abortProfile_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_abortProfile_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_abortProfile(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_abortProfile_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_abortRaiseM1M3_7afaba9d data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_abortRaiseM1M3");
  }
  MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter_var SALWriter = MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("7afaba9d");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_abortRaiseM1M3_7afaba9d writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_abortRaiseM1M3_7afaba9dSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_abortRaiseM1M3");
  }
  MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader_var SALReader = MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_abortRaiseM1M3(MTM1M3_command_abortRaiseM1M3C *data)
{
  int actorIdx = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_abortRaiseM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_abortRaiseM1M3");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter_var SALWriter = MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter::_narrow(dwriter.in());
  MTM1M3::command_abortRaiseM1M3_7afaba9d Instance;

  Instance.private_revCode = DDS::string_dup("7afaba9d");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.abortRaiseM1M3 = data->abortRaiseM1M3;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_abortRaiseM1M3_7afaba9d writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_abortRaiseM1M3(MTM1M3_command_abortRaiseM1M3C *data)
{
  MTM1M3::command_abortRaiseM1M3_7afaba9dSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_abortRaiseM1M3");
  }
  int actorIdx = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_abortRaiseM1M3");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader_var SALReader = MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_abortRaiseM1M3_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->abortRaiseM1M3 = Instances[j].abortRaiseM1M3;
    lastSample_MTM1M3_command_abortRaiseM1M3.abortRaiseM1M3 = Instances[j].abortRaiseM1M3;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_abortRaiseM1M3(MTM1M3_command_abortRaiseM1M3C *data)
{
    int saveMax = sal[SAL__MTM1M3_command_abortRaiseM1M3_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_abortRaiseM1M3_ACTOR].maxSamples = 1;
    istatus = getSample_command_abortRaiseM1M3(data);
    sal[SAL__MTM1M3_command_abortRaiseM1M3_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_abortRaiseM1M3(MTM1M3_command_abortRaiseM1M3C *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_abortRaiseM1M3(data);
    if (istatus == SAL__NO_UPDATES) {
   data->abortRaiseM1M3 = lastSample_MTM1M3_command_abortRaiseM1M3.abortRaiseM1M3;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_abortRaiseM1M3(MTM1M3_command_abortRaiseM1M3C *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_abortRaiseM1M3_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_abortRaiseM1M3_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_abortRaiseM1M3(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_abortRaiseM1M3_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_applyAberrationForces_4f7ead34 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyAberrationForces");
  }
  MTM1M3::command_applyAberrationForces_4f7ead34DataWriter_var SALWriter = MTM1M3::command_applyAberrationForces_4f7ead34DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("4f7ead34");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyAberrationForces_4f7ead34 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_applyAberrationForces_4f7ead34DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_applyAberrationForces_4f7ead34Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyAberrationForces");
  }
  MTM1M3::command_applyAberrationForces_4f7ead34DataReader_var SALReader = MTM1M3::command_applyAberrationForces_4f7ead34DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_applyAberrationForces(MTM1M3_command_applyAberrationForcesC *data)
{
  int actorIdx = SAL__MTM1M3_command_applyAberrationForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_applyAberrationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyAberrationForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyAberrationForces_4f7ead34DataWriter_var SALWriter = MTM1M3::command_applyAberrationForces_4f7ead34DataWriter::_narrow(dwriter.in());
  MTM1M3::command_applyAberrationForces_4f7ead34 Instance;

  Instance.private_revCode = DDS::string_dup("4f7ead34");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyAberrationForces_4f7ead34 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_applyAberrationForces_4f7ead34DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_applyAberrationForces(MTM1M3_command_applyAberrationForcesC *data)
{
  MTM1M3::command_applyAberrationForces_4f7ead34Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_applyAberrationForces");
  }
  int actorIdx = SAL__MTM1M3_command_applyAberrationForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyAberrationForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyAberrationForces_4f7ead34DataReader_var SALReader = MTM1M3::command_applyAberrationForces_4f7ead34DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_applyAberrationForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_command_applyAberrationForces.zForces[iseq] = Instances[j].zForces[iseq];}
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_applyAberrationForces(MTM1M3_command_applyAberrationForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_applyAberrationForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_applyAberrationForces_ACTOR].maxSamples = 1;
    istatus = getSample_command_applyAberrationForces(data);
    sal[SAL__MTM1M3_command_applyAberrationForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_applyAberrationForces(MTM1M3_command_applyAberrationForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_applyAberrationForces(data);
    if (istatus == SAL__NO_UPDATES) {
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_command_applyAberrationForces.zForces[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_applyAberrationForces(MTM1M3_command_applyAberrationForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_applyAberrationForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_applyAberrationForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_applyAberrationForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_applyAberrationForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53d data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyAberrationForcesByBendingModes");
  }
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter_var SALWriter = MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("ef2ea53d");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53d writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyAberrationForcesByBendingModes");
  }
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader_var SALReader = MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_applyAberrationForcesByBendingModes(MTM1M3_command_applyAberrationForcesByBendingModesC *data)
{
  int actorIdx = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_applyAberrationForcesByBendingModes");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyAberrationForcesByBendingModes");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter_var SALWriter = MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter::_narrow(dwriter.in());
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53d Instance;

  Instance.private_revCode = DDS::string_dup("ef2ea53d");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    for (int iseq=0;iseq<22;iseq++) {Instance.coefficients[iseq] = data->coefficients[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53d writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_applyAberrationForcesByBendingModes(MTM1M3_command_applyAberrationForcesByBendingModesC *data)
{
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_applyAberrationForcesByBendingModes");
  }
  int actorIdx = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyAberrationForcesByBendingModes");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader_var SALReader = MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    for (int iseq=0;iseq<22;iseq++) {data->coefficients[iseq] = Instances[j].coefficients[iseq];}
    for (int iseq=0;iseq<22;iseq++) {lastSample_MTM1M3_command_applyAberrationForcesByBendingModes.coefficients[iseq] = Instances[j].coefficients[iseq];}
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_applyAberrationForcesByBendingModes(MTM1M3_command_applyAberrationForcesByBendingModesC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR].maxSamples = 1;
    istatus = getSample_command_applyAberrationForcesByBendingModes(data);
    sal[SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_applyAberrationForcesByBendingModes(MTM1M3_command_applyAberrationForcesByBendingModesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_applyAberrationForcesByBendingModes(data);
    if (istatus == SAL__NO_UPDATES) {
    for (int iseq=0;iseq<22;iseq++) {data->coefficients[iseq] = lastSample_MTM1M3_command_applyAberrationForcesByBendingModes.coefficients[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_applyAberrationForcesByBendingModes(MTM1M3_command_applyAberrationForcesByBendingModesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_applyAberrationForcesByBendingModes(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_applyActiveOpticForces_c79b863f data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyActiveOpticForces");
  }
  MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter_var SALWriter = MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("c79b863f");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyActiveOpticForces_c79b863f writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_applyActiveOpticForces_c79b863fSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyActiveOpticForces");
  }
  MTM1M3::command_applyActiveOpticForces_c79b863fDataReader_var SALReader = MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_applyActiveOpticForces(MTM1M3_command_applyActiveOpticForcesC *data)
{
  int actorIdx = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_applyActiveOpticForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyActiveOpticForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter_var SALWriter = MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter::_narrow(dwriter.in());
  MTM1M3::command_applyActiveOpticForces_c79b863f Instance;

  Instance.private_revCode = DDS::string_dup("c79b863f");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyActiveOpticForces_c79b863f writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_applyActiveOpticForces(MTM1M3_command_applyActiveOpticForcesC *data)
{
  MTM1M3::command_applyActiveOpticForces_c79b863fSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_applyActiveOpticForces");
  }
  int actorIdx = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyActiveOpticForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyActiveOpticForces_c79b863fDataReader_var SALReader = MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_applyActiveOpticForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_command_applyActiveOpticForces.zForces[iseq] = Instances[j].zForces[iseq];}
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_applyActiveOpticForces(MTM1M3_command_applyActiveOpticForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_applyActiveOpticForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_applyActiveOpticForces_ACTOR].maxSamples = 1;
    istatus = getSample_command_applyActiveOpticForces(data);
    sal[SAL__MTM1M3_command_applyActiveOpticForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_applyActiveOpticForces(MTM1M3_command_applyActiveOpticForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_applyActiveOpticForces(data);
    if (istatus == SAL__NO_UPDATES) {
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_command_applyActiveOpticForces.zForces[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_applyActiveOpticForces(MTM1M3_command_applyActiveOpticForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_applyActiveOpticForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_applyActiveOpticForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_applyActiveOpticForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_applyActiveOpticForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5b data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyActiveOpticForcesByBendingModes");
  }
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter_var SALWriter = MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("3b76ff5b");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5b writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyActiveOpticForcesByBendingModes");
  }
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader_var SALReader = MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_applyActiveOpticForcesByBendingModes(MTM1M3_command_applyActiveOpticForcesByBendingModesC *data)
{
  int actorIdx = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_applyActiveOpticForcesByBendingModes");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyActiveOpticForcesByBendingModes");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter_var SALWriter = MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter::_narrow(dwriter.in());
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5b Instance;

  Instance.private_revCode = DDS::string_dup("3b76ff5b");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    for (int iseq=0;iseq<22;iseq++) {Instance.coefficients[iseq] = data->coefficients[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5b writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_applyActiveOpticForcesByBendingModes(MTM1M3_command_applyActiveOpticForcesByBendingModesC *data)
{
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_applyActiveOpticForcesByBendingModes");
  }
  int actorIdx = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyActiveOpticForcesByBendingModes");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader_var SALReader = MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    for (int iseq=0;iseq<22;iseq++) {data->coefficients[iseq] = Instances[j].coefficients[iseq];}
    for (int iseq=0;iseq<22;iseq++) {lastSample_MTM1M3_command_applyActiveOpticForcesByBendingModes.coefficients[iseq] = Instances[j].coefficients[iseq];}
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_applyActiveOpticForcesByBendingModes(MTM1M3_command_applyActiveOpticForcesByBendingModesC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR].maxSamples = 1;
    istatus = getSample_command_applyActiveOpticForcesByBendingModes(data);
    sal[SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_applyActiveOpticForcesByBendingModes(MTM1M3_command_applyActiveOpticForcesByBendingModesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_applyActiveOpticForcesByBendingModes(data);
    if (istatus == SAL__NO_UPDATES) {
    for (int iseq=0;iseq<22;iseq++) {data->coefficients[iseq] = lastSample_MTM1M3_command_applyActiveOpticForcesByBendingModes.coefficients[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_applyActiveOpticForcesByBendingModes(MTM1M3_command_applyActiveOpticForcesByBendingModesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_applyActiveOpticForcesByBendingModes(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_applyOffsetForces_c715c535 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyOffsetForces");
  }
  MTM1M3::command_applyOffsetForces_c715c535DataWriter_var SALWriter = MTM1M3::command_applyOffsetForces_c715c535DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("c715c535");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyOffsetForces_c715c535 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_applyOffsetForces_c715c535DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_applyOffsetForces_c715c535Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyOffsetForces");
  }
  MTM1M3::command_applyOffsetForces_c715c535DataReader_var SALReader = MTM1M3::command_applyOffsetForces_c715c535DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyOffsetForces_c715c535DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyOffsetForces_c715c535DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_applyOffsetForces_c715c535DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_applyOffsetForces(MTM1M3_command_applyOffsetForcesC *data)
{
  int actorIdx = SAL__MTM1M3_command_applyOffsetForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_applyOffsetForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyOffsetForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyOffsetForces_c715c535DataWriter_var SALWriter = MTM1M3::command_applyOffsetForces_c715c535DataWriter::_narrow(dwriter.in());
  MTM1M3::command_applyOffsetForces_c715c535 Instance;

  Instance.private_revCode = DDS::string_dup("c715c535");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyOffsetForces_c715c535 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_applyOffsetForces_c715c535DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_applyOffsetForces(MTM1M3_command_applyOffsetForcesC *data)
{
  MTM1M3::command_applyOffsetForces_c715c535Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_applyOffsetForces");
  }
  int actorIdx = SAL__MTM1M3_command_applyOffsetForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyOffsetForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyOffsetForces_c715c535DataReader_var SALReader = MTM1M3::command_applyOffsetForces_c715c535DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyOffsetForces_c715c535DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_applyOffsetForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyOffsetForces_c715c535DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_command_applyOffsetForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_command_applyOffsetForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_command_applyOffsetForces.zForces[iseq] = Instances[j].zForces[iseq];}
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_applyOffsetForces_c715c535DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_applyOffsetForces(MTM1M3_command_applyOffsetForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_applyOffsetForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_applyOffsetForces_ACTOR].maxSamples = 1;
    istatus = getSample_command_applyOffsetForces(data);
    sal[SAL__MTM1M3_command_applyOffsetForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_applyOffsetForces(MTM1M3_command_applyOffsetForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_applyOffsetForces(data);
    if (istatus == SAL__NO_UPDATES) {
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_command_applyOffsetForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_command_applyOffsetForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_command_applyOffsetForces.zForces[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_applyOffsetForces(MTM1M3_command_applyOffsetForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_applyOffsetForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_applyOffsetForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_applyOffsetForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_applyOffsetForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyOffsetForcesByMirrorForce");
  }
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter_var SALWriter = MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("4d09c953");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyOffsetForcesByMirrorForce");
  }
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader_var SALReader = MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_applyOffsetForcesByMirrorForce(MTM1M3_command_applyOffsetForcesByMirrorForceC *data)
{
  int actorIdx = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_applyOffsetForcesByMirrorForce");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_applyOffsetForcesByMirrorForce");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter_var SALWriter = MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter::_narrow(dwriter.in());
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953 Instance;

  Instance.private_revCode = DDS::string_dup("4d09c953");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.xForce = data->xForce;
    Instance.yForce = data->yForce;
    Instance.zForce = data->zForce;
    Instance.xMoment = data->xMoment;
    Instance.yMoment = data->yMoment;
    Instance.zMoment = data->zMoment;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_applyOffsetForcesByMirrorForce(MTM1M3_command_applyOffsetForcesByMirrorForceC *data)
{
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_applyOffsetForcesByMirrorForce");
  }
  int actorIdx = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_applyOffsetForcesByMirrorForce");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader_var SALReader = MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->xForce = Instances[j].xForce;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.xForce = Instances[j].xForce;
    data->yForce = Instances[j].yForce;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.yForce = Instances[j].yForce;
    data->zForce = Instances[j].zForce;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.zForce = Instances[j].zForce;
    data->xMoment = Instances[j].xMoment;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.xMoment = Instances[j].xMoment;
    data->yMoment = Instances[j].yMoment;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.yMoment = Instances[j].yMoment;
    data->zMoment = Instances[j].zMoment;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.zMoment = Instances[j].zMoment;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_applyOffsetForcesByMirrorForce(MTM1M3_command_applyOffsetForcesByMirrorForceC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR].maxSamples = 1;
    istatus = getSample_command_applyOffsetForcesByMirrorForce(data);
    sal[SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_applyOffsetForcesByMirrorForce(MTM1M3_command_applyOffsetForcesByMirrorForceC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_applyOffsetForcesByMirrorForce(data);
    if (istatus == SAL__NO_UPDATES) {
   data->xForce = lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.xForce;
   data->yForce = lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.yForce;
   data->zForce = lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.zForce;
   data->xMoment = lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.xMoment;
   data->yMoment = lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.yMoment;
   data->zMoment = lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.zMoment;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_applyOffsetForcesByMirrorForce(MTM1M3_command_applyOffsetForcesByMirrorForceC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_applyOffsetForcesByMirrorForce(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_clearAberrationForces_58d2b112 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_clearAberrationForces");
  }
  MTM1M3::command_clearAberrationForces_58d2b112DataWriter_var SALWriter = MTM1M3::command_clearAberrationForces_58d2b112DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("58d2b112");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_clearAberrationForces_58d2b112 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_clearAberrationForces_58d2b112DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_clearAberrationForces_58d2b112Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_clearAberrationForces");
  }
  MTM1M3::command_clearAberrationForces_58d2b112DataReader_var SALReader = MTM1M3::command_clearAberrationForces_58d2b112DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearAberrationForces_58d2b112DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_clearAberrationForces_58d2b112DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_clearAberrationForces_58d2b112DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_clearAberrationForces(MTM1M3_command_clearAberrationForcesC *data)
{
  int actorIdx = SAL__MTM1M3_command_clearAberrationForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_clearAberrationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_clearAberrationForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_clearAberrationForces_58d2b112DataWriter_var SALWriter = MTM1M3::command_clearAberrationForces_58d2b112DataWriter::_narrow(dwriter.in());
  MTM1M3::command_clearAberrationForces_58d2b112 Instance;

  Instance.private_revCode = DDS::string_dup("58d2b112");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.clearAberrationForces = data->clearAberrationForces;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_clearAberrationForces_58d2b112 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_clearAberrationForces_58d2b112DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_clearAberrationForces(MTM1M3_command_clearAberrationForcesC *data)
{
  MTM1M3::command_clearAberrationForces_58d2b112Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_clearAberrationForces");
  }
  int actorIdx = SAL__MTM1M3_command_clearAberrationForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_clearAberrationForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_clearAberrationForces_58d2b112DataReader_var SALReader = MTM1M3::command_clearAberrationForces_58d2b112DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearAberrationForces_58d2b112DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_clearAberrationForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_clearAberrationForces_58d2b112DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->clearAberrationForces = Instances[j].clearAberrationForces;
    lastSample_MTM1M3_command_clearAberrationForces.clearAberrationForces = Instances[j].clearAberrationForces;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_clearAberrationForces_58d2b112DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_clearAberrationForces(MTM1M3_command_clearAberrationForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_clearAberrationForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_clearAberrationForces_ACTOR].maxSamples = 1;
    istatus = getSample_command_clearAberrationForces(data);
    sal[SAL__MTM1M3_command_clearAberrationForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_clearAberrationForces(MTM1M3_command_clearAberrationForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_clearAberrationForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->clearAberrationForces = lastSample_MTM1M3_command_clearAberrationForces.clearAberrationForces;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_clearAberrationForces(MTM1M3_command_clearAberrationForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_clearAberrationForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_clearAberrationForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_clearAberrationForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_clearAberrationForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_clearActiveOpticForces_d4ffa42c data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_clearActiveOpticForces");
  }
  MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter_var SALWriter = MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("d4ffa42c");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_clearActiveOpticForces_d4ffa42c writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_clearActiveOpticForces_d4ffa42cSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_clearActiveOpticForces");
  }
  MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader_var SALReader = MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_clearActiveOpticForces(MTM1M3_command_clearActiveOpticForcesC *data)
{
  int actorIdx = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_clearActiveOpticForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_clearActiveOpticForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter_var SALWriter = MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter::_narrow(dwriter.in());
  MTM1M3::command_clearActiveOpticForces_d4ffa42c Instance;

  Instance.private_revCode = DDS::string_dup("d4ffa42c");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.clearActiveOpticForces = data->clearActiveOpticForces;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_clearActiveOpticForces_d4ffa42c writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_clearActiveOpticForces(MTM1M3_command_clearActiveOpticForcesC *data)
{
  MTM1M3::command_clearActiveOpticForces_d4ffa42cSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_clearActiveOpticForces");
  }
  int actorIdx = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_clearActiveOpticForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader_var SALReader = MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_clearActiveOpticForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->clearActiveOpticForces = Instances[j].clearActiveOpticForces;
    lastSample_MTM1M3_command_clearActiveOpticForces.clearActiveOpticForces = Instances[j].clearActiveOpticForces;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_clearActiveOpticForces(MTM1M3_command_clearActiveOpticForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_clearActiveOpticForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_clearActiveOpticForces_ACTOR].maxSamples = 1;
    istatus = getSample_command_clearActiveOpticForces(data);
    sal[SAL__MTM1M3_command_clearActiveOpticForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_clearActiveOpticForces(MTM1M3_command_clearActiveOpticForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_clearActiveOpticForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->clearActiveOpticForces = lastSample_MTM1M3_command_clearActiveOpticForces.clearActiveOpticForces;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_clearActiveOpticForces(MTM1M3_command_clearActiveOpticForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_clearActiveOpticForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_clearActiveOpticForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_clearActiveOpticForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_clearActiveOpticForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_clearOffsetForces_0d7f285d data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_clearOffsetForces");
  }
  MTM1M3::command_clearOffsetForces_0d7f285dDataWriter_var SALWriter = MTM1M3::command_clearOffsetForces_0d7f285dDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("0d7f285d");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_clearOffsetForces_0d7f285d writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_clearOffsetForces_0d7f285dDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_clearOffsetForces_0d7f285dSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_clearOffsetForces");
  }
  MTM1M3::command_clearOffsetForces_0d7f285dDataReader_var SALReader = MTM1M3::command_clearOffsetForces_0d7f285dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_clearOffsetForces(MTM1M3_command_clearOffsetForcesC *data)
{
  int actorIdx = SAL__MTM1M3_command_clearOffsetForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_clearOffsetForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_clearOffsetForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_clearOffsetForces_0d7f285dDataWriter_var SALWriter = MTM1M3::command_clearOffsetForces_0d7f285dDataWriter::_narrow(dwriter.in());
  MTM1M3::command_clearOffsetForces_0d7f285d Instance;

  Instance.private_revCode = DDS::string_dup("0d7f285d");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.clearOffsetForces = data->clearOffsetForces;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_clearOffsetForces_0d7f285d writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_clearOffsetForces_0d7f285dDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_clearOffsetForces(MTM1M3_command_clearOffsetForcesC *data)
{
  MTM1M3::command_clearOffsetForces_0d7f285dSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_clearOffsetForces");
  }
  int actorIdx = SAL__MTM1M3_command_clearOffsetForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_clearOffsetForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_clearOffsetForces_0d7f285dDataReader_var SALReader = MTM1M3::command_clearOffsetForces_0d7f285dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_clearOffsetForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->clearOffsetForces = Instances[j].clearOffsetForces;
    lastSample_MTM1M3_command_clearOffsetForces.clearOffsetForces = Instances[j].clearOffsetForces;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_clearOffsetForces(MTM1M3_command_clearOffsetForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_clearOffsetForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_clearOffsetForces_ACTOR].maxSamples = 1;
    istatus = getSample_command_clearOffsetForces(data);
    sal[SAL__MTM1M3_command_clearOffsetForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_clearOffsetForces(MTM1M3_command_clearOffsetForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_clearOffsetForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->clearOffsetForces = lastSample_MTM1M3_command_clearOffsetForces.clearOffsetForces;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_clearOffsetForces(MTM1M3_command_clearOffsetForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_clearOffsetForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_clearOffsetForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_clearOffsetForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_clearOffsetForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_disable_04faa884 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_disable");
  }
  MTM1M3::command_disable_04faa884DataWriter_var SALWriter = MTM1M3::command_disable_04faa884DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("04faa884");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_disable_04faa884 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_disable_04faa884DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_disable_04faa884Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_disable");
  }
  MTM1M3::command_disable_04faa884DataReader_var SALReader = MTM1M3::command_disable_04faa884DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disable_04faa884DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_disable_04faa884DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_disable_04faa884DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_disable(MTM1M3_command_disableC *data)
{
  int actorIdx = SAL__MTM1M3_command_disable_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_disable");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_disable");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_disable_04faa884DataWriter_var SALWriter = MTM1M3::command_disable_04faa884DataWriter::_narrow(dwriter.in());
  MTM1M3::command_disable_04faa884 Instance;

  Instance.private_revCode = DDS::string_dup("04faa884");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.value = data->value;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_disable_04faa884 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_disable_04faa884DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_disable(MTM1M3_command_disableC *data)
{
  MTM1M3::command_disable_04faa884Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_disable");
  }
  int actorIdx = SAL__MTM1M3_command_disable_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_disable");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_disable_04faa884DataReader_var SALReader = MTM1M3::command_disable_04faa884DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disable_04faa884DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_disable_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_disable_04faa884DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->value = Instances[j].value;
    lastSample_MTM1M3_command_disable.value = Instances[j].value;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_disable_04faa884DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_disable(MTM1M3_command_disableC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_disable_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_disable_ACTOR].maxSamples = 1;
    istatus = getSample_command_disable(data);
    sal[SAL__MTM1M3_command_disable_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_disable(MTM1M3_command_disableC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_disable(data);
    if (istatus == SAL__NO_UPDATES) {
   data->value = lastSample_MTM1M3_command_disable.value;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_disable(MTM1M3_command_disableC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_disable_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_disable_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_disable(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_disable_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_disableHardpointChase_dbe9a16b data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_disableHardpointChase");
  }
  MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter_var SALWriter = MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("dbe9a16b");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_disableHardpointChase_dbe9a16b writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_disableHardpointChase_dbe9a16bSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_disableHardpointChase");
  }
  MTM1M3::command_disableHardpointChase_dbe9a16bDataReader_var SALReader = MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_disableHardpointChase(MTM1M3_command_disableHardpointChaseC *data)
{
  int actorIdx = SAL__MTM1M3_command_disableHardpointChase_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_disableHardpointChase");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_disableHardpointChase");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter_var SALWriter = MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter::_narrow(dwriter.in());
  MTM1M3::command_disableHardpointChase_dbe9a16b Instance;

  Instance.private_revCode = DDS::string_dup("dbe9a16b");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.hardpointActuator = data->hardpointActuator;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_disableHardpointChase_dbe9a16b writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_disableHardpointChase(MTM1M3_command_disableHardpointChaseC *data)
{
  MTM1M3::command_disableHardpointChase_dbe9a16bSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_disableHardpointChase");
  }
  int actorIdx = SAL__MTM1M3_command_disableHardpointChase_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_disableHardpointChase");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_disableHardpointChase_dbe9a16bDataReader_var SALReader = MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_disableHardpointChase_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->hardpointActuator = Instances[j].hardpointActuator;
    lastSample_MTM1M3_command_disableHardpointChase.hardpointActuator = Instances[j].hardpointActuator;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_disableHardpointChase(MTM1M3_command_disableHardpointChaseC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_disableHardpointChase_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_disableHardpointChase_ACTOR].maxSamples = 1;
    istatus = getSample_command_disableHardpointChase(data);
    sal[SAL__MTM1M3_command_disableHardpointChase_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_disableHardpointChase(MTM1M3_command_disableHardpointChaseC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_disableHardpointChase(data);
    if (istatus == SAL__NO_UPDATES) {
   data->hardpointActuator = lastSample_MTM1M3_command_disableHardpointChase.hardpointActuator;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_disableHardpointChase(MTM1M3_command_disableHardpointChaseC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_disableHardpointChase_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_disableHardpointChase_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_disableHardpointChase(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_disableHardpointChase_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_disableHardpointCorrections_07d1f2ea data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_disableHardpointCorrections");
  }
  MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter_var SALWriter = MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("07d1f2ea");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_disableHardpointCorrections_07d1f2ea writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_disableHardpointCorrections_07d1f2eaSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_disableHardpointCorrections");
  }
  MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader_var SALReader = MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_disableHardpointCorrections(MTM1M3_command_disableHardpointCorrectionsC *data)
{
  int actorIdx = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_disableHardpointCorrections");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_disableHardpointCorrections");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter_var SALWriter = MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter::_narrow(dwriter.in());
  MTM1M3::command_disableHardpointCorrections_07d1f2ea Instance;

  Instance.private_revCode = DDS::string_dup("07d1f2ea");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.disableHardpointCorrections = data->disableHardpointCorrections;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_disableHardpointCorrections_07d1f2ea writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_disableHardpointCorrections(MTM1M3_command_disableHardpointCorrectionsC *data)
{
  MTM1M3::command_disableHardpointCorrections_07d1f2eaSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_disableHardpointCorrections");
  }
  int actorIdx = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_disableHardpointCorrections");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader_var SALReader = MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_disableHardpointCorrections_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->disableHardpointCorrections = Instances[j].disableHardpointCorrections;
    lastSample_MTM1M3_command_disableHardpointCorrections.disableHardpointCorrections = Instances[j].disableHardpointCorrections;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_disableHardpointCorrections(MTM1M3_command_disableHardpointCorrectionsC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_disableHardpointCorrections_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_disableHardpointCorrections_ACTOR].maxSamples = 1;
    istatus = getSample_command_disableHardpointCorrections(data);
    sal[SAL__MTM1M3_command_disableHardpointCorrections_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_disableHardpointCorrections(MTM1M3_command_disableHardpointCorrectionsC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_disableHardpointCorrections(data);
    if (istatus == SAL__NO_UPDATES) {
   data->disableHardpointCorrections = lastSample_MTM1M3_command_disableHardpointCorrections.disableHardpointCorrections;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_disableHardpointCorrections(MTM1M3_command_disableHardpointCorrectionsC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_disableHardpointCorrections_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_disableHardpointCorrections_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_disableHardpointCorrections(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_disableHardpointCorrections_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_enable_c128bf47 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enable");
  }
  MTM1M3::command_enable_c128bf47DataWriter_var SALWriter = MTM1M3::command_enable_c128bf47DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("c128bf47");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enable_c128bf47 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_enable_c128bf47DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_enable_c128bf47Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enable");
  }
  MTM1M3::command_enable_c128bf47DataReader_var SALReader = MTM1M3::command_enable_c128bf47DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enable_c128bf47DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enable_c128bf47DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_enable_c128bf47DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_enable(MTM1M3_command_enableC *data)
{
  int actorIdx = SAL__MTM1M3_command_enable_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_enable");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enable");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enable_c128bf47DataWriter_var SALWriter = MTM1M3::command_enable_c128bf47DataWriter::_narrow(dwriter.in());
  MTM1M3::command_enable_c128bf47 Instance;

  Instance.private_revCode = DDS::string_dup("c128bf47");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.value = data->value;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enable_c128bf47 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_enable_c128bf47DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_enable(MTM1M3_command_enableC *data)
{
  MTM1M3::command_enable_c128bf47Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_enable");
  }
  int actorIdx = SAL__MTM1M3_command_enable_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enable");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enable_c128bf47DataReader_var SALReader = MTM1M3::command_enable_c128bf47DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enable_c128bf47DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_enable_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enable_c128bf47DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->value = Instances[j].value;
    lastSample_MTM1M3_command_enable.value = Instances[j].value;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_enable_c128bf47DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_enable(MTM1M3_command_enableC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_enable_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_enable_ACTOR].maxSamples = 1;
    istatus = getSample_command_enable(data);
    sal[SAL__MTM1M3_command_enable_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_enable(MTM1M3_command_enableC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_enable(data);
    if (istatus == SAL__NO_UPDATES) {
   data->value = lastSample_MTM1M3_command_enable.value;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_enable(MTM1M3_command_enableC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_enable_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_enable_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_enable(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_enable_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_enableHardpointChase_49c0d4e1 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enableHardpointChase");
  }
  MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter_var SALWriter = MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("49c0d4e1");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enableHardpointChase_49c0d4e1 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_enableHardpointChase_49c0d4e1Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enableHardpointChase");
  }
  MTM1M3::command_enableHardpointChase_49c0d4e1DataReader_var SALReader = MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_enableHardpointChase(MTM1M3_command_enableHardpointChaseC *data)
{
  int actorIdx = SAL__MTM1M3_command_enableHardpointChase_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_enableHardpointChase");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enableHardpointChase");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter_var SALWriter = MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter::_narrow(dwriter.in());
  MTM1M3::command_enableHardpointChase_49c0d4e1 Instance;

  Instance.private_revCode = DDS::string_dup("49c0d4e1");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.hardpointActuator = data->hardpointActuator;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enableHardpointChase_49c0d4e1 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_enableHardpointChase(MTM1M3_command_enableHardpointChaseC *data)
{
  MTM1M3::command_enableHardpointChase_49c0d4e1Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_enableHardpointChase");
  }
  int actorIdx = SAL__MTM1M3_command_enableHardpointChase_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enableHardpointChase");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enableHardpointChase_49c0d4e1DataReader_var SALReader = MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_enableHardpointChase_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->hardpointActuator = Instances[j].hardpointActuator;
    lastSample_MTM1M3_command_enableHardpointChase.hardpointActuator = Instances[j].hardpointActuator;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_enableHardpointChase(MTM1M3_command_enableHardpointChaseC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_enableHardpointChase_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_enableHardpointChase_ACTOR].maxSamples = 1;
    istatus = getSample_command_enableHardpointChase(data);
    sal[SAL__MTM1M3_command_enableHardpointChase_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_enableHardpointChase(MTM1M3_command_enableHardpointChaseC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_enableHardpointChase(data);
    if (istatus == SAL__NO_UPDATES) {
   data->hardpointActuator = lastSample_MTM1M3_command_enableHardpointChase.hardpointActuator;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_enableHardpointChase(MTM1M3_command_enableHardpointChaseC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_enableHardpointChase_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_enableHardpointChase_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_enableHardpointChase(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_enableHardpointChase_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_enableHardpointCorrections_dae9c1ec data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enableHardpointCorrections");
  }
  MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter_var SALWriter = MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("dae9c1ec");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enableHardpointCorrections_dae9c1ec writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_enableHardpointCorrections_dae9c1ecSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enableHardpointCorrections");
  }
  MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader_var SALReader = MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_enableHardpointCorrections(MTM1M3_command_enableHardpointCorrectionsC *data)
{
  int actorIdx = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_enableHardpointCorrections");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enableHardpointCorrections");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter_var SALWriter = MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter::_narrow(dwriter.in());
  MTM1M3::command_enableHardpointCorrections_dae9c1ec Instance;

  Instance.private_revCode = DDS::string_dup("dae9c1ec");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.enableHardpointCorrections = data->enableHardpointCorrections;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enableHardpointCorrections_dae9c1ec writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_enableHardpointCorrections(MTM1M3_command_enableHardpointCorrectionsC *data)
{
  MTM1M3::command_enableHardpointCorrections_dae9c1ecSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_enableHardpointCorrections");
  }
  int actorIdx = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enableHardpointCorrections");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader_var SALReader = MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_enableHardpointCorrections_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->enableHardpointCorrections = Instances[j].enableHardpointCorrections;
    lastSample_MTM1M3_command_enableHardpointCorrections.enableHardpointCorrections = Instances[j].enableHardpointCorrections;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_enableHardpointCorrections(MTM1M3_command_enableHardpointCorrectionsC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_enableHardpointCorrections_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_enableHardpointCorrections_ACTOR].maxSamples = 1;
    istatus = getSample_command_enableHardpointCorrections(data);
    sal[SAL__MTM1M3_command_enableHardpointCorrections_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_enableHardpointCorrections(MTM1M3_command_enableHardpointCorrectionsC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_enableHardpointCorrections(data);
    if (istatus == SAL__NO_UPDATES) {
   data->enableHardpointCorrections = lastSample_MTM1M3_command_enableHardpointCorrections.enableHardpointCorrections;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_enableHardpointCorrections(MTM1M3_command_enableHardpointCorrectionsC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_enableHardpointCorrections_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_enableHardpointCorrections_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_enableHardpointCorrections(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_enableHardpointCorrections_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_enterControl_417c941a data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enterControl");
  }
  MTM1M3::command_enterControl_417c941aDataWriter_var SALWriter = MTM1M3::command_enterControl_417c941aDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("417c941a");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enterControl_417c941a writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_enterControl_417c941aDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_enterControl_417c941aSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enterControl");
  }
  MTM1M3::command_enterControl_417c941aDataReader_var SALReader = MTM1M3::command_enterControl_417c941aDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enterControl_417c941aDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enterControl_417c941aDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_enterControl_417c941aDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_enterControl(MTM1M3_command_enterControlC *data)
{
  int actorIdx = SAL__MTM1M3_command_enterControl_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_enterControl");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enterControl");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enterControl_417c941aDataWriter_var SALWriter = MTM1M3::command_enterControl_417c941aDataWriter::_narrow(dwriter.in());
  MTM1M3::command_enterControl_417c941a Instance;

  Instance.private_revCode = DDS::string_dup("417c941a");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.value = data->value;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enterControl_417c941a writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_enterControl_417c941aDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_enterControl(MTM1M3_command_enterControlC *data)
{
  MTM1M3::command_enterControl_417c941aSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_enterControl");
  }
  int actorIdx = SAL__MTM1M3_command_enterControl_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enterControl");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enterControl_417c941aDataReader_var SALReader = MTM1M3::command_enterControl_417c941aDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enterControl_417c941aDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_enterControl_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enterControl_417c941aDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->value = Instances[j].value;
    lastSample_MTM1M3_command_enterControl.value = Instances[j].value;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_enterControl_417c941aDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_enterControl(MTM1M3_command_enterControlC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_enterControl_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_enterControl_ACTOR].maxSamples = 1;
    istatus = getSample_command_enterControl(data);
    sal[SAL__MTM1M3_command_enterControl_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_enterControl(MTM1M3_command_enterControlC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_enterControl(data);
    if (istatus == SAL__NO_UPDATES) {
   data->value = lastSample_MTM1M3_command_enterControl.value;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_enterControl(MTM1M3_command_enterControlC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_enterControl_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_enterControl_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_enterControl(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_enterControl_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_enterEngineering_89e1ff1c data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enterEngineering");
  }
  MTM1M3::command_enterEngineering_89e1ff1cDataWriter_var SALWriter = MTM1M3::command_enterEngineering_89e1ff1cDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("89e1ff1c");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enterEngineering_89e1ff1c writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_enterEngineering_89e1ff1cDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_enterEngineering_89e1ff1cSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enterEngineering");
  }
  MTM1M3::command_enterEngineering_89e1ff1cDataReader_var SALReader = MTM1M3::command_enterEngineering_89e1ff1cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enterEngineering_89e1ff1cDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enterEngineering_89e1ff1cDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_enterEngineering_89e1ff1cDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_enterEngineering(MTM1M3_command_enterEngineeringC *data)
{
  int actorIdx = SAL__MTM1M3_command_enterEngineering_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_enterEngineering");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_enterEngineering");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enterEngineering_89e1ff1cDataWriter_var SALWriter = MTM1M3::command_enterEngineering_89e1ff1cDataWriter::_narrow(dwriter.in());
  MTM1M3::command_enterEngineering_89e1ff1c Instance;

  Instance.private_revCode = DDS::string_dup("89e1ff1c");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.enterEngineering = data->enterEngineering;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_enterEngineering_89e1ff1c writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_enterEngineering_89e1ff1cDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_enterEngineering(MTM1M3_command_enterEngineeringC *data)
{
  MTM1M3::command_enterEngineering_89e1ff1cSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_enterEngineering");
  }
  int actorIdx = SAL__MTM1M3_command_enterEngineering_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_enterEngineering");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_enterEngineering_89e1ff1cDataReader_var SALReader = MTM1M3::command_enterEngineering_89e1ff1cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enterEngineering_89e1ff1cDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_enterEngineering_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_enterEngineering_89e1ff1cDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->enterEngineering = Instances[j].enterEngineering;
    lastSample_MTM1M3_command_enterEngineering.enterEngineering = Instances[j].enterEngineering;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_enterEngineering_89e1ff1cDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_enterEngineering(MTM1M3_command_enterEngineeringC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_enterEngineering_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_enterEngineering_ACTOR].maxSamples = 1;
    istatus = getSample_command_enterEngineering(data);
    sal[SAL__MTM1M3_command_enterEngineering_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_enterEngineering(MTM1M3_command_enterEngineeringC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_enterEngineering(data);
    if (istatus == SAL__NO_UPDATES) {
   data->enterEngineering = lastSample_MTM1M3_command_enterEngineering.enterEngineering;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_enterEngineering(MTM1M3_command_enterEngineeringC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_enterEngineering_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_enterEngineering_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_enterEngineering(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_enterEngineering_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_exitControl_e2ea247d data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_exitControl");
  }
  MTM1M3::command_exitControl_e2ea247dDataWriter_var SALWriter = MTM1M3::command_exitControl_e2ea247dDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("e2ea247d");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_exitControl_e2ea247d writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_exitControl_e2ea247dDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_exitControl_e2ea247dSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_exitControl");
  }
  MTM1M3::command_exitControl_e2ea247dDataReader_var SALReader = MTM1M3::command_exitControl_e2ea247dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_exitControl_e2ea247dDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_exitControl_e2ea247dDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_exitControl_e2ea247dDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_exitControl(MTM1M3_command_exitControlC *data)
{
  int actorIdx = SAL__MTM1M3_command_exitControl_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_exitControl");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_exitControl");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_exitControl_e2ea247dDataWriter_var SALWriter = MTM1M3::command_exitControl_e2ea247dDataWriter::_narrow(dwriter.in());
  MTM1M3::command_exitControl_e2ea247d Instance;

  Instance.private_revCode = DDS::string_dup("e2ea247d");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.value = data->value;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_exitControl_e2ea247d writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_exitControl_e2ea247dDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_exitControl(MTM1M3_command_exitControlC *data)
{
  MTM1M3::command_exitControl_e2ea247dSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_exitControl");
  }
  int actorIdx = SAL__MTM1M3_command_exitControl_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_exitControl");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_exitControl_e2ea247dDataReader_var SALReader = MTM1M3::command_exitControl_e2ea247dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_exitControl_e2ea247dDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_exitControl_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_exitControl_e2ea247dDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->value = Instances[j].value;
    lastSample_MTM1M3_command_exitControl.value = Instances[j].value;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_exitControl_e2ea247dDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_exitControl(MTM1M3_command_exitControlC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_exitControl_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_exitControl_ACTOR].maxSamples = 1;
    istatus = getSample_command_exitControl(data);
    sal[SAL__MTM1M3_command_exitControl_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_exitControl(MTM1M3_command_exitControlC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_exitControl(data);
    if (istatus == SAL__NO_UPDATES) {
   data->value = lastSample_MTM1M3_command_exitControl.value;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_exitControl(MTM1M3_command_exitControlC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_exitControl_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_exitControl_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_exitControl(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_exitControl_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_exitEngineering_01073d21 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_exitEngineering");
  }
  MTM1M3::command_exitEngineering_01073d21DataWriter_var SALWriter = MTM1M3::command_exitEngineering_01073d21DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("01073d21");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_exitEngineering_01073d21 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_exitEngineering_01073d21DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_exitEngineering_01073d21Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_exitEngineering");
  }
  MTM1M3::command_exitEngineering_01073d21DataReader_var SALReader = MTM1M3::command_exitEngineering_01073d21DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_exitEngineering_01073d21DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_exitEngineering_01073d21DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_exitEngineering_01073d21DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_exitEngineering(MTM1M3_command_exitEngineeringC *data)
{
  int actorIdx = SAL__MTM1M3_command_exitEngineering_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_exitEngineering");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_exitEngineering");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_exitEngineering_01073d21DataWriter_var SALWriter = MTM1M3::command_exitEngineering_01073d21DataWriter::_narrow(dwriter.in());
  MTM1M3::command_exitEngineering_01073d21 Instance;

  Instance.private_revCode = DDS::string_dup("01073d21");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.exitEngineering = data->exitEngineering;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_exitEngineering_01073d21 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_exitEngineering_01073d21DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_exitEngineering(MTM1M3_command_exitEngineeringC *data)
{
  MTM1M3::command_exitEngineering_01073d21Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_exitEngineering");
  }
  int actorIdx = SAL__MTM1M3_command_exitEngineering_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_exitEngineering");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_exitEngineering_01073d21DataReader_var SALReader = MTM1M3::command_exitEngineering_01073d21DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_exitEngineering_01073d21DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_exitEngineering_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_exitEngineering_01073d21DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->exitEngineering = Instances[j].exitEngineering;
    lastSample_MTM1M3_command_exitEngineering.exitEngineering = Instances[j].exitEngineering;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_exitEngineering_01073d21DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_exitEngineering(MTM1M3_command_exitEngineeringC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_exitEngineering_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_exitEngineering_ACTOR].maxSamples = 1;
    istatus = getSample_command_exitEngineering(data);
    sal[SAL__MTM1M3_command_exitEngineering_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_exitEngineering(MTM1M3_command_exitEngineeringC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_exitEngineering(data);
    if (istatus == SAL__NO_UPDATES) {
   data->exitEngineering = lastSample_MTM1M3_command_exitEngineering.exitEngineering;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_exitEngineering(MTM1M3_command_exitEngineeringC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_exitEngineering_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_exitEngineering_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_exitEngineering(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_exitEngineering_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_lowerM1M3_69afda69 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_lowerM1M3");
  }
  MTM1M3::command_lowerM1M3_69afda69DataWriter_var SALWriter = MTM1M3::command_lowerM1M3_69afda69DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("69afda69");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_lowerM1M3_69afda69 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_lowerM1M3_69afda69DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_lowerM1M3_69afda69Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_lowerM1M3");
  }
  MTM1M3::command_lowerM1M3_69afda69DataReader_var SALReader = MTM1M3::command_lowerM1M3_69afda69DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_lowerM1M3_69afda69DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_lowerM1M3_69afda69DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_lowerM1M3_69afda69DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_lowerM1M3(MTM1M3_command_lowerM1M3C *data)
{
  int actorIdx = SAL__MTM1M3_command_lowerM1M3_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_lowerM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_lowerM1M3");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_lowerM1M3_69afda69DataWriter_var SALWriter = MTM1M3::command_lowerM1M3_69afda69DataWriter::_narrow(dwriter.in());
  MTM1M3::command_lowerM1M3_69afda69 Instance;

  Instance.private_revCode = DDS::string_dup("69afda69");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.lowerM1M3 = data->lowerM1M3;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_lowerM1M3_69afda69 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_lowerM1M3_69afda69DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_lowerM1M3(MTM1M3_command_lowerM1M3C *data)
{
  MTM1M3::command_lowerM1M3_69afda69Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_lowerM1M3");
  }
  int actorIdx = SAL__MTM1M3_command_lowerM1M3_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_lowerM1M3");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_lowerM1M3_69afda69DataReader_var SALReader = MTM1M3::command_lowerM1M3_69afda69DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_lowerM1M3_69afda69DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_lowerM1M3_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_lowerM1M3_69afda69DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->lowerM1M3 = Instances[j].lowerM1M3;
    lastSample_MTM1M3_command_lowerM1M3.lowerM1M3 = Instances[j].lowerM1M3;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_lowerM1M3_69afda69DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_lowerM1M3(MTM1M3_command_lowerM1M3C *data)
{
    int saveMax = sal[SAL__MTM1M3_command_lowerM1M3_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_lowerM1M3_ACTOR].maxSamples = 1;
    istatus = getSample_command_lowerM1M3(data);
    sal[SAL__MTM1M3_command_lowerM1M3_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_lowerM1M3(MTM1M3_command_lowerM1M3C *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_lowerM1M3(data);
    if (istatus == SAL__NO_UPDATES) {
   data->lowerM1M3 = lastSample_MTM1M3_command_lowerM1M3.lowerM1M3;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_lowerM1M3(MTM1M3_command_lowerM1M3C *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_lowerM1M3_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_lowerM1M3_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_lowerM1M3(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_lowerM1M3_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_modbusTransmit_a3c81bde data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_modbusTransmit");
  }
  MTM1M3::command_modbusTransmit_a3c81bdeDataWriter_var SALWriter = MTM1M3::command_modbusTransmit_a3c81bdeDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("a3c81bde");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_modbusTransmit_a3c81bde writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_modbusTransmit_a3c81bdeDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_modbusTransmit_a3c81bdeSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_modbusTransmit");
  }
  MTM1M3::command_modbusTransmit_a3c81bdeDataReader_var SALReader = MTM1M3::command_modbusTransmit_a3c81bdeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_modbusTransmit(MTM1M3_command_modbusTransmitC *data)
{
  int actorIdx = SAL__MTM1M3_command_modbusTransmit_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_modbusTransmit");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_modbusTransmit");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_modbusTransmit_a3c81bdeDataWriter_var SALWriter = MTM1M3::command_modbusTransmit_a3c81bdeDataWriter::_narrow(dwriter.in());
  MTM1M3::command_modbusTransmit_a3c81bde Instance;

  Instance.private_revCode = DDS::string_dup("a3c81bde");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.actuatorId = data->actuatorId;
    Instance.functionCode = data->functionCode;
    for (int iseq=0;iseq<252;iseq++) {Instance.data[iseq] = data->data[iseq];}
    Instance.dataLength = data->dataLength;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_modbusTransmit_a3c81bde writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_modbusTransmit_a3c81bdeDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_modbusTransmit(MTM1M3_command_modbusTransmitC *data)
{
  MTM1M3::command_modbusTransmit_a3c81bdeSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_modbusTransmit");
  }
  int actorIdx = SAL__MTM1M3_command_modbusTransmit_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_modbusTransmit");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_modbusTransmit_a3c81bdeDataReader_var SALReader = MTM1M3::command_modbusTransmit_a3c81bdeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_modbusTransmit_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->actuatorId = Instances[j].actuatorId;
    lastSample_MTM1M3_command_modbusTransmit.actuatorId = Instances[j].actuatorId;
    data->functionCode = Instances[j].functionCode;
    lastSample_MTM1M3_command_modbusTransmit.functionCode = Instances[j].functionCode;
    for (int iseq=0;iseq<252;iseq++) {data->data[iseq] = Instances[j].data[iseq];}
    for (int iseq=0;iseq<252;iseq++) {lastSample_MTM1M3_command_modbusTransmit.data[iseq] = Instances[j].data[iseq];}
    data->dataLength = Instances[j].dataLength;
    lastSample_MTM1M3_command_modbusTransmit.dataLength = Instances[j].dataLength;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_modbusTransmit(MTM1M3_command_modbusTransmitC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_modbusTransmit_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_modbusTransmit_ACTOR].maxSamples = 1;
    istatus = getSample_command_modbusTransmit(data);
    sal[SAL__MTM1M3_command_modbusTransmit_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_modbusTransmit(MTM1M3_command_modbusTransmitC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_modbusTransmit(data);
    if (istatus == SAL__NO_UPDATES) {
   data->actuatorId = lastSample_MTM1M3_command_modbusTransmit.actuatorId;
   data->functionCode = lastSample_MTM1M3_command_modbusTransmit.functionCode;
    for (int iseq=0;iseq<252;iseq++) {data->data[iseq] = lastSample_MTM1M3_command_modbusTransmit.data[iseq];}
   data->dataLength = lastSample_MTM1M3_command_modbusTransmit.dataLength;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_modbusTransmit(MTM1M3_command_modbusTransmitC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_modbusTransmit_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_modbusTransmit_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_modbusTransmit(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_modbusTransmit_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_moveHardpointActuators_4d114fab data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_moveHardpointActuators");
  }
  MTM1M3::command_moveHardpointActuators_4d114fabDataWriter_var SALWriter = MTM1M3::command_moveHardpointActuators_4d114fabDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("4d114fab");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_moveHardpointActuators_4d114fab writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_moveHardpointActuators_4d114fabDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_moveHardpointActuators_4d114fabSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_moveHardpointActuators");
  }
  MTM1M3::command_moveHardpointActuators_4d114fabDataReader_var SALReader = MTM1M3::command_moveHardpointActuators_4d114fabDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_moveHardpointActuators(MTM1M3_command_moveHardpointActuatorsC *data)
{
  int actorIdx = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_moveHardpointActuators");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_moveHardpointActuators");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_moveHardpointActuators_4d114fabDataWriter_var SALWriter = MTM1M3::command_moveHardpointActuators_4d114fabDataWriter::_narrow(dwriter.in());
  MTM1M3::command_moveHardpointActuators_4d114fab Instance;

  Instance.private_revCode = DDS::string_dup("4d114fab");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    for (int iseq=0;iseq<6;iseq++) {Instance.steps[iseq] = data->steps[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_moveHardpointActuators_4d114fab writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_moveHardpointActuators_4d114fabDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_moveHardpointActuators(MTM1M3_command_moveHardpointActuatorsC *data)
{
  MTM1M3::command_moveHardpointActuators_4d114fabSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_moveHardpointActuators");
  }
  int actorIdx = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_moveHardpointActuators");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_moveHardpointActuators_4d114fabDataReader_var SALReader = MTM1M3::command_moveHardpointActuators_4d114fabDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_moveHardpointActuators_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    for (int iseq=0;iseq<6;iseq++) {data->steps[iseq] = Instances[j].steps[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_command_moveHardpointActuators.steps[iseq] = Instances[j].steps[iseq];}
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_moveHardpointActuators(MTM1M3_command_moveHardpointActuatorsC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_moveHardpointActuators_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_moveHardpointActuators_ACTOR].maxSamples = 1;
    istatus = getSample_command_moveHardpointActuators(data);
    sal[SAL__MTM1M3_command_moveHardpointActuators_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_moveHardpointActuators(MTM1M3_command_moveHardpointActuatorsC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_moveHardpointActuators(data);
    if (istatus == SAL__NO_UPDATES) {
    for (int iseq=0;iseq<6;iseq++) {data->steps[iseq] = lastSample_MTM1M3_command_moveHardpointActuators.steps[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_moveHardpointActuators(MTM1M3_command_moveHardpointActuatorsC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_moveHardpointActuators_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_moveHardpointActuators_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_moveHardpointActuators(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_moveHardpointActuators_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_positionM1M3_fa7ca786 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_positionM1M3");
  }
  MTM1M3::command_positionM1M3_fa7ca786DataWriter_var SALWriter = MTM1M3::command_positionM1M3_fa7ca786DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("fa7ca786");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_positionM1M3_fa7ca786 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_positionM1M3_fa7ca786DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_positionM1M3_fa7ca786Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_positionM1M3");
  }
  MTM1M3::command_positionM1M3_fa7ca786DataReader_var SALReader = MTM1M3::command_positionM1M3_fa7ca786DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_positionM1M3_fa7ca786DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_positionM1M3_fa7ca786DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_positionM1M3_fa7ca786DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_positionM1M3(MTM1M3_command_positionM1M3C *data)
{
  int actorIdx = SAL__MTM1M3_command_positionM1M3_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_positionM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_positionM1M3");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_positionM1M3_fa7ca786DataWriter_var SALWriter = MTM1M3::command_positionM1M3_fa7ca786DataWriter::_narrow(dwriter.in());
  MTM1M3::command_positionM1M3_fa7ca786 Instance;

  Instance.private_revCode = DDS::string_dup("fa7ca786");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.xPosition = data->xPosition;
    Instance.yPosition = data->yPosition;
    Instance.zPosition = data->zPosition;
    Instance.xRotation = data->xRotation;
    Instance.yRotation = data->yRotation;
    Instance.zRotation = data->zRotation;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_positionM1M3_fa7ca786 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_positionM1M3_fa7ca786DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_positionM1M3(MTM1M3_command_positionM1M3C *data)
{
  MTM1M3::command_positionM1M3_fa7ca786Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_positionM1M3");
  }
  int actorIdx = SAL__MTM1M3_command_positionM1M3_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_positionM1M3");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_positionM1M3_fa7ca786DataReader_var SALReader = MTM1M3::command_positionM1M3_fa7ca786DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_positionM1M3_fa7ca786DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_positionM1M3_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_positionM1M3_fa7ca786DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->xPosition = Instances[j].xPosition;
    lastSample_MTM1M3_command_positionM1M3.xPosition = Instances[j].xPosition;
    data->yPosition = Instances[j].yPosition;
    lastSample_MTM1M3_command_positionM1M3.yPosition = Instances[j].yPosition;
    data->zPosition = Instances[j].zPosition;
    lastSample_MTM1M3_command_positionM1M3.zPosition = Instances[j].zPosition;
    data->xRotation = Instances[j].xRotation;
    lastSample_MTM1M3_command_positionM1M3.xRotation = Instances[j].xRotation;
    data->yRotation = Instances[j].yRotation;
    lastSample_MTM1M3_command_positionM1M3.yRotation = Instances[j].yRotation;
    data->zRotation = Instances[j].zRotation;
    lastSample_MTM1M3_command_positionM1M3.zRotation = Instances[j].zRotation;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_positionM1M3_fa7ca786DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_positionM1M3(MTM1M3_command_positionM1M3C *data)
{
    int saveMax = sal[SAL__MTM1M3_command_positionM1M3_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_positionM1M3_ACTOR].maxSamples = 1;
    istatus = getSample_command_positionM1M3(data);
    sal[SAL__MTM1M3_command_positionM1M3_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_positionM1M3(MTM1M3_command_positionM1M3C *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_positionM1M3(data);
    if (istatus == SAL__NO_UPDATES) {
   data->xPosition = lastSample_MTM1M3_command_positionM1M3.xPosition;
   data->yPosition = lastSample_MTM1M3_command_positionM1M3.yPosition;
   data->zPosition = lastSample_MTM1M3_command_positionM1M3.zPosition;
   data->xRotation = lastSample_MTM1M3_command_positionM1M3.xRotation;
   data->yRotation = lastSample_MTM1M3_command_positionM1M3.yRotation;
   data->zRotation = lastSample_MTM1M3_command_positionM1M3.zRotation;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_positionM1M3(MTM1M3_command_positionM1M3C *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_positionM1M3_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_positionM1M3_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_positionM1M3(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_positionM1M3_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_programILC_7dde50ee data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_programILC");
  }
  MTM1M3::command_programILC_7dde50eeDataWriter_var SALWriter = MTM1M3::command_programILC_7dde50eeDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("7dde50ee");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_programILC_7dde50ee writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_programILC_7dde50eeDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_programILC_7dde50eeSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_programILC");
  }
  MTM1M3::command_programILC_7dde50eeDataReader_var SALReader = MTM1M3::command_programILC_7dde50eeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_programILC_7dde50eeDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_programILC_7dde50eeDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_programILC_7dde50eeDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_programILC(MTM1M3_command_programILCC *data)
{
  int actorIdx = SAL__MTM1M3_command_programILC_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_programILC");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_programILC");
  }
    if ( data->filePath.length() > 256 ) {
       throw std::length_error("Item filePath exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_programILC_7dde50eeDataWriter_var SALWriter = MTM1M3::command_programILC_7dde50eeDataWriter::_narrow(dwriter.in());
  MTM1M3::command_programILC_7dde50ee Instance;

  Instance.private_revCode = DDS::string_dup("7dde50ee");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.actuatorId = data->actuatorId;
    Instance.filePath = DDS::string_dup(data->filePath.c_str());


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_programILC_7dde50ee writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_programILC_7dde50eeDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_programILC(MTM1M3_command_programILCC *data)
{
  MTM1M3::command_programILC_7dde50eeSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_programILC");
  }
  int actorIdx = SAL__MTM1M3_command_programILC_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_programILC");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_programILC_7dde50eeDataReader_var SALReader = MTM1M3::command_programILC_7dde50eeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_programILC_7dde50eeDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_programILC_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_programILC_7dde50eeDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->actuatorId = Instances[j].actuatorId;
    lastSample_MTM1M3_command_programILC.actuatorId = Instances[j].actuatorId;
    data->filePath=Instances[j].filePath.m_ptr;
    lastSample_MTM1M3_command_programILC.filePath=Instances[j].filePath.m_ptr;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_programILC_7dde50eeDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_programILC(MTM1M3_command_programILCC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_programILC_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_programILC_ACTOR].maxSamples = 1;
    istatus = getSample_command_programILC(data);
    sal[SAL__MTM1M3_command_programILC_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_programILC(MTM1M3_command_programILCC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_programILC(data);
    if (istatus == SAL__NO_UPDATES) {
   data->actuatorId = lastSample_MTM1M3_command_programILC.actuatorId;
   data->filePath = lastSample_MTM1M3_command_programILC.filePath;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_programILC(MTM1M3_command_programILCC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_programILC_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_programILC_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_programILC(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_programILC_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_raiseM1M3_f0a54745 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_raiseM1M3");
  }
  MTM1M3::command_raiseM1M3_f0a54745DataWriter_var SALWriter = MTM1M3::command_raiseM1M3_f0a54745DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("f0a54745");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_raiseM1M3_f0a54745 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_raiseM1M3_f0a54745DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_raiseM1M3_f0a54745Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_raiseM1M3");
  }
  MTM1M3::command_raiseM1M3_f0a54745DataReader_var SALReader = MTM1M3::command_raiseM1M3_f0a54745DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_raiseM1M3_f0a54745DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_raiseM1M3_f0a54745DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_raiseM1M3_f0a54745DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_raiseM1M3(MTM1M3_command_raiseM1M3C *data)
{
  int actorIdx = SAL__MTM1M3_command_raiseM1M3_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_raiseM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_raiseM1M3");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_raiseM1M3_f0a54745DataWriter_var SALWriter = MTM1M3::command_raiseM1M3_f0a54745DataWriter::_narrow(dwriter.in());
  MTM1M3::command_raiseM1M3_f0a54745 Instance;

  Instance.private_revCode = DDS::string_dup("f0a54745");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.raiseM1M3 = data->raiseM1M3;
    Instance.bypassReferencePosition = data->bypassReferencePosition;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_raiseM1M3_f0a54745 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_raiseM1M3_f0a54745DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_raiseM1M3(MTM1M3_command_raiseM1M3C *data)
{
  MTM1M3::command_raiseM1M3_f0a54745Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_raiseM1M3");
  }
  int actorIdx = SAL__MTM1M3_command_raiseM1M3_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_raiseM1M3");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_raiseM1M3_f0a54745DataReader_var SALReader = MTM1M3::command_raiseM1M3_f0a54745DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_raiseM1M3_f0a54745DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_raiseM1M3_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_raiseM1M3_f0a54745DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->raiseM1M3 = Instances[j].raiseM1M3;
    lastSample_MTM1M3_command_raiseM1M3.raiseM1M3 = Instances[j].raiseM1M3;
    data->bypassReferencePosition = Instances[j].bypassReferencePosition;
    lastSample_MTM1M3_command_raiseM1M3.bypassReferencePosition = Instances[j].bypassReferencePosition;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_raiseM1M3_f0a54745DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_raiseM1M3(MTM1M3_command_raiseM1M3C *data)
{
    int saveMax = sal[SAL__MTM1M3_command_raiseM1M3_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_raiseM1M3_ACTOR].maxSamples = 1;
    istatus = getSample_command_raiseM1M3(data);
    sal[SAL__MTM1M3_command_raiseM1M3_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_raiseM1M3(MTM1M3_command_raiseM1M3C *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_raiseM1M3(data);
    if (istatus == SAL__NO_UPDATES) {
   data->raiseM1M3 = lastSample_MTM1M3_command_raiseM1M3.raiseM1M3;
   data->bypassReferencePosition = lastSample_MTM1M3_command_raiseM1M3.bypassReferencePosition;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_raiseM1M3(MTM1M3_command_raiseM1M3C *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_raiseM1M3_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_raiseM1M3_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_raiseM1M3(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_raiseM1M3_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_resetPID_bc5508ce data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_resetPID");
  }
  MTM1M3::command_resetPID_bc5508ceDataWriter_var SALWriter = MTM1M3::command_resetPID_bc5508ceDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("bc5508ce");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_resetPID_bc5508ce writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_resetPID_bc5508ceDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_resetPID_bc5508ceSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_resetPID");
  }
  MTM1M3::command_resetPID_bc5508ceDataReader_var SALReader = MTM1M3::command_resetPID_bc5508ceDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_resetPID_bc5508ceDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_resetPID_bc5508ceDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_resetPID_bc5508ceDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_resetPID(MTM1M3_command_resetPIDC *data)
{
  int actorIdx = SAL__MTM1M3_command_resetPID_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_resetPID");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_resetPID");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_resetPID_bc5508ceDataWriter_var SALWriter = MTM1M3::command_resetPID_bc5508ceDataWriter::_narrow(dwriter.in());
  MTM1M3::command_resetPID_bc5508ce Instance;

  Instance.private_revCode = DDS::string_dup("bc5508ce");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.pid = data->pid;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_resetPID_bc5508ce writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_resetPID_bc5508ceDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_resetPID(MTM1M3_command_resetPIDC *data)
{
  MTM1M3::command_resetPID_bc5508ceSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_resetPID");
  }
  int actorIdx = SAL__MTM1M3_command_resetPID_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_resetPID");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_resetPID_bc5508ceDataReader_var SALReader = MTM1M3::command_resetPID_bc5508ceDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_resetPID_bc5508ceDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_resetPID_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_resetPID_bc5508ceDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->pid = Instances[j].pid;
    lastSample_MTM1M3_command_resetPID.pid = Instances[j].pid;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_resetPID_bc5508ceDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_resetPID(MTM1M3_command_resetPIDC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_resetPID_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_resetPID_ACTOR].maxSamples = 1;
    istatus = getSample_command_resetPID(data);
    sal[SAL__MTM1M3_command_resetPID_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_resetPID(MTM1M3_command_resetPIDC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_resetPID(data);
    if (istatus == SAL__NO_UPDATES) {
   data->pid = lastSample_MTM1M3_command_resetPID.pid;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_resetPID(MTM1M3_command_resetPIDC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_resetPID_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_resetPID_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_resetPID(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_resetPID_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_runMirrorForceProfile_33f2be6c data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_runMirrorForceProfile");
  }
  MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter_var SALWriter = MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("33f2be6c");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_runMirrorForceProfile_33f2be6c writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_runMirrorForceProfile_33f2be6cSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_runMirrorForceProfile");
  }
  MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader_var SALReader = MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_runMirrorForceProfile(MTM1M3_command_runMirrorForceProfileC *data)
{
  int actorIdx = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_runMirrorForceProfile");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_runMirrorForceProfile");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter_var SALWriter = MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter::_narrow(dwriter.in());
  MTM1M3::command_runMirrorForceProfile_33f2be6c Instance;

  Instance.private_revCode = DDS::string_dup("33f2be6c");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    for (int iseq=0;iseq<1000;iseq++) {Instance.xForce[iseq] = data->xForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.yForce[iseq] = data->yForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.zForce[iseq] = data->zForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.xMoment[iseq] = data->xMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.yMoment[iseq] = data->yMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.zMoment[iseq] = data->zMoment[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_runMirrorForceProfile_33f2be6c writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_runMirrorForceProfile(MTM1M3_command_runMirrorForceProfileC *data)
{
  MTM1M3::command_runMirrorForceProfile_33f2be6cSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_runMirrorForceProfile");
  }
  int actorIdx = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_runMirrorForceProfile");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader_var SALReader = MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_runMirrorForceProfile_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    for (int iseq=0;iseq<1000;iseq++) {data->xForce[iseq] = Instances[j].xForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.xForce[iseq] = Instances[j].xForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->yForce[iseq] = Instances[j].yForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.yForce[iseq] = Instances[j].yForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->zForce[iseq] = Instances[j].zForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.zForce[iseq] = Instances[j].zForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->xMoment[iseq] = Instances[j].xMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.xMoment[iseq] = Instances[j].xMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->yMoment[iseq] = Instances[j].yMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.yMoment[iseq] = Instances[j].yMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->zMoment[iseq] = Instances[j].zMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.zMoment[iseq] = Instances[j].zMoment[iseq];}
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_runMirrorForceProfile(MTM1M3_command_runMirrorForceProfileC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_runMirrorForceProfile_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_runMirrorForceProfile_ACTOR].maxSamples = 1;
    istatus = getSample_command_runMirrorForceProfile(data);
    sal[SAL__MTM1M3_command_runMirrorForceProfile_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_runMirrorForceProfile(MTM1M3_command_runMirrorForceProfileC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_runMirrorForceProfile(data);
    if (istatus == SAL__NO_UPDATES) {
    for (int iseq=0;iseq<1000;iseq++) {data->xForce[iseq] = lastSample_MTM1M3_command_runMirrorForceProfile.xForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->yForce[iseq] = lastSample_MTM1M3_command_runMirrorForceProfile.yForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->zForce[iseq] = lastSample_MTM1M3_command_runMirrorForceProfile.zForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->xMoment[iseq] = lastSample_MTM1M3_command_runMirrorForceProfile.xMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->yMoment[iseq] = lastSample_MTM1M3_command_runMirrorForceProfile.yMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->zMoment[iseq] = lastSample_MTM1M3_command_runMirrorForceProfile.zMoment[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_runMirrorForceProfile(MTM1M3_command_runMirrorForceProfileC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_runMirrorForceProfile_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_runMirrorForceProfile_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_runMirrorForceProfile(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_runMirrorForceProfile_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_setLogLevel_346fd770 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_setLogLevel");
  }
  MTM1M3::command_setLogLevel_346fd770DataWriter_var SALWriter = MTM1M3::command_setLogLevel_346fd770DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("346fd770");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_setLogLevel_346fd770 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_setLogLevel_346fd770DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_setLogLevel_346fd770Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_setLogLevel");
  }
  MTM1M3::command_setLogLevel_346fd770DataReader_var SALReader = MTM1M3::command_setLogLevel_346fd770DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setLogLevel_346fd770DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_setLogLevel_346fd770DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_setLogLevel_346fd770DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_setLogLevel(MTM1M3_command_setLogLevelC *data)
{
  int actorIdx = SAL__MTM1M3_command_setLogLevel_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_setLogLevel");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_setLogLevel");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_setLogLevel_346fd770DataWriter_var SALWriter = MTM1M3::command_setLogLevel_346fd770DataWriter::_narrow(dwriter.in());
  MTM1M3::command_setLogLevel_346fd770 Instance;

  Instance.private_revCode = DDS::string_dup("346fd770");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.level = data->level;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_setLogLevel_346fd770 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_setLogLevel_346fd770DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_setLogLevel(MTM1M3_command_setLogLevelC *data)
{
  MTM1M3::command_setLogLevel_346fd770Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_setLogLevel");
  }
  int actorIdx = SAL__MTM1M3_command_setLogLevel_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_setLogLevel");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_setLogLevel_346fd770DataReader_var SALReader = MTM1M3::command_setLogLevel_346fd770DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setLogLevel_346fd770DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_setLogLevel_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_setLogLevel_346fd770DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->level = Instances[j].level;
    lastSample_MTM1M3_command_setLogLevel.level = Instances[j].level;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_setLogLevel_346fd770DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_setLogLevel(MTM1M3_command_setLogLevelC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_setLogLevel_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_setLogLevel_ACTOR].maxSamples = 1;
    istatus = getSample_command_setLogLevel(data);
    sal[SAL__MTM1M3_command_setLogLevel_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_setLogLevel(MTM1M3_command_setLogLevelC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_setLogLevel(data);
    if (istatus == SAL__NO_UPDATES) {
   data->level = lastSample_MTM1M3_command_setLogLevel.level;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_setLogLevel(MTM1M3_command_setLogLevelC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_setLogLevel_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_setLogLevel_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_setLogLevel(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_setLogLevel_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_setSimulationMode_dccc3b3c data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_setSimulationMode");
  }
  MTM1M3::command_setSimulationMode_dccc3b3cDataWriter_var SALWriter = MTM1M3::command_setSimulationMode_dccc3b3cDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("dccc3b3c");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_setSimulationMode_dccc3b3c writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_setSimulationMode_dccc3b3cDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_setSimulationMode_dccc3b3cSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_setSimulationMode");
  }
  MTM1M3::command_setSimulationMode_dccc3b3cDataReader_var SALReader = MTM1M3::command_setSimulationMode_dccc3b3cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_setSimulationMode(MTM1M3_command_setSimulationModeC *data)
{
  int actorIdx = SAL__MTM1M3_command_setSimulationMode_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_setSimulationMode");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_setSimulationMode");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_setSimulationMode_dccc3b3cDataWriter_var SALWriter = MTM1M3::command_setSimulationMode_dccc3b3cDataWriter::_narrow(dwriter.in());
  MTM1M3::command_setSimulationMode_dccc3b3c Instance;

  Instance.private_revCode = DDS::string_dup("dccc3b3c");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.mode = data->mode;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_setSimulationMode_dccc3b3c writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_setSimulationMode_dccc3b3cDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_setSimulationMode(MTM1M3_command_setSimulationModeC *data)
{
  MTM1M3::command_setSimulationMode_dccc3b3cSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_setSimulationMode");
  }
  int actorIdx = SAL__MTM1M3_command_setSimulationMode_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_setSimulationMode");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_setSimulationMode_dccc3b3cDataReader_var SALReader = MTM1M3::command_setSimulationMode_dccc3b3cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_setSimulationMode_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->mode = Instances[j].mode;
    lastSample_MTM1M3_command_setSimulationMode.mode = Instances[j].mode;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_setSimulationMode(MTM1M3_command_setSimulationModeC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_setSimulationMode_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_setSimulationMode_ACTOR].maxSamples = 1;
    istatus = getSample_command_setSimulationMode(data);
    sal[SAL__MTM1M3_command_setSimulationMode_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_setSimulationMode(MTM1M3_command_setSimulationModeC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_setSimulationMode(data);
    if (istatus == SAL__NO_UPDATES) {
   data->mode = lastSample_MTM1M3_command_setSimulationMode.mode;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_setSimulationMode(MTM1M3_command_setSimulationModeC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_setSimulationMode_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_setSimulationMode_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_setSimulationMode(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_setSimulationMode_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_setThermalSetpoint_ca5041e8 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_setThermalSetpoint");
  }
  MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter_var SALWriter = MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("ca5041e8");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_setThermalSetpoint_ca5041e8 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_setThermalSetpoint_ca5041e8Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_setThermalSetpoint");
  }
  MTM1M3::command_setThermalSetpoint_ca5041e8DataReader_var SALReader = MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_setThermalSetpoint(MTM1M3_command_setThermalSetpointC *data)
{
  int actorIdx = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_setThermalSetpoint");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_setThermalSetpoint");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter_var SALWriter = MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter::_narrow(dwriter.in());
  MTM1M3::command_setThermalSetpoint_ca5041e8 Instance;

  Instance.private_revCode = DDS::string_dup("ca5041e8");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.setpoint = data->setpoint;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_setThermalSetpoint_ca5041e8 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_setThermalSetpoint(MTM1M3_command_setThermalSetpointC *data)
{
  MTM1M3::command_setThermalSetpoint_ca5041e8Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_setThermalSetpoint");
  }
  int actorIdx = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_setThermalSetpoint");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_setThermalSetpoint_ca5041e8DataReader_var SALReader = MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_setThermalSetpoint_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->setpoint = Instances[j].setpoint;
    lastSample_MTM1M3_command_setThermalSetpoint.setpoint = Instances[j].setpoint;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_setThermalSetpoint(MTM1M3_command_setThermalSetpointC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_setThermalSetpoint_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_setThermalSetpoint_ACTOR].maxSamples = 1;
    istatus = getSample_command_setThermalSetpoint(data);
    sal[SAL__MTM1M3_command_setThermalSetpoint_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_setThermalSetpoint(MTM1M3_command_setThermalSetpointC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_setThermalSetpoint(data);
    if (istatus == SAL__NO_UPDATES) {
   data->setpoint = lastSample_MTM1M3_command_setThermalSetpoint.setpoint;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_setThermalSetpoint(MTM1M3_command_setThermalSetpointC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_setThermalSetpoint_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_setThermalSetpoint_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_setThermalSetpoint(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_setThermalSetpoint_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_setValue_56638307 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_setValue");
  }
  MTM1M3::command_setValue_56638307DataWriter_var SALWriter = MTM1M3::command_setValue_56638307DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("56638307");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_setValue_56638307 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_setValue_56638307DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_setValue_56638307Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_setValue");
  }
  MTM1M3::command_setValue_56638307DataReader_var SALReader = MTM1M3::command_setValue_56638307DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setValue_56638307DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_setValue_56638307DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_setValue_56638307DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_setValue(MTM1M3_command_setValueC *data)
{
  int actorIdx = SAL__MTM1M3_command_setValue_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_setValue");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_setValue");
  }
    if ( data->parametersAndValues.length() > 256 ) {
       throw std::length_error("Item parametersAndValues exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_setValue_56638307DataWriter_var SALWriter = MTM1M3::command_setValue_56638307DataWriter::_narrow(dwriter.in());
  MTM1M3::command_setValue_56638307 Instance;

  Instance.private_revCode = DDS::string_dup("56638307");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.parametersAndValues = DDS::string_dup(data->parametersAndValues.c_str());


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_setValue_56638307 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_setValue_56638307DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_setValue(MTM1M3_command_setValueC *data)
{
  MTM1M3::command_setValue_56638307Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_setValue");
  }
  int actorIdx = SAL__MTM1M3_command_setValue_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_setValue");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_setValue_56638307DataReader_var SALReader = MTM1M3::command_setValue_56638307DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setValue_56638307DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_setValue_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_setValue_56638307DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->parametersAndValues=Instances[j].parametersAndValues.m_ptr;
    lastSample_MTM1M3_command_setValue.parametersAndValues=Instances[j].parametersAndValues.m_ptr;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_setValue_56638307DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_setValue(MTM1M3_command_setValueC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_setValue_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_setValue_ACTOR].maxSamples = 1;
    istatus = getSample_command_setValue(data);
    sal[SAL__MTM1M3_command_setValue_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_setValue(MTM1M3_command_setValueC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_setValue(data);
    if (istatus == SAL__NO_UPDATES) {
   data->parametersAndValues = lastSample_MTM1M3_command_setValue.parametersAndValues;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_setValue(MTM1M3_command_setValueC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_setValue_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_setValue_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_setValue(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_setValue_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_shutdown_46d06e01 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_shutdown");
  }
  MTM1M3::command_shutdown_46d06e01DataWriter_var SALWriter = MTM1M3::command_shutdown_46d06e01DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("46d06e01");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_shutdown_46d06e01 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_shutdown_46d06e01DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_shutdown_46d06e01Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_shutdown");
  }
  MTM1M3::command_shutdown_46d06e01DataReader_var SALReader = MTM1M3::command_shutdown_46d06e01DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_shutdown_46d06e01DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_shutdown_46d06e01DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_shutdown_46d06e01DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_shutdown(MTM1M3_command_shutdownC *data)
{
  int actorIdx = SAL__MTM1M3_command_shutdown_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_shutdown");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_shutdown");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_shutdown_46d06e01DataWriter_var SALWriter = MTM1M3::command_shutdown_46d06e01DataWriter::_narrow(dwriter.in());
  MTM1M3::command_shutdown_46d06e01 Instance;

  Instance.private_revCode = DDS::string_dup("46d06e01");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.shutdown = data->shutdown;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_shutdown_46d06e01 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_shutdown_46d06e01DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_shutdown(MTM1M3_command_shutdownC *data)
{
  MTM1M3::command_shutdown_46d06e01Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_shutdown");
  }
  int actorIdx = SAL__MTM1M3_command_shutdown_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_shutdown");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_shutdown_46d06e01DataReader_var SALReader = MTM1M3::command_shutdown_46d06e01DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_shutdown_46d06e01DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_shutdown_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_shutdown_46d06e01DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->shutdown = Instances[j].shutdown;
    lastSample_MTM1M3_command_shutdown.shutdown = Instances[j].shutdown;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_shutdown_46d06e01DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_shutdown(MTM1M3_command_shutdownC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_shutdown_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_shutdown_ACTOR].maxSamples = 1;
    istatus = getSample_command_shutdown(data);
    sal[SAL__MTM1M3_command_shutdown_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_shutdown(MTM1M3_command_shutdownC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_shutdown(data);
    if (istatus == SAL__NO_UPDATES) {
   data->shutdown = lastSample_MTM1M3_command_shutdown.shutdown;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_shutdown(MTM1M3_command_shutdownC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_shutdown_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_shutdown_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_shutdown(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_shutdown_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_standby_9b43256c data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_standby");
  }
  MTM1M3::command_standby_9b43256cDataWriter_var SALWriter = MTM1M3::command_standby_9b43256cDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("9b43256c");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_standby_9b43256c writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_standby_9b43256cDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_standby_9b43256cSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_standby");
  }
  MTM1M3::command_standby_9b43256cDataReader_var SALReader = MTM1M3::command_standby_9b43256cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_standby_9b43256cDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_standby_9b43256cDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_standby_9b43256cDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_standby(MTM1M3_command_standbyC *data)
{
  int actorIdx = SAL__MTM1M3_command_standby_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_standby");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_standby");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_standby_9b43256cDataWriter_var SALWriter = MTM1M3::command_standby_9b43256cDataWriter::_narrow(dwriter.in());
  MTM1M3::command_standby_9b43256c Instance;

  Instance.private_revCode = DDS::string_dup("9b43256c");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.value = data->value;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_standby_9b43256c writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_standby_9b43256cDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_standby(MTM1M3_command_standbyC *data)
{
  MTM1M3::command_standby_9b43256cSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_standby");
  }
  int actorIdx = SAL__MTM1M3_command_standby_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_standby");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_standby_9b43256cDataReader_var SALReader = MTM1M3::command_standby_9b43256cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_standby_9b43256cDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_standby_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_standby_9b43256cDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->value = Instances[j].value;
    lastSample_MTM1M3_command_standby.value = Instances[j].value;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_standby_9b43256cDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_standby(MTM1M3_command_standbyC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_standby_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_standby_ACTOR].maxSamples = 1;
    istatus = getSample_command_standby(data);
    sal[SAL__MTM1M3_command_standby_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_standby(MTM1M3_command_standbyC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_standby(data);
    if (istatus == SAL__NO_UPDATES) {
   data->value = lastSample_MTM1M3_command_standby.value;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_standby(MTM1M3_command_standbyC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_standby_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_standby_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_standby(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_standby_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_start_63435b30 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_start");
  }
  MTM1M3::command_start_63435b30DataWriter_var SALWriter = MTM1M3::command_start_63435b30DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("63435b30");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_start_63435b30 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_start_63435b30DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_start_63435b30Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_start");
  }
  MTM1M3::command_start_63435b30DataReader_var SALReader = MTM1M3::command_start_63435b30DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_start_63435b30DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_start_63435b30DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_start_63435b30DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_start(MTM1M3_command_startC *data)
{
  int actorIdx = SAL__MTM1M3_command_start_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_start");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_start");
  }
    if ( data->settingsToApply.length() > 256 ) {
       throw std::length_error("Item settingsToApply exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_start_63435b30DataWriter_var SALWriter = MTM1M3::command_start_63435b30DataWriter::_narrow(dwriter.in());
  MTM1M3::command_start_63435b30 Instance;

  Instance.private_revCode = DDS::string_dup("63435b30");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.settingsToApply = DDS::string_dup(data->settingsToApply.c_str());


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_start_63435b30 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_start_63435b30DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_start(MTM1M3_command_startC *data)
{
  MTM1M3::command_start_63435b30Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_start");
  }
  int actorIdx = SAL__MTM1M3_command_start_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_start");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_start_63435b30DataReader_var SALReader = MTM1M3::command_start_63435b30DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_start_63435b30DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_start_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_start_63435b30DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->settingsToApply=Instances[j].settingsToApply.m_ptr;
    lastSample_MTM1M3_command_start.settingsToApply=Instances[j].settingsToApply.m_ptr;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_start_63435b30DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_start(MTM1M3_command_startC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_start_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_start_ACTOR].maxSamples = 1;
    istatus = getSample_command_start(data);
    sal[SAL__MTM1M3_command_start_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_start(MTM1M3_command_startC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_start(data);
    if (istatus == SAL__NO_UPDATES) {
   data->settingsToApply = lastSample_MTM1M3_command_start.settingsToApply;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_start(MTM1M3_command_startC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_start_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_start_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_start(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_start_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_stopHardpointMotion_727b2152 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_stopHardpointMotion");
  }
  MTM1M3::command_stopHardpointMotion_727b2152DataWriter_var SALWriter = MTM1M3::command_stopHardpointMotion_727b2152DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("727b2152");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_stopHardpointMotion_727b2152 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_stopHardpointMotion_727b2152DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_stopHardpointMotion_727b2152Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_stopHardpointMotion");
  }
  MTM1M3::command_stopHardpointMotion_727b2152DataReader_var SALReader = MTM1M3::command_stopHardpointMotion_727b2152DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_stopHardpointMotion_727b2152DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_stopHardpointMotion_727b2152DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_stopHardpointMotion_727b2152DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_stopHardpointMotion(MTM1M3_command_stopHardpointMotionC *data)
{
  int actorIdx = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_stopHardpointMotion");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_stopHardpointMotion");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_stopHardpointMotion_727b2152DataWriter_var SALWriter = MTM1M3::command_stopHardpointMotion_727b2152DataWriter::_narrow(dwriter.in());
  MTM1M3::command_stopHardpointMotion_727b2152 Instance;

  Instance.private_revCode = DDS::string_dup("727b2152");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.stopHardpointMotion = data->stopHardpointMotion;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_stopHardpointMotion_727b2152 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_stopHardpointMotion_727b2152DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_stopHardpointMotion(MTM1M3_command_stopHardpointMotionC *data)
{
  MTM1M3::command_stopHardpointMotion_727b2152Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_stopHardpointMotion");
  }
  int actorIdx = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_stopHardpointMotion");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_stopHardpointMotion_727b2152DataReader_var SALReader = MTM1M3::command_stopHardpointMotion_727b2152DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_stopHardpointMotion_727b2152DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_stopHardpointMotion_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_stopHardpointMotion_727b2152DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->stopHardpointMotion = Instances[j].stopHardpointMotion;
    lastSample_MTM1M3_command_stopHardpointMotion.stopHardpointMotion = Instances[j].stopHardpointMotion;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_stopHardpointMotion_727b2152DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_stopHardpointMotion(MTM1M3_command_stopHardpointMotionC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_stopHardpointMotion_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_stopHardpointMotion_ACTOR].maxSamples = 1;
    istatus = getSample_command_stopHardpointMotion(data);
    sal[SAL__MTM1M3_command_stopHardpointMotion_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_stopHardpointMotion(MTM1M3_command_stopHardpointMotionC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_stopHardpointMotion(data);
    if (istatus == SAL__NO_UPDATES) {
   data->stopHardpointMotion = lastSample_MTM1M3_command_stopHardpointMotion.stopHardpointMotion;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_stopHardpointMotion(MTM1M3_command_stopHardpointMotionC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_stopHardpointMotion_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_stopHardpointMotion_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_stopHardpointMotion(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_stopHardpointMotion_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_testAir_37cd327c data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_testAir");
  }
  MTM1M3::command_testAir_37cd327cDataWriter_var SALWriter = MTM1M3::command_testAir_37cd327cDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("37cd327c");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_testAir_37cd327c writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_testAir_37cd327cDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_testAir_37cd327cSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_testAir");
  }
  MTM1M3::command_testAir_37cd327cDataReader_var SALReader = MTM1M3::command_testAir_37cd327cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testAir_37cd327cDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_testAir_37cd327cDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_testAir_37cd327cDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_testAir(MTM1M3_command_testAirC *data)
{
  int actorIdx = SAL__MTM1M3_command_testAir_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_testAir");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_testAir");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_testAir_37cd327cDataWriter_var SALWriter = MTM1M3::command_testAir_37cd327cDataWriter::_narrow(dwriter.in());
  MTM1M3::command_testAir_37cd327c Instance;

  Instance.private_revCode = DDS::string_dup("37cd327c");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.testAir = data->testAir;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_testAir_37cd327c writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_testAir_37cd327cDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_testAir(MTM1M3_command_testAirC *data)
{
  MTM1M3::command_testAir_37cd327cSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_testAir");
  }
  int actorIdx = SAL__MTM1M3_command_testAir_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_testAir");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_testAir_37cd327cDataReader_var SALReader = MTM1M3::command_testAir_37cd327cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testAir_37cd327cDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_testAir_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_testAir_37cd327cDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->testAir = Instances[j].testAir;
    lastSample_MTM1M3_command_testAir.testAir = Instances[j].testAir;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_testAir_37cd327cDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_testAir(MTM1M3_command_testAirC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_testAir_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_testAir_ACTOR].maxSamples = 1;
    istatus = getSample_command_testAir(data);
    sal[SAL__MTM1M3_command_testAir_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_testAir(MTM1M3_command_testAirC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_testAir(data);
    if (istatus == SAL__NO_UPDATES) {
   data->testAir = lastSample_MTM1M3_command_testAir.testAir;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_testAir(MTM1M3_command_testAirC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_testAir_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_testAir_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_testAir(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_testAir_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_testForceActuator_f1a37131 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_testForceActuator");
  }
  MTM1M3::command_testForceActuator_f1a37131DataWriter_var SALWriter = MTM1M3::command_testForceActuator_f1a37131DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("f1a37131");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_testForceActuator_f1a37131 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_testForceActuator_f1a37131DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_testForceActuator_f1a37131Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_testForceActuator");
  }
  MTM1M3::command_testForceActuator_f1a37131DataReader_var SALReader = MTM1M3::command_testForceActuator_f1a37131DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testForceActuator_f1a37131DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_testForceActuator_f1a37131DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_testForceActuator_f1a37131DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_testForceActuator(MTM1M3_command_testForceActuatorC *data)
{
  int actorIdx = SAL__MTM1M3_command_testForceActuator_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_testForceActuator");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_testForceActuator");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_testForceActuator_f1a37131DataWriter_var SALWriter = MTM1M3::command_testForceActuator_f1a37131DataWriter::_narrow(dwriter.in());
  MTM1M3::command_testForceActuator_f1a37131 Instance;

  Instance.private_revCode = DDS::string_dup("f1a37131");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.forceActuator = data->forceActuator;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_testForceActuator_f1a37131 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_testForceActuator_f1a37131DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_testForceActuator(MTM1M3_command_testForceActuatorC *data)
{
  MTM1M3::command_testForceActuator_f1a37131Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_testForceActuator");
  }
  int actorIdx = SAL__MTM1M3_command_testForceActuator_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_testForceActuator");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_testForceActuator_f1a37131DataReader_var SALReader = MTM1M3::command_testForceActuator_f1a37131DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testForceActuator_f1a37131DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_testForceActuator_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_testForceActuator_f1a37131DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->forceActuator = Instances[j].forceActuator;
    lastSample_MTM1M3_command_testForceActuator.forceActuator = Instances[j].forceActuator;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_testForceActuator_f1a37131DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_testForceActuator(MTM1M3_command_testForceActuatorC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_testForceActuator_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_testForceActuator_ACTOR].maxSamples = 1;
    istatus = getSample_command_testForceActuator(data);
    sal[SAL__MTM1M3_command_testForceActuator_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_testForceActuator(MTM1M3_command_testForceActuatorC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_testForceActuator(data);
    if (istatus == SAL__NO_UPDATES) {
   data->forceActuator = lastSample_MTM1M3_command_testForceActuator.forceActuator;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_testForceActuator(MTM1M3_command_testForceActuatorC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_testForceActuator_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_testForceActuator_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_testForceActuator(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_testForceActuator_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_testHardpoint_3736f433 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_testHardpoint");
  }
  MTM1M3::command_testHardpoint_3736f433DataWriter_var SALWriter = MTM1M3::command_testHardpoint_3736f433DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("3736f433");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_testHardpoint_3736f433 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_testHardpoint_3736f433DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_testHardpoint_3736f433Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_testHardpoint");
  }
  MTM1M3::command_testHardpoint_3736f433DataReader_var SALReader = MTM1M3::command_testHardpoint_3736f433DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testHardpoint_3736f433DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_testHardpoint_3736f433DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_testHardpoint_3736f433DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_testHardpoint(MTM1M3_command_testHardpointC *data)
{
  int actorIdx = SAL__MTM1M3_command_testHardpoint_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_testHardpoint");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_testHardpoint");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_testHardpoint_3736f433DataWriter_var SALWriter = MTM1M3::command_testHardpoint_3736f433DataWriter::_narrow(dwriter.in());
  MTM1M3::command_testHardpoint_3736f433 Instance;

  Instance.private_revCode = DDS::string_dup("3736f433");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.hardpointActuator = data->hardpointActuator;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_testHardpoint_3736f433 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_testHardpoint_3736f433DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_testHardpoint(MTM1M3_command_testHardpointC *data)
{
  MTM1M3::command_testHardpoint_3736f433Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_testHardpoint");
  }
  int actorIdx = SAL__MTM1M3_command_testHardpoint_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_testHardpoint");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_testHardpoint_3736f433DataReader_var SALReader = MTM1M3::command_testHardpoint_3736f433DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testHardpoint_3736f433DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_testHardpoint_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_testHardpoint_3736f433DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->hardpointActuator = Instances[j].hardpointActuator;
    lastSample_MTM1M3_command_testHardpoint.hardpointActuator = Instances[j].hardpointActuator;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_testHardpoint_3736f433DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_testHardpoint(MTM1M3_command_testHardpointC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_testHardpoint_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_testHardpoint_ACTOR].maxSamples = 1;
    istatus = getSample_command_testHardpoint(data);
    sal[SAL__MTM1M3_command_testHardpoint_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_testHardpoint(MTM1M3_command_testHardpointC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_testHardpoint(data);
    if (istatus == SAL__NO_UPDATES) {
   data->hardpointActuator = lastSample_MTM1M3_command_testHardpoint.hardpointActuator;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_testHardpoint(MTM1M3_command_testHardpointC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_testHardpoint_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_testHardpoint_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_testHardpoint(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_testHardpoint_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_translateM1M3_4d0dfbfe data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_translateM1M3");
  }
  MTM1M3::command_translateM1M3_4d0dfbfeDataWriter_var SALWriter = MTM1M3::command_translateM1M3_4d0dfbfeDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("4d0dfbfe");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_translateM1M3_4d0dfbfe writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_translateM1M3_4d0dfbfeDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_translateM1M3_4d0dfbfeSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_translateM1M3");
  }
  MTM1M3::command_translateM1M3_4d0dfbfeDataReader_var SALReader = MTM1M3::command_translateM1M3_4d0dfbfeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_translateM1M3(MTM1M3_command_translateM1M3C *data)
{
  int actorIdx = SAL__MTM1M3_command_translateM1M3_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_translateM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_translateM1M3");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_translateM1M3_4d0dfbfeDataWriter_var SALWriter = MTM1M3::command_translateM1M3_4d0dfbfeDataWriter::_narrow(dwriter.in());
  MTM1M3::command_translateM1M3_4d0dfbfe Instance;

  Instance.private_revCode = DDS::string_dup("4d0dfbfe");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.xTranslation = data->xTranslation;
    Instance.yTranslation = data->yTranslation;
    Instance.zTranslation = data->zTranslation;
    Instance.xRotation = data->xRotation;
    Instance.yRotation = data->yRotation;
    Instance.zRotation = data->zRotation;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_translateM1M3_4d0dfbfe writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_translateM1M3_4d0dfbfeDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_translateM1M3(MTM1M3_command_translateM1M3C *data)
{
  MTM1M3::command_translateM1M3_4d0dfbfeSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_translateM1M3");
  }
  int actorIdx = SAL__MTM1M3_command_translateM1M3_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_translateM1M3");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_translateM1M3_4d0dfbfeDataReader_var SALReader = MTM1M3::command_translateM1M3_4d0dfbfeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_translateM1M3_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->xTranslation = Instances[j].xTranslation;
    lastSample_MTM1M3_command_translateM1M3.xTranslation = Instances[j].xTranslation;
    data->yTranslation = Instances[j].yTranslation;
    lastSample_MTM1M3_command_translateM1M3.yTranslation = Instances[j].yTranslation;
    data->zTranslation = Instances[j].zTranslation;
    lastSample_MTM1M3_command_translateM1M3.zTranslation = Instances[j].zTranslation;
    data->xRotation = Instances[j].xRotation;
    lastSample_MTM1M3_command_translateM1M3.xRotation = Instances[j].xRotation;
    data->yRotation = Instances[j].yRotation;
    lastSample_MTM1M3_command_translateM1M3.yRotation = Instances[j].yRotation;
    data->zRotation = Instances[j].zRotation;
    lastSample_MTM1M3_command_translateM1M3.zRotation = Instances[j].zRotation;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_translateM1M3(MTM1M3_command_translateM1M3C *data)
{
    int saveMax = sal[SAL__MTM1M3_command_translateM1M3_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_translateM1M3_ACTOR].maxSamples = 1;
    istatus = getSample_command_translateM1M3(data);
    sal[SAL__MTM1M3_command_translateM1M3_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_translateM1M3(MTM1M3_command_translateM1M3C *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_translateM1M3(data);
    if (istatus == SAL__NO_UPDATES) {
   data->xTranslation = lastSample_MTM1M3_command_translateM1M3.xTranslation;
   data->yTranslation = lastSample_MTM1M3_command_translateM1M3.yTranslation;
   data->zTranslation = lastSample_MTM1M3_command_translateM1M3.zTranslation;
   data->xRotation = lastSample_MTM1M3_command_translateM1M3.xRotation;
   data->yRotation = lastSample_MTM1M3_command_translateM1M3.yRotation;
   data->zRotation = lastSample_MTM1M3_command_translateM1M3.zRotation;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_translateM1M3(MTM1M3_command_translateM1M3C *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_translateM1M3_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_translateM1M3_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_translateM1M3(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_translateM1M3_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_turnAirOff_1054819e data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnAirOff");
  }
  MTM1M3::command_turnAirOff_1054819eDataWriter_var SALWriter = MTM1M3::command_turnAirOff_1054819eDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("1054819e");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnAirOff_1054819e writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_turnAirOff_1054819eDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_turnAirOff_1054819eSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnAirOff");
  }
  MTM1M3::command_turnAirOff_1054819eDataReader_var SALReader = MTM1M3::command_turnAirOff_1054819eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnAirOff_1054819eDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnAirOff_1054819eDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_turnAirOff_1054819eDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_turnAirOff(MTM1M3_command_turnAirOffC *data)
{
  int actorIdx = SAL__MTM1M3_command_turnAirOff_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_turnAirOff");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnAirOff");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnAirOff_1054819eDataWriter_var SALWriter = MTM1M3::command_turnAirOff_1054819eDataWriter::_narrow(dwriter.in());
  MTM1M3::command_turnAirOff_1054819e Instance;

  Instance.private_revCode = DDS::string_dup("1054819e");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.turnAirOff = data->turnAirOff;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnAirOff_1054819e writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_turnAirOff_1054819eDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_turnAirOff(MTM1M3_command_turnAirOffC *data)
{
  MTM1M3::command_turnAirOff_1054819eSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_turnAirOff");
  }
  int actorIdx = SAL__MTM1M3_command_turnAirOff_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnAirOff");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnAirOff_1054819eDataReader_var SALReader = MTM1M3::command_turnAirOff_1054819eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnAirOff_1054819eDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_turnAirOff_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnAirOff_1054819eDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->turnAirOff = Instances[j].turnAirOff;
    lastSample_MTM1M3_command_turnAirOff.turnAirOff = Instances[j].turnAirOff;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_turnAirOff_1054819eDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_turnAirOff(MTM1M3_command_turnAirOffC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_turnAirOff_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_turnAirOff_ACTOR].maxSamples = 1;
    istatus = getSample_command_turnAirOff(data);
    sal[SAL__MTM1M3_command_turnAirOff_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_turnAirOff(MTM1M3_command_turnAirOffC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_turnAirOff(data);
    if (istatus == SAL__NO_UPDATES) {
   data->turnAirOff = lastSample_MTM1M3_command_turnAirOff.turnAirOff;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_turnAirOff(MTM1M3_command_turnAirOffC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_turnAirOff_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_turnAirOff_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_turnAirOff(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_turnAirOff_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_turnAirOn_acc6807c data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnAirOn");
  }
  MTM1M3::command_turnAirOn_acc6807cDataWriter_var SALWriter = MTM1M3::command_turnAirOn_acc6807cDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("acc6807c");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnAirOn_acc6807c writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_turnAirOn_acc6807cDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_turnAirOn_acc6807cSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnAirOn");
  }
  MTM1M3::command_turnAirOn_acc6807cDataReader_var SALReader = MTM1M3::command_turnAirOn_acc6807cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnAirOn_acc6807cDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnAirOn_acc6807cDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_turnAirOn_acc6807cDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_turnAirOn(MTM1M3_command_turnAirOnC *data)
{
  int actorIdx = SAL__MTM1M3_command_turnAirOn_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_turnAirOn");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnAirOn");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnAirOn_acc6807cDataWriter_var SALWriter = MTM1M3::command_turnAirOn_acc6807cDataWriter::_narrow(dwriter.in());
  MTM1M3::command_turnAirOn_acc6807c Instance;

  Instance.private_revCode = DDS::string_dup("acc6807c");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.turnAirOn = data->turnAirOn;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnAirOn_acc6807c writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_turnAirOn_acc6807cDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_turnAirOn(MTM1M3_command_turnAirOnC *data)
{
  MTM1M3::command_turnAirOn_acc6807cSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_turnAirOn");
  }
  int actorIdx = SAL__MTM1M3_command_turnAirOn_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnAirOn");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnAirOn_acc6807cDataReader_var SALReader = MTM1M3::command_turnAirOn_acc6807cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnAirOn_acc6807cDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_turnAirOn_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnAirOn_acc6807cDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->turnAirOn = Instances[j].turnAirOn;
    lastSample_MTM1M3_command_turnAirOn.turnAirOn = Instances[j].turnAirOn;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_turnAirOn_acc6807cDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_turnAirOn(MTM1M3_command_turnAirOnC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_turnAirOn_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_turnAirOn_ACTOR].maxSamples = 1;
    istatus = getSample_command_turnAirOn(data);
    sal[SAL__MTM1M3_command_turnAirOn_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_turnAirOn(MTM1M3_command_turnAirOnC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_turnAirOn(data);
    if (istatus == SAL__NO_UPDATES) {
   data->turnAirOn = lastSample_MTM1M3_command_turnAirOn.turnAirOn;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_turnAirOn(MTM1M3_command_turnAirOnC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_turnAirOn_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_turnAirOn_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_turnAirOn(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_turnAirOn_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_turnLightsOff_08b6e5a2 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnLightsOff");
  }
  MTM1M3::command_turnLightsOff_08b6e5a2DataWriter_var SALWriter = MTM1M3::command_turnLightsOff_08b6e5a2DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("08b6e5a2");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnLightsOff_08b6e5a2 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_turnLightsOff_08b6e5a2DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_turnLightsOff_08b6e5a2Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnLightsOff");
  }
  MTM1M3::command_turnLightsOff_08b6e5a2DataReader_var SALReader = MTM1M3::command_turnLightsOff_08b6e5a2DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_turnLightsOff(MTM1M3_command_turnLightsOffC *data)
{
  int actorIdx = SAL__MTM1M3_command_turnLightsOff_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_turnLightsOff");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnLightsOff");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnLightsOff_08b6e5a2DataWriter_var SALWriter = MTM1M3::command_turnLightsOff_08b6e5a2DataWriter::_narrow(dwriter.in());
  MTM1M3::command_turnLightsOff_08b6e5a2 Instance;

  Instance.private_revCode = DDS::string_dup("08b6e5a2");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.turnLightsOff = data->turnLightsOff;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnLightsOff_08b6e5a2 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_turnLightsOff_08b6e5a2DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_turnLightsOff(MTM1M3_command_turnLightsOffC *data)
{
  MTM1M3::command_turnLightsOff_08b6e5a2Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_turnLightsOff");
  }
  int actorIdx = SAL__MTM1M3_command_turnLightsOff_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnLightsOff");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnLightsOff_08b6e5a2DataReader_var SALReader = MTM1M3::command_turnLightsOff_08b6e5a2DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_turnLightsOff_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->turnLightsOff = Instances[j].turnLightsOff;
    lastSample_MTM1M3_command_turnLightsOff.turnLightsOff = Instances[j].turnLightsOff;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_turnLightsOff(MTM1M3_command_turnLightsOffC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_turnLightsOff_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_turnLightsOff_ACTOR].maxSamples = 1;
    istatus = getSample_command_turnLightsOff(data);
    sal[SAL__MTM1M3_command_turnLightsOff_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_turnLightsOff(MTM1M3_command_turnLightsOffC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_turnLightsOff(data);
    if (istatus == SAL__NO_UPDATES) {
   data->turnLightsOff = lastSample_MTM1M3_command_turnLightsOff.turnLightsOff;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_turnLightsOff(MTM1M3_command_turnLightsOffC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_turnLightsOff_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_turnLightsOff_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_turnLightsOff(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_turnLightsOff_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_turnLightsOn_89e80426 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnLightsOn");
  }
  MTM1M3::command_turnLightsOn_89e80426DataWriter_var SALWriter = MTM1M3::command_turnLightsOn_89e80426DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("89e80426");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnLightsOn_89e80426 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_turnLightsOn_89e80426DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_turnLightsOn_89e80426Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnLightsOn");
  }
  MTM1M3::command_turnLightsOn_89e80426DataReader_var SALReader = MTM1M3::command_turnLightsOn_89e80426DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnLightsOn_89e80426DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnLightsOn_89e80426DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_turnLightsOn_89e80426DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_turnLightsOn(MTM1M3_command_turnLightsOnC *data)
{
  int actorIdx = SAL__MTM1M3_command_turnLightsOn_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_turnLightsOn");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnLightsOn");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnLightsOn_89e80426DataWriter_var SALWriter = MTM1M3::command_turnLightsOn_89e80426DataWriter::_narrow(dwriter.in());
  MTM1M3::command_turnLightsOn_89e80426 Instance;

  Instance.private_revCode = DDS::string_dup("89e80426");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.turnLightsOn = data->turnLightsOn;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnLightsOn_89e80426 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_turnLightsOn_89e80426DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_turnLightsOn(MTM1M3_command_turnLightsOnC *data)
{
  MTM1M3::command_turnLightsOn_89e80426Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_turnLightsOn");
  }
  int actorIdx = SAL__MTM1M3_command_turnLightsOn_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnLightsOn");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnLightsOn_89e80426DataReader_var SALReader = MTM1M3::command_turnLightsOn_89e80426DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnLightsOn_89e80426DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_turnLightsOn_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnLightsOn_89e80426DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->turnLightsOn = Instances[j].turnLightsOn;
    lastSample_MTM1M3_command_turnLightsOn.turnLightsOn = Instances[j].turnLightsOn;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_turnLightsOn_89e80426DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_turnLightsOn(MTM1M3_command_turnLightsOnC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_turnLightsOn_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_turnLightsOn_ACTOR].maxSamples = 1;
    istatus = getSample_command_turnLightsOn(data);
    sal[SAL__MTM1M3_command_turnLightsOn_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_turnLightsOn(MTM1M3_command_turnLightsOnC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_turnLightsOn(data);
    if (istatus == SAL__NO_UPDATES) {
   data->turnLightsOn = lastSample_MTM1M3_command_turnLightsOn.turnLightsOn;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_turnLightsOn(MTM1M3_command_turnLightsOnC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_turnLightsOn_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_turnLightsOn_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_turnLightsOn(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_turnLightsOn_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_turnPowerOff_41dde1fd data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnPowerOff");
  }
  MTM1M3::command_turnPowerOff_41dde1fdDataWriter_var SALWriter = MTM1M3::command_turnPowerOff_41dde1fdDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("41dde1fd");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnPowerOff_41dde1fd writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_turnPowerOff_41dde1fdDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_turnPowerOff_41dde1fdSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnPowerOff");
  }
  MTM1M3::command_turnPowerOff_41dde1fdDataReader_var SALReader = MTM1M3::command_turnPowerOff_41dde1fdDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnPowerOff_41dde1fdDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnPowerOff_41dde1fdDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_turnPowerOff_41dde1fdDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_turnPowerOff(MTM1M3_command_turnPowerOffC *data)
{
  int actorIdx = SAL__MTM1M3_command_turnPowerOff_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_turnPowerOff");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnPowerOff");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnPowerOff_41dde1fdDataWriter_var SALWriter = MTM1M3::command_turnPowerOff_41dde1fdDataWriter::_narrow(dwriter.in());
  MTM1M3::command_turnPowerOff_41dde1fd Instance;

  Instance.private_revCode = DDS::string_dup("41dde1fd");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.turnPowerNetworkAOff = data->turnPowerNetworkAOff;
    Instance.turnPowerNetworkBOff = data->turnPowerNetworkBOff;
    Instance.turnPowerNetworkCOff = data->turnPowerNetworkCOff;
    Instance.turnPowerNetworkDOff = data->turnPowerNetworkDOff;
    Instance.turnAuxPowerNetworkAOff = data->turnAuxPowerNetworkAOff;
    Instance.turnAuxPowerNetworkBOff = data->turnAuxPowerNetworkBOff;
    Instance.turnAuxPowerNetworkCOff = data->turnAuxPowerNetworkCOff;
    Instance.turnAuxPowerNetworkDOff = data->turnAuxPowerNetworkDOff;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnPowerOff_41dde1fd writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_turnPowerOff_41dde1fdDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_turnPowerOff(MTM1M3_command_turnPowerOffC *data)
{
  MTM1M3::command_turnPowerOff_41dde1fdSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_turnPowerOff");
  }
  int actorIdx = SAL__MTM1M3_command_turnPowerOff_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnPowerOff");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnPowerOff_41dde1fdDataReader_var SALReader = MTM1M3::command_turnPowerOff_41dde1fdDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnPowerOff_41dde1fdDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_turnPowerOff_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnPowerOff_41dde1fdDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->turnPowerNetworkAOff = Instances[j].turnPowerNetworkAOff;
    lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkAOff = Instances[j].turnPowerNetworkAOff;
    data->turnPowerNetworkBOff = Instances[j].turnPowerNetworkBOff;
    lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkBOff = Instances[j].turnPowerNetworkBOff;
    data->turnPowerNetworkCOff = Instances[j].turnPowerNetworkCOff;
    lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkCOff = Instances[j].turnPowerNetworkCOff;
    data->turnPowerNetworkDOff = Instances[j].turnPowerNetworkDOff;
    lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkDOff = Instances[j].turnPowerNetworkDOff;
    data->turnAuxPowerNetworkAOff = Instances[j].turnAuxPowerNetworkAOff;
    lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkAOff = Instances[j].turnAuxPowerNetworkAOff;
    data->turnAuxPowerNetworkBOff = Instances[j].turnAuxPowerNetworkBOff;
    lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkBOff = Instances[j].turnAuxPowerNetworkBOff;
    data->turnAuxPowerNetworkCOff = Instances[j].turnAuxPowerNetworkCOff;
    lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkCOff = Instances[j].turnAuxPowerNetworkCOff;
    data->turnAuxPowerNetworkDOff = Instances[j].turnAuxPowerNetworkDOff;
    lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkDOff = Instances[j].turnAuxPowerNetworkDOff;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_turnPowerOff_41dde1fdDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_turnPowerOff(MTM1M3_command_turnPowerOffC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_turnPowerOff_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_turnPowerOff_ACTOR].maxSamples = 1;
    istatus = getSample_command_turnPowerOff(data);
    sal[SAL__MTM1M3_command_turnPowerOff_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_turnPowerOff(MTM1M3_command_turnPowerOffC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_turnPowerOff(data);
    if (istatus == SAL__NO_UPDATES) {
   data->turnPowerNetworkAOff = lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkAOff;
   data->turnPowerNetworkBOff = lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkBOff;
   data->turnPowerNetworkCOff = lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkCOff;
   data->turnPowerNetworkDOff = lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkDOff;
   data->turnAuxPowerNetworkAOff = lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkAOff;
   data->turnAuxPowerNetworkBOff = lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkBOff;
   data->turnAuxPowerNetworkCOff = lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkCOff;
   data->turnAuxPowerNetworkDOff = lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkDOff;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_turnPowerOff(MTM1M3_command_turnPowerOffC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_turnPowerOff_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_turnPowerOff_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_turnPowerOff(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_turnPowerOff_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_turnPowerOn_7c3fbe06 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnPowerOn");
  }
  MTM1M3::command_turnPowerOn_7c3fbe06DataWriter_var SALWriter = MTM1M3::command_turnPowerOn_7c3fbe06DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("7c3fbe06");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnPowerOn_7c3fbe06 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_turnPowerOn_7c3fbe06DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_turnPowerOn_7c3fbe06Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnPowerOn");
  }
  MTM1M3::command_turnPowerOn_7c3fbe06DataReader_var SALReader = MTM1M3::command_turnPowerOn_7c3fbe06DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_turnPowerOn(MTM1M3_command_turnPowerOnC *data)
{
  int actorIdx = SAL__MTM1M3_command_turnPowerOn_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_turnPowerOn");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_turnPowerOn");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnPowerOn_7c3fbe06DataWriter_var SALWriter = MTM1M3::command_turnPowerOn_7c3fbe06DataWriter::_narrow(dwriter.in());
  MTM1M3::command_turnPowerOn_7c3fbe06 Instance;

  Instance.private_revCode = DDS::string_dup("7c3fbe06");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.turnPowerNetworkAOn = data->turnPowerNetworkAOn;
    Instance.turnPowerNetworkBOn = data->turnPowerNetworkBOn;
    Instance.turnPowerNetworkCOn = data->turnPowerNetworkCOn;
    Instance.turnPowerNetworkDOn = data->turnPowerNetworkDOn;
    Instance.turnAuxPowerNetworkAOn = data->turnAuxPowerNetworkAOn;
    Instance.turnAuxPowerNetworkBOn = data->turnAuxPowerNetworkBOn;
    Instance.turnAuxPowerNetworkCOn = data->turnAuxPowerNetworkCOn;
    Instance.turnAuxPowerNetworkDOn = data->turnAuxPowerNetworkDOn;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_turnPowerOn_7c3fbe06 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_turnPowerOn_7c3fbe06DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_turnPowerOn(MTM1M3_command_turnPowerOnC *data)
{
  MTM1M3::command_turnPowerOn_7c3fbe06Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_turnPowerOn");
  }
  int actorIdx = SAL__MTM1M3_command_turnPowerOn_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_turnPowerOn");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_turnPowerOn_7c3fbe06DataReader_var SALReader = MTM1M3::command_turnPowerOn_7c3fbe06DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_turnPowerOn_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->turnPowerNetworkAOn = Instances[j].turnPowerNetworkAOn;
    lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkAOn = Instances[j].turnPowerNetworkAOn;
    data->turnPowerNetworkBOn = Instances[j].turnPowerNetworkBOn;
    lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkBOn = Instances[j].turnPowerNetworkBOn;
    data->turnPowerNetworkCOn = Instances[j].turnPowerNetworkCOn;
    lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkCOn = Instances[j].turnPowerNetworkCOn;
    data->turnPowerNetworkDOn = Instances[j].turnPowerNetworkDOn;
    lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkDOn = Instances[j].turnPowerNetworkDOn;
    data->turnAuxPowerNetworkAOn = Instances[j].turnAuxPowerNetworkAOn;
    lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkAOn = Instances[j].turnAuxPowerNetworkAOn;
    data->turnAuxPowerNetworkBOn = Instances[j].turnAuxPowerNetworkBOn;
    lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkBOn = Instances[j].turnAuxPowerNetworkBOn;
    data->turnAuxPowerNetworkCOn = Instances[j].turnAuxPowerNetworkCOn;
    lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkCOn = Instances[j].turnAuxPowerNetworkCOn;
    data->turnAuxPowerNetworkDOn = Instances[j].turnAuxPowerNetworkDOn;
    lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkDOn = Instances[j].turnAuxPowerNetworkDOn;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_turnPowerOn(MTM1M3_command_turnPowerOnC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_turnPowerOn_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_turnPowerOn_ACTOR].maxSamples = 1;
    istatus = getSample_command_turnPowerOn(data);
    sal[SAL__MTM1M3_command_turnPowerOn_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_turnPowerOn(MTM1M3_command_turnPowerOnC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_turnPowerOn(data);
    if (istatus == SAL__NO_UPDATES) {
   data->turnPowerNetworkAOn = lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkAOn;
   data->turnPowerNetworkBOn = lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkBOn;
   data->turnPowerNetworkCOn = lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkCOn;
   data->turnPowerNetworkDOn = lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkDOn;
   data->turnAuxPowerNetworkAOn = lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkAOn;
   data->turnAuxPowerNetworkBOn = lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkBOn;
   data->turnAuxPowerNetworkCOn = lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkCOn;
   data->turnAuxPowerNetworkDOn = lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkDOn;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_turnPowerOn(MTM1M3_command_turnPowerOnC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_turnPowerOn_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_turnPowerOn_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_turnPowerOn(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_turnPowerOn_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::command_updatePID_6e2af9f8 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_updatePID");
  }
  MTM1M3::command_updatePID_6e2af9f8DataWriter_var SALWriter = MTM1M3::command_updatePID_6e2af9f8DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("6e2af9f8");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_updatePID_6e2af9f8 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::command_updatePID_6e2af9f8DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::command_updatePID_6e2af9f8Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_updatePID");
  }
  MTM1M3::command_updatePID_6e2af9f8DataReader_var SALReader = MTM1M3::command_updatePID_6e2af9f8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_updatePID_6e2af9f8DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_updatePID_6e2af9f8DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::command_updatePID_6e2af9f8DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_command_updatePID(MTM1M3_command_updatePIDC *data)
{
  int actorIdx = SAL__MTM1M3_command_updatePID_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_command_updatePID");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_command_updatePID");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_updatePID_6e2af9f8DataWriter_var SALWriter = MTM1M3::command_updatePID_6e2af9f8DataWriter::_narrow(dwriter.in());
  MTM1M3::command_updatePID_6e2af9f8 Instance;

  Instance.private_revCode = DDS::string_dup("6e2af9f8");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.pid = data->pid;
    Instance.timestep = data->timestep;
    Instance.p = data->p;
    Instance.i = data->i;
    Instance.d = data->d;
    Instance.n = data->n;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::command_updatePID_6e2af9f8 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::command_updatePID_6e2af9f8DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_command_updatePID(MTM1M3_command_updatePIDC *data)
{
  MTM1M3::command_updatePID_6e2af9f8Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_command_updatePID");
  }
  int actorIdx = SAL__MTM1M3_command_updatePID_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_command_updatePID");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::command_updatePID_6e2af9f8DataReader_var SALReader = MTM1M3::command_updatePID_6e2af9f8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_updatePID_6e2af9f8DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_command_updatePID_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::command_updatePID_6e2af9f8DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->pid = Instances[j].pid;
    lastSample_MTM1M3_command_updatePID.pid = Instances[j].pid;
    data->timestep = Instances[j].timestep;
    lastSample_MTM1M3_command_updatePID.timestep = Instances[j].timestep;
    data->p = Instances[j].p;
    lastSample_MTM1M3_command_updatePID.p = Instances[j].p;
    data->i = Instances[j].i;
    lastSample_MTM1M3_command_updatePID.i = Instances[j].i;
    data->d = Instances[j].d;
    lastSample_MTM1M3_command_updatePID.d = Instances[j].d;
    data->n = Instances[j].n;
    lastSample_MTM1M3_command_updatePID.n = Instances[j].n;
     istatus = Instances[j].private_seqNum;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::command_updatePID_6e2af9f8DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_command_updatePID(MTM1M3_command_updatePIDC *data)
{
    int saveMax = sal[SAL__MTM1M3_command_updatePID_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_command_updatePID_ACTOR].maxSamples = 1;
    istatus = getSample_command_updatePID(data);
    sal[SAL__MTM1M3_command_updatePID_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_command_updatePID(MTM1M3_command_updatePIDC *data)
{
    salReturn istatus = -1;
    istatus = getSample_command_updatePID(data);
    if (istatus == SAL__NO_UPDATES) {
   data->pid = lastSample_MTM1M3_command_updatePID.pid;
   data->timestep = lastSample_MTM1M3_command_updatePID.timestep;
   data->p = lastSample_MTM1M3_command_updatePID.p;
   data->i = lastSample_MTM1M3_command_updatePID.i;
   data->d = lastSample_MTM1M3_command_updatePID.d;
   data->n = lastSample_MTM1M3_command_updatePID.n;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_command_updatePID(MTM1M3_command_updatePIDC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_command_updatePID_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_command_updatePID_ACTOR].sampleAge = -1.0;
    istatus = getSample_command_updatePID(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_command_updatePID_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::forceActuatorData_5d276d43 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_forceActuatorData");
  }
  MTM1M3::forceActuatorData_5d276d43DataWriter_var SALWriter = MTM1M3::forceActuatorData_5d276d43DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("5d276d43");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::forceActuatorData_5d276d43 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::forceActuatorData_5d276d43DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::forceActuatorData_5d276d43Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_forceActuatorData");
  }
  MTM1M3::forceActuatorData_5d276d43DataReader_var SALReader = MTM1M3::forceActuatorData_5d276d43DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::forceActuatorData_5d276d43DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::forceActuatorData_5d276d43DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::forceActuatorData_5d276d43DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_forceActuatorData(MTM1M3_forceActuatorDataC *data)
{
  int actorIdx = SAL__MTM1M3_forceActuatorData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_forceActuatorData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_forceActuatorData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::forceActuatorData_5d276d43DataWriter_var SALWriter = MTM1M3::forceActuatorData_5d276d43DataWriter::_narrow(dwriter.in());
  MTM1M3::forceActuatorData_5d276d43 Instance;

  Instance.private_revCode = DDS::string_dup("5d276d43");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<156;iseq++) {Instance.primaryCylinderForce[iseq] = data->primaryCylinderForce[iseq];}
    for (int iseq=0;iseq<112;iseq++) {Instance.secondaryCylinderForce[iseq] = data->secondaryCylinderForce[iseq];}
    for (int iseq=0;iseq<12;iseq++) {Instance.xForce[iseq] = data->xForce[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForce[iseq] = data->yForce[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForce[iseq] = data->zForce[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::forceActuatorData_5d276d43 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::forceActuatorData_5d276d43DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_forceActuatorData(MTM1M3_forceActuatorDataC *data)
{
  MTM1M3::forceActuatorData_5d276d43Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_forceActuatorData");
  }
  int actorIdx = SAL__MTM1M3_forceActuatorData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_forceActuatorData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::forceActuatorData_5d276d43DataReader_var SALReader = MTM1M3::forceActuatorData_5d276d43DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::forceActuatorData_5d276d43DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_forceActuatorData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::forceActuatorData_5d276d43DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_forceActuatorData.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->primaryCylinderForce[iseq] = Instances[j].primaryCylinderForce[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_forceActuatorData.primaryCylinderForce[iseq] = Instances[j].primaryCylinderForce[iseq];}
    for (int iseq=0;iseq<112;iseq++) {data->secondaryCylinderForce[iseq] = Instances[j].secondaryCylinderForce[iseq];}
    for (int iseq=0;iseq<112;iseq++) {lastSample_MTM1M3_forceActuatorData.secondaryCylinderForce[iseq] = Instances[j].secondaryCylinderForce[iseq];}
    for (int iseq=0;iseq<12;iseq++) {data->xForce[iseq] = Instances[j].xForce[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_forceActuatorData.xForce[iseq] = Instances[j].xForce[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForce[iseq] = Instances[j].yForce[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_forceActuatorData.yForce[iseq] = Instances[j].yForce[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForce[iseq] = Instances[j].zForce[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_forceActuatorData.zForce[iseq] = Instances[j].zForce[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_forceActuatorData.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_forceActuatorData.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_forceActuatorData.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_forceActuatorData.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_forceActuatorData.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_forceActuatorData.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_forceActuatorData.forceMagnitude = Instances[j].forceMagnitude;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::forceActuatorData_5d276d43DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_forceActuatorData(MTM1M3_forceActuatorDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_forceActuatorData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_forceActuatorData_ACTOR].maxSamples = 1;
    istatus = getSample_forceActuatorData(data);
    sal[SAL__MTM1M3_forceActuatorData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_forceActuatorData(MTM1M3_forceActuatorDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_forceActuatorData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_forceActuatorData.timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->primaryCylinderForce[iseq] = lastSample_MTM1M3_forceActuatorData.primaryCylinderForce[iseq];}
    for (int iseq=0;iseq<112;iseq++) {data->secondaryCylinderForce[iseq] = lastSample_MTM1M3_forceActuatorData.secondaryCylinderForce[iseq];}
    for (int iseq=0;iseq<12;iseq++) {data->xForce[iseq] = lastSample_MTM1M3_forceActuatorData.xForce[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForce[iseq] = lastSample_MTM1M3_forceActuatorData.yForce[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForce[iseq] = lastSample_MTM1M3_forceActuatorData.zForce[iseq];}
   data->fx = lastSample_MTM1M3_forceActuatorData.fx;
   data->fy = lastSample_MTM1M3_forceActuatorData.fy;
   data->fz = lastSample_MTM1M3_forceActuatorData.fz;
   data->mx = lastSample_MTM1M3_forceActuatorData.mx;
   data->my = lastSample_MTM1M3_forceActuatorData.my;
   data->mz = lastSample_MTM1M3_forceActuatorData.mz;
   data->forceMagnitude = lastSample_MTM1M3_forceActuatorData.forceMagnitude;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_forceActuatorData(MTM1M3_forceActuatorDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_forceActuatorData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_forceActuatorData_ACTOR].sampleAge = -1.0;
    istatus = getSample_forceActuatorData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_forceActuatorData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::gyroData_52effcca data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_gyroData");
  }
  MTM1M3::gyroData_52effccaDataWriter_var SALWriter = MTM1M3::gyroData_52effccaDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("52effcca");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::gyroData_52effcca writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::gyroData_52effccaDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::gyroData_52effccaSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_gyroData");
  }
  MTM1M3::gyroData_52effccaDataReader_var SALReader = MTM1M3::gyroData_52effccaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::gyroData_52effccaDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::gyroData_52effccaDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::gyroData_52effccaDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_gyroData(MTM1M3_gyroDataC *data)
{
  int actorIdx = SAL__MTM1M3_gyroData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_gyroData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_gyroData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::gyroData_52effccaDataWriter_var SALWriter = MTM1M3::gyroData_52effccaDataWriter::_narrow(dwriter.in());
  MTM1M3::gyroData_52effcca Instance;

  Instance.private_revCode = DDS::string_dup("52effcca");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.angularVelocityX = data->angularVelocityX;
    Instance.angularVelocityY = data->angularVelocityY;
    Instance.angularVelocityZ = data->angularVelocityZ;
    Instance.sequenceNumber = data->sequenceNumber;
    Instance.temperature = data->temperature;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::gyroData_52effcca writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::gyroData_52effccaDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_gyroData(MTM1M3_gyroDataC *data)
{
  MTM1M3::gyroData_52effccaSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_gyroData");
  }
  int actorIdx = SAL__MTM1M3_gyroData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_gyroData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::gyroData_52effccaDataReader_var SALReader = MTM1M3::gyroData_52effccaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::gyroData_52effccaDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_gyroData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::gyroData_52effccaDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_gyroData.timestamp = Instances[j].timestamp;
    data->angularVelocityX = Instances[j].angularVelocityX;
    lastSample_MTM1M3_gyroData.angularVelocityX = Instances[j].angularVelocityX;
    data->angularVelocityY = Instances[j].angularVelocityY;
    lastSample_MTM1M3_gyroData.angularVelocityY = Instances[j].angularVelocityY;
    data->angularVelocityZ = Instances[j].angularVelocityZ;
    lastSample_MTM1M3_gyroData.angularVelocityZ = Instances[j].angularVelocityZ;
    data->sequenceNumber = Instances[j].sequenceNumber;
    lastSample_MTM1M3_gyroData.sequenceNumber = Instances[j].sequenceNumber;
    data->temperature = Instances[j].temperature;
    lastSample_MTM1M3_gyroData.temperature = Instances[j].temperature;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::gyroData_52effccaDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_gyroData(MTM1M3_gyroDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_gyroData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_gyroData_ACTOR].maxSamples = 1;
    istatus = getSample_gyroData(data);
    sal[SAL__MTM1M3_gyroData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_gyroData(MTM1M3_gyroDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_gyroData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_gyroData.timestamp;
   data->angularVelocityX = lastSample_MTM1M3_gyroData.angularVelocityX;
   data->angularVelocityY = lastSample_MTM1M3_gyroData.angularVelocityY;
   data->angularVelocityZ = lastSample_MTM1M3_gyroData.angularVelocityZ;
   data->sequenceNumber = lastSample_MTM1M3_gyroData.sequenceNumber;
   data->temperature = lastSample_MTM1M3_gyroData.temperature;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_gyroData(MTM1M3_gyroDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_gyroData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_gyroData_ACTOR].sampleAge = -1.0;
    istatus = getSample_gyroData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_gyroData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::hardpointActuatorData_e4c2857f data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_hardpointActuatorData");
  }
  MTM1M3::hardpointActuatorData_e4c2857fDataWriter_var SALWriter = MTM1M3::hardpointActuatorData_e4c2857fDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("e4c2857f");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::hardpointActuatorData_e4c2857f writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::hardpointActuatorData_e4c2857fDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::hardpointActuatorData_e4c2857fSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_hardpointActuatorData");
  }
  MTM1M3::hardpointActuatorData_e4c2857fDataReader_var SALReader = MTM1M3::hardpointActuatorData_e4c2857fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::hardpointActuatorData_e4c2857fDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::hardpointActuatorData_e4c2857fDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::hardpointActuatorData_e4c2857fDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_hardpointActuatorData(MTM1M3_hardpointActuatorDataC *data)
{
  int actorIdx = SAL__MTM1M3_hardpointActuatorData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_hardpointActuatorData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_hardpointActuatorData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::hardpointActuatorData_e4c2857fDataWriter_var SALWriter = MTM1M3::hardpointActuatorData_e4c2857fDataWriter::_narrow(dwriter.in());
  MTM1M3::hardpointActuatorData_e4c2857f Instance;

  Instance.private_revCode = DDS::string_dup("e4c2857f");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<6;iseq++) {Instance.stepsQueued[iseq] = data->stepsQueued[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.stepsCommanded[iseq] = data->stepsCommanded[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.measuredForce[iseq] = data->measuredForce[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.encoder[iseq] = data->encoder[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.displacement[iseq] = data->displacement[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.xPosition = data->xPosition;
    Instance.yPosition = data->yPosition;
    Instance.zPosition = data->zPosition;
    Instance.xRotation = data->xRotation;
    Instance.yRotation = data->yRotation;
    Instance.zRotation = data->zRotation;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::hardpointActuatorData_e4c2857f writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::hardpointActuatorData_e4c2857fDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_hardpointActuatorData(MTM1M3_hardpointActuatorDataC *data)
{
  MTM1M3::hardpointActuatorData_e4c2857fSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_hardpointActuatorData");
  }
  int actorIdx = SAL__MTM1M3_hardpointActuatorData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_hardpointActuatorData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::hardpointActuatorData_e4c2857fDataReader_var SALReader = MTM1M3::hardpointActuatorData_e4c2857fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::hardpointActuatorData_e4c2857fDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_hardpointActuatorData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::hardpointActuatorData_e4c2857fDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_hardpointActuatorData.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->stepsQueued[iseq] = Instances[j].stepsQueued[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointActuatorData.stepsQueued[iseq] = Instances[j].stepsQueued[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->stepsCommanded[iseq] = Instances[j].stepsCommanded[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointActuatorData.stepsCommanded[iseq] = Instances[j].stepsCommanded[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->measuredForce[iseq] = Instances[j].measuredForce[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointActuatorData.measuredForce[iseq] = Instances[j].measuredForce[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->encoder[iseq] = Instances[j].encoder[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointActuatorData.encoder[iseq] = Instances[j].encoder[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->displacement[iseq] = Instances[j].displacement[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointActuatorData.displacement[iseq] = Instances[j].displacement[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_hardpointActuatorData.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_hardpointActuatorData.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_hardpointActuatorData.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_hardpointActuatorData.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_hardpointActuatorData.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_hardpointActuatorData.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_hardpointActuatorData.forceMagnitude = Instances[j].forceMagnitude;
    data->xPosition = Instances[j].xPosition;
    lastSample_MTM1M3_hardpointActuatorData.xPosition = Instances[j].xPosition;
    data->yPosition = Instances[j].yPosition;
    lastSample_MTM1M3_hardpointActuatorData.yPosition = Instances[j].yPosition;
    data->zPosition = Instances[j].zPosition;
    lastSample_MTM1M3_hardpointActuatorData.zPosition = Instances[j].zPosition;
    data->xRotation = Instances[j].xRotation;
    lastSample_MTM1M3_hardpointActuatorData.xRotation = Instances[j].xRotation;
    data->yRotation = Instances[j].yRotation;
    lastSample_MTM1M3_hardpointActuatorData.yRotation = Instances[j].yRotation;
    data->zRotation = Instances[j].zRotation;
    lastSample_MTM1M3_hardpointActuatorData.zRotation = Instances[j].zRotation;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::hardpointActuatorData_e4c2857fDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_hardpointActuatorData(MTM1M3_hardpointActuatorDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_hardpointActuatorData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_hardpointActuatorData_ACTOR].maxSamples = 1;
    istatus = getSample_hardpointActuatorData(data);
    sal[SAL__MTM1M3_hardpointActuatorData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_hardpointActuatorData(MTM1M3_hardpointActuatorDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_hardpointActuatorData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_hardpointActuatorData.timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->stepsQueued[iseq] = lastSample_MTM1M3_hardpointActuatorData.stepsQueued[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->stepsCommanded[iseq] = lastSample_MTM1M3_hardpointActuatorData.stepsCommanded[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->measuredForce[iseq] = lastSample_MTM1M3_hardpointActuatorData.measuredForce[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->encoder[iseq] = lastSample_MTM1M3_hardpointActuatorData.encoder[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->displacement[iseq] = lastSample_MTM1M3_hardpointActuatorData.displacement[iseq];}
   data->fx = lastSample_MTM1M3_hardpointActuatorData.fx;
   data->fy = lastSample_MTM1M3_hardpointActuatorData.fy;
   data->fz = lastSample_MTM1M3_hardpointActuatorData.fz;
   data->mx = lastSample_MTM1M3_hardpointActuatorData.mx;
   data->my = lastSample_MTM1M3_hardpointActuatorData.my;
   data->mz = lastSample_MTM1M3_hardpointActuatorData.mz;
   data->forceMagnitude = lastSample_MTM1M3_hardpointActuatorData.forceMagnitude;
   data->xPosition = lastSample_MTM1M3_hardpointActuatorData.xPosition;
   data->yPosition = lastSample_MTM1M3_hardpointActuatorData.yPosition;
   data->zPosition = lastSample_MTM1M3_hardpointActuatorData.zPosition;
   data->xRotation = lastSample_MTM1M3_hardpointActuatorData.xRotation;
   data->yRotation = lastSample_MTM1M3_hardpointActuatorData.yRotation;
   data->zRotation = lastSample_MTM1M3_hardpointActuatorData.zRotation;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_hardpointActuatorData(MTM1M3_hardpointActuatorDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_hardpointActuatorData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_hardpointActuatorData_ACTOR].sampleAge = -1.0;
    istatus = getSample_hardpointActuatorData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_hardpointActuatorData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::hardpointMonitorData_8caedbd0 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_hardpointMonitorData");
  }
  MTM1M3::hardpointMonitorData_8caedbd0DataWriter_var SALWriter = MTM1M3::hardpointMonitorData_8caedbd0DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("8caedbd0");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::hardpointMonitorData_8caedbd0 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::hardpointMonitorData_8caedbd0DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::hardpointMonitorData_8caedbd0Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_hardpointMonitorData");
  }
  MTM1M3::hardpointMonitorData_8caedbd0DataReader_var SALReader = MTM1M3::hardpointMonitorData_8caedbd0DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::hardpointMonitorData_8caedbd0DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::hardpointMonitorData_8caedbd0DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::hardpointMonitorData_8caedbd0DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_hardpointMonitorData(MTM1M3_hardpointMonitorDataC *data)
{
  int actorIdx = SAL__MTM1M3_hardpointMonitorData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_hardpointMonitorData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_hardpointMonitorData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::hardpointMonitorData_8caedbd0DataWriter_var SALWriter = MTM1M3::hardpointMonitorData_8caedbd0DataWriter::_narrow(dwriter.in());
  MTM1M3::hardpointMonitorData_8caedbd0 Instance;

  Instance.private_revCode = DDS::string_dup("8caedbd0");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<6;iseq++) {Instance.breakawayLVDT[iseq] = data->breakawayLVDT[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.displacementLVDT[iseq] = data->displacementLVDT[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.breakawayPressure[iseq] = data->breakawayPressure[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.pressureSensor1[iseq] = data->pressureSensor1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.pressureSensor2[iseq] = data->pressureSensor2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.pressureSensor3[iseq] = data->pressureSensor3[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::hardpointMonitorData_8caedbd0 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::hardpointMonitorData_8caedbd0DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_hardpointMonitorData(MTM1M3_hardpointMonitorDataC *data)
{
  MTM1M3::hardpointMonitorData_8caedbd0Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_hardpointMonitorData");
  }
  int actorIdx = SAL__MTM1M3_hardpointMonitorData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_hardpointMonitorData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::hardpointMonitorData_8caedbd0DataReader_var SALReader = MTM1M3::hardpointMonitorData_8caedbd0DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::hardpointMonitorData_8caedbd0DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_hardpointMonitorData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::hardpointMonitorData_8caedbd0DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_hardpointMonitorData.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->breakawayLVDT[iseq] = Instances[j].breakawayLVDT[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointMonitorData.breakawayLVDT[iseq] = Instances[j].breakawayLVDT[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->displacementLVDT[iseq] = Instances[j].displacementLVDT[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointMonitorData.displacementLVDT[iseq] = Instances[j].displacementLVDT[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->breakawayPressure[iseq] = Instances[j].breakawayPressure[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointMonitorData.breakawayPressure[iseq] = Instances[j].breakawayPressure[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->pressureSensor1[iseq] = Instances[j].pressureSensor1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointMonitorData.pressureSensor1[iseq] = Instances[j].pressureSensor1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->pressureSensor2[iseq] = Instances[j].pressureSensor2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointMonitorData.pressureSensor2[iseq] = Instances[j].pressureSensor2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->pressureSensor3[iseq] = Instances[j].pressureSensor3[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_hardpointMonitorData.pressureSensor3[iseq] = Instances[j].pressureSensor3[iseq];}
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::hardpointMonitorData_8caedbd0DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_hardpointMonitorData(MTM1M3_hardpointMonitorDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_hardpointMonitorData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_hardpointMonitorData_ACTOR].maxSamples = 1;
    istatus = getSample_hardpointMonitorData(data);
    sal[SAL__MTM1M3_hardpointMonitorData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_hardpointMonitorData(MTM1M3_hardpointMonitorDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_hardpointMonitorData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_hardpointMonitorData.timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->breakawayLVDT[iseq] = lastSample_MTM1M3_hardpointMonitorData.breakawayLVDT[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->displacementLVDT[iseq] = lastSample_MTM1M3_hardpointMonitorData.displacementLVDT[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->breakawayPressure[iseq] = lastSample_MTM1M3_hardpointMonitorData.breakawayPressure[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->pressureSensor1[iseq] = lastSample_MTM1M3_hardpointMonitorData.pressureSensor1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->pressureSensor2[iseq] = lastSample_MTM1M3_hardpointMonitorData.pressureSensor2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->pressureSensor3[iseq] = lastSample_MTM1M3_hardpointMonitorData.pressureSensor3[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_hardpointMonitorData(MTM1M3_hardpointMonitorDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_hardpointMonitorData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_hardpointMonitorData_ACTOR].sampleAge = -1.0;
    istatus = getSample_hardpointMonitorData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_hardpointMonitorData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::imsData_dd412900 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_imsData");
  }
  MTM1M3::imsData_dd412900DataWriter_var SALWriter = MTM1M3::imsData_dd412900DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("dd412900");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::imsData_dd412900 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::imsData_dd412900DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::imsData_dd412900Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_imsData");
  }
  MTM1M3::imsData_dd412900DataReader_var SALReader = MTM1M3::imsData_dd412900DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::imsData_dd412900DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::imsData_dd412900DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::imsData_dd412900DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_imsData(MTM1M3_imsDataC *data)
{
  int actorIdx = SAL__MTM1M3_imsData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_imsData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_imsData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::imsData_dd412900DataWriter_var SALWriter = MTM1M3::imsData_dd412900DataWriter::_narrow(dwriter.in());
  MTM1M3::imsData_dd412900 Instance;

  Instance.private_revCode = DDS::string_dup("dd412900");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<8;iseq++) {Instance.rawSensorData[iseq] = data->rawSensorData[iseq];}
    Instance.xPosition = data->xPosition;
    Instance.yPosition = data->yPosition;
    Instance.zPosition = data->zPosition;
    Instance.xRotation = data->xRotation;
    Instance.yRotation = data->yRotation;
    Instance.zRotation = data->zRotation;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::imsData_dd412900 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::imsData_dd412900DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_imsData(MTM1M3_imsDataC *data)
{
  MTM1M3::imsData_dd412900Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_imsData");
  }
  int actorIdx = SAL__MTM1M3_imsData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_imsData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::imsData_dd412900DataReader_var SALReader = MTM1M3::imsData_dd412900DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::imsData_dd412900DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_imsData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::imsData_dd412900DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_imsData.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<8;iseq++) {data->rawSensorData[iseq] = Instances[j].rawSensorData[iseq];}
    for (int iseq=0;iseq<8;iseq++) {lastSample_MTM1M3_imsData.rawSensorData[iseq] = Instances[j].rawSensorData[iseq];}
    data->xPosition = Instances[j].xPosition;
    lastSample_MTM1M3_imsData.xPosition = Instances[j].xPosition;
    data->yPosition = Instances[j].yPosition;
    lastSample_MTM1M3_imsData.yPosition = Instances[j].yPosition;
    data->zPosition = Instances[j].zPosition;
    lastSample_MTM1M3_imsData.zPosition = Instances[j].zPosition;
    data->xRotation = Instances[j].xRotation;
    lastSample_MTM1M3_imsData.xRotation = Instances[j].xRotation;
    data->yRotation = Instances[j].yRotation;
    lastSample_MTM1M3_imsData.yRotation = Instances[j].yRotation;
    data->zRotation = Instances[j].zRotation;
    lastSample_MTM1M3_imsData.zRotation = Instances[j].zRotation;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::imsData_dd412900DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_imsData(MTM1M3_imsDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_imsData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_imsData_ACTOR].maxSamples = 1;
    istatus = getSample_imsData(data);
    sal[SAL__MTM1M3_imsData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_imsData(MTM1M3_imsDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_imsData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_imsData.timestamp;
    for (int iseq=0;iseq<8;iseq++) {data->rawSensorData[iseq] = lastSample_MTM1M3_imsData.rawSensorData[iseq];}
   data->xPosition = lastSample_MTM1M3_imsData.xPosition;
   data->yPosition = lastSample_MTM1M3_imsData.yPosition;
   data->zPosition = lastSample_MTM1M3_imsData.zPosition;
   data->xRotation = lastSample_MTM1M3_imsData.xRotation;
   data->yRotation = lastSample_MTM1M3_imsData.yRotation;
   data->zRotation = lastSample_MTM1M3_imsData.zRotation;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_imsData(MTM1M3_imsDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_imsData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_imsData_ACTOR].sampleAge = -1.0;
    istatus = getSample_imsData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_imsData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::inclinometerData_6233a3d3 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_inclinometerData");
  }
  MTM1M3::inclinometerData_6233a3d3DataWriter_var SALWriter = MTM1M3::inclinometerData_6233a3d3DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("6233a3d3");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::inclinometerData_6233a3d3 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::inclinometerData_6233a3d3DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::inclinometerData_6233a3d3Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_inclinometerData");
  }
  MTM1M3::inclinometerData_6233a3d3DataReader_var SALReader = MTM1M3::inclinometerData_6233a3d3DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::inclinometerData_6233a3d3DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::inclinometerData_6233a3d3DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::inclinometerData_6233a3d3DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_inclinometerData(MTM1M3_inclinometerDataC *data)
{
  int actorIdx = SAL__MTM1M3_inclinometerData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_inclinometerData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_inclinometerData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::inclinometerData_6233a3d3DataWriter_var SALWriter = MTM1M3::inclinometerData_6233a3d3DataWriter::_narrow(dwriter.in());
  MTM1M3::inclinometerData_6233a3d3 Instance;

  Instance.private_revCode = DDS::string_dup("6233a3d3");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.inclinometerAngle = data->inclinometerAngle;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::inclinometerData_6233a3d3 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::inclinometerData_6233a3d3DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_inclinometerData(MTM1M3_inclinometerDataC *data)
{
  MTM1M3::inclinometerData_6233a3d3Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_inclinometerData");
  }
  int actorIdx = SAL__MTM1M3_inclinometerData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_inclinometerData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::inclinometerData_6233a3d3DataReader_var SALReader = MTM1M3::inclinometerData_6233a3d3DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::inclinometerData_6233a3d3DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_inclinometerData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::inclinometerData_6233a3d3DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_inclinometerData.timestamp = Instances[j].timestamp;
    data->inclinometerAngle = Instances[j].inclinometerAngle;
    lastSample_MTM1M3_inclinometerData.inclinometerAngle = Instances[j].inclinometerAngle;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::inclinometerData_6233a3d3DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_inclinometerData(MTM1M3_inclinometerDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_inclinometerData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_inclinometerData_ACTOR].maxSamples = 1;
    istatus = getSample_inclinometerData(data);
    sal[SAL__MTM1M3_inclinometerData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_inclinometerData(MTM1M3_inclinometerDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_inclinometerData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_inclinometerData.timestamp;
   data->inclinometerAngle = lastSample_MTM1M3_inclinometerData.inclinometerAngle;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_inclinometerData(MTM1M3_inclinometerDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_inclinometerData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_inclinometerData_ACTOR].sampleAge = -1.0;
    istatus = getSample_inclinometerData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_inclinometerData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_accelerometerWarning_aa15b0aa data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_accelerometerWarning");
  }
  MTM1M3::logevent_accelerometerWarning_aa15b0aaDataWriter_var SALWriter = MTM1M3::logevent_accelerometerWarning_aa15b0aaDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("aa15b0aa");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_accelerometerWarning_aa15b0aa writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_accelerometerWarning_aa15b0aaDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_accelerometerWarning_aa15b0aaSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_accelerometerWarning");
  }
  MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader_var SALReader = MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_accelerometerWarning(MTM1M3_logevent_accelerometerWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_accelerometerWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_accelerometerWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_accelerometerWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_accelerometerWarning_aa15b0aaDataWriter_var SALWriter = MTM1M3::logevent_accelerometerWarning_aa15b0aaDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_accelerometerWarning_aa15b0aa Instance;

  Instance.private_revCode = DDS::string_dup("aa15b0aa");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.responseTimeout = data->responseTimeout;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_accelerometerWarning_aa15b0aa writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_accelerometerWarning_aa15b0aaDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_accelerometerWarning(MTM1M3_logevent_accelerometerWarningC *data)
{
  MTM1M3::logevent_accelerometerWarning_aa15b0aaSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_accelerometerWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_accelerometerWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_accelerometerWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader_var SALReader = MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_accelerometerWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_accelerometerWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_accelerometerWarning.anyWarning = Instances[j].anyWarning;
    data->responseTimeout = Instances[j].responseTimeout;
    lastSample_MTM1M3_logevent_accelerometerWarning.responseTimeout = Instances[j].responseTimeout;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_accelerometerWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_accelerometerWarning_aa15b0aaDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_accelerometerWarning(MTM1M3_logevent_accelerometerWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_accelerometerWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_accelerometerWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_accelerometerWarning(data);
    sal[SAL__MTM1M3_logevent_accelerometerWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_accelerometerWarning(MTM1M3_logevent_accelerometerWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_accelerometerWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_accelerometerWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_accelerometerWarning.anyWarning;
   data->responseTimeout = lastSample_MTM1M3_logevent_accelerometerWarning.responseTimeout;
   data->priority = lastSample_MTM1M3_logevent_accelerometerWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_accelerometerWarning(MTM1M3_logevent_accelerometerWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_accelerometerWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_accelerometerWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_accelerometerWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_accelerometerWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_airSupplyStatus_da397eb1 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_airSupplyStatus");
  }
  MTM1M3::logevent_airSupplyStatus_da397eb1DataWriter_var SALWriter = MTM1M3::logevent_airSupplyStatus_da397eb1DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("da397eb1");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_airSupplyStatus_da397eb1 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_airSupplyStatus_da397eb1DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_airSupplyStatus_da397eb1Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_airSupplyStatus");
  }
  MTM1M3::logevent_airSupplyStatus_da397eb1DataReader_var SALReader = MTM1M3::logevent_airSupplyStatus_da397eb1DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_airSupplyStatus_da397eb1DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_airSupplyStatus_da397eb1DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_airSupplyStatus_da397eb1DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_airSupplyStatus(MTM1M3_logevent_airSupplyStatusC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_airSupplyStatus_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_airSupplyStatus");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_airSupplyStatus");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_airSupplyStatus_da397eb1DataWriter_var SALWriter = MTM1M3::logevent_airSupplyStatus_da397eb1DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_airSupplyStatus_da397eb1 Instance;

  Instance.private_revCode = DDS::string_dup("da397eb1");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.airCommandedOn = data->airCommandedOn;
    Instance.airCommandOutputOn = data->airCommandOutputOn;
    Instance.airValveOpened = data->airValveOpened;
    Instance.airValveClosed = data->airValveClosed;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_airSupplyStatus_da397eb1 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_airSupplyStatus_da397eb1DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_airSupplyStatus(MTM1M3_logevent_airSupplyStatusC *data)
{
  MTM1M3::logevent_airSupplyStatus_da397eb1Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_airSupplyStatus");
  }
  int actorIdx = SAL__MTM1M3_logevent_airSupplyStatus_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_airSupplyStatus");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_airSupplyStatus_da397eb1DataReader_var SALReader = MTM1M3::logevent_airSupplyStatus_da397eb1DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_airSupplyStatus_da397eb1DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_airSupplyStatus_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_airSupplyStatus_da397eb1DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_airSupplyStatus.timestamp = Instances[j].timestamp;
    data->airCommandedOn = Instances[j].airCommandedOn;
    lastSample_MTM1M3_logevent_airSupplyStatus.airCommandedOn = Instances[j].airCommandedOn;
    data->airCommandOutputOn = Instances[j].airCommandOutputOn;
    lastSample_MTM1M3_logevent_airSupplyStatus.airCommandOutputOn = Instances[j].airCommandOutputOn;
    data->airValveOpened = Instances[j].airValveOpened;
    lastSample_MTM1M3_logevent_airSupplyStatus.airValveOpened = Instances[j].airValveOpened;
    data->airValveClosed = Instances[j].airValveClosed;
    lastSample_MTM1M3_logevent_airSupplyStatus.airValveClosed = Instances[j].airValveClosed;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_airSupplyStatus.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_airSupplyStatus_da397eb1DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_airSupplyStatus(MTM1M3_logevent_airSupplyStatusC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_airSupplyStatus_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_airSupplyStatus_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_airSupplyStatus(data);
    sal[SAL__MTM1M3_logevent_airSupplyStatus_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_airSupplyStatus(MTM1M3_logevent_airSupplyStatusC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_airSupplyStatus(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_airSupplyStatus.timestamp;
   data->airCommandedOn = lastSample_MTM1M3_logevent_airSupplyStatus.airCommandedOn;
   data->airCommandOutputOn = lastSample_MTM1M3_logevent_airSupplyStatus.airCommandOutputOn;
   data->airValveOpened = lastSample_MTM1M3_logevent_airSupplyStatus.airValveOpened;
   data->airValveClosed = lastSample_MTM1M3_logevent_airSupplyStatus.airValveClosed;
   data->priority = lastSample_MTM1M3_logevent_airSupplyStatus.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_airSupplyStatus(MTM1M3_logevent_airSupplyStatusC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_airSupplyStatus_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_airSupplyStatus_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_airSupplyStatus(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_airSupplyStatus_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_airSupplyWarning_52167fbe data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_airSupplyWarning");
  }
  MTM1M3::logevent_airSupplyWarning_52167fbeDataWriter_var SALWriter = MTM1M3::logevent_airSupplyWarning_52167fbeDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("52167fbe");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_airSupplyWarning_52167fbe writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_airSupplyWarning_52167fbeDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_airSupplyWarning_52167fbeSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_airSupplyWarning");
  }
  MTM1M3::logevent_airSupplyWarning_52167fbeDataReader_var SALReader = MTM1M3::logevent_airSupplyWarning_52167fbeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_airSupplyWarning_52167fbeDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_airSupplyWarning_52167fbeDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_airSupplyWarning_52167fbeDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_airSupplyWarning(MTM1M3_logevent_airSupplyWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_airSupplyWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_airSupplyWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_airSupplyWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_airSupplyWarning_52167fbeDataWriter_var SALWriter = MTM1M3::logevent_airSupplyWarning_52167fbeDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_airSupplyWarning_52167fbe Instance;

  Instance.private_revCode = DDS::string_dup("52167fbe");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.commandOutputMismatch = data->commandOutputMismatch;
    Instance.commandSensorMismatch = data->commandSensorMismatch;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_airSupplyWarning_52167fbe writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_airSupplyWarning_52167fbeDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_airSupplyWarning(MTM1M3_logevent_airSupplyWarningC *data)
{
  MTM1M3::logevent_airSupplyWarning_52167fbeSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_airSupplyWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_airSupplyWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_airSupplyWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_airSupplyWarning_52167fbeDataReader_var SALReader = MTM1M3::logevent_airSupplyWarning_52167fbeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_airSupplyWarning_52167fbeDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_airSupplyWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_airSupplyWarning_52167fbeDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_airSupplyWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_airSupplyWarning.anyWarning = Instances[j].anyWarning;
    data->commandOutputMismatch = Instances[j].commandOutputMismatch;
    lastSample_MTM1M3_logevent_airSupplyWarning.commandOutputMismatch = Instances[j].commandOutputMismatch;
    data->commandSensorMismatch = Instances[j].commandSensorMismatch;
    lastSample_MTM1M3_logevent_airSupplyWarning.commandSensorMismatch = Instances[j].commandSensorMismatch;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_airSupplyWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_airSupplyWarning_52167fbeDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_airSupplyWarning(MTM1M3_logevent_airSupplyWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_airSupplyWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_airSupplyWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_airSupplyWarning(data);
    sal[SAL__MTM1M3_logevent_airSupplyWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_airSupplyWarning(MTM1M3_logevent_airSupplyWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_airSupplyWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_airSupplyWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_airSupplyWarning.anyWarning;
   data->commandOutputMismatch = lastSample_MTM1M3_logevent_airSupplyWarning.commandOutputMismatch;
   data->commandSensorMismatch = lastSample_MTM1M3_logevent_airSupplyWarning.commandSensorMismatch;
   data->priority = lastSample_MTM1M3_logevent_airSupplyWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_airSupplyWarning(MTM1M3_logevent_airSupplyWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_airSupplyWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_airSupplyWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_airSupplyWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_airSupplyWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedAberrationForces_d72ce7af data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedAberrationForces");
  }
  MTM1M3::logevent_appliedAberrationForces_d72ce7afDataWriter_var SALWriter = MTM1M3::logevent_appliedAberrationForces_d72ce7afDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("d72ce7af");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedAberrationForces_d72ce7af writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedAberrationForces_d72ce7afDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedAberrationForces_d72ce7afSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedAberrationForces");
  }
  MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader_var SALReader = MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedAberrationForces(MTM1M3_logevent_appliedAberrationForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedAberrationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedAberrationForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedAberrationForces_d72ce7afDataWriter_var SALWriter = MTM1M3::logevent_appliedAberrationForces_d72ce7afDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedAberrationForces_d72ce7af Instance;

  Instance.private_revCode = DDS::string_dup("d72ce7af");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedAberrationForces_d72ce7af writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedAberrationForces_d72ce7afDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedAberrationForces(MTM1M3_logevent_appliedAberrationForcesC *data)
{
  MTM1M3::logevent_appliedAberrationForces_d72ce7afSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedAberrationForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedAberrationForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader_var SALReader = MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedAberrationForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedAberrationForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedAberrationForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedAberrationForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedAberrationForces.my = Instances[j].my;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedAberrationForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedAberrationForces_d72ce7afDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedAberrationForces(MTM1M3_logevent_appliedAberrationForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedAberrationForces(data);
    sal[SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedAberrationForces(MTM1M3_logevent_appliedAberrationForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedAberrationForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedAberrationForces.timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedAberrationForces.zForces[iseq];}
   data->fz = lastSample_MTM1M3_logevent_appliedAberrationForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedAberrationForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedAberrationForces.my;
   data->priority = lastSample_MTM1M3_logevent_appliedAberrationForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedAberrationForces(MTM1M3_logevent_appliedAberrationForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedAberrationForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedAccelerationForces_e2698a2b data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedAccelerationForces");
  }
  MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataWriter_var SALWriter = MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("e2698a2b");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedAccelerationForces_e2698a2b writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedAccelerationForces_e2698a2bSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedAccelerationForces");
  }
  MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader_var SALReader = MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedAccelerationForces(MTM1M3_logevent_appliedAccelerationForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedAccelerationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedAccelerationForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataWriter_var SALWriter = MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedAccelerationForces_e2698a2b Instance;

  Instance.private_revCode = DDS::string_dup("e2698a2b");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedAccelerationForces_e2698a2b writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedAccelerationForces(MTM1M3_logevent_appliedAccelerationForcesC *data)
{
  MTM1M3::logevent_appliedAccelerationForces_e2698a2bSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedAccelerationForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedAccelerationForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader_var SALReader = MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedAccelerationForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedAccelerationForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedAccelerationForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedAccelerationForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedAccelerationForces_e2698a2bDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedAccelerationForces(MTM1M3_logevent_appliedAccelerationForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedAccelerationForces(data);
    sal[SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedAccelerationForces(MTM1M3_logevent_appliedAccelerationForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedAccelerationForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedAccelerationForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedAccelerationForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedAccelerationForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedAccelerationForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedAccelerationForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedAccelerationForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedAccelerationForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedAccelerationForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedAccelerationForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedAccelerationForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedAccelerationForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedAccelerationForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedAccelerationForces(MTM1M3_logevent_appliedAccelerationForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedAccelerationForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedActiveOpticForces_4f827b4b data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedActiveOpticForces");
  }
  MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataWriter_var SALWriter = MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("4f827b4b");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedActiveOpticForces_4f827b4b writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedActiveOpticForces_4f827b4bSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedActiveOpticForces");
  }
  MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader_var SALReader = MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedActiveOpticForces(MTM1M3_logevent_appliedActiveOpticForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedActiveOpticForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedActiveOpticForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataWriter_var SALWriter = MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedActiveOpticForces_4f827b4b Instance;

  Instance.private_revCode = DDS::string_dup("4f827b4b");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedActiveOpticForces_4f827b4b writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedActiveOpticForces(MTM1M3_logevent_appliedActiveOpticForcesC *data)
{
  MTM1M3::logevent_appliedActiveOpticForces_4f827b4bSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedActiveOpticForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedActiveOpticForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader_var SALReader = MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedActiveOpticForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedActiveOpticForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedActiveOpticForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedActiveOpticForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedActiveOpticForces.my = Instances[j].my;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedActiveOpticForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedActiveOpticForces_4f827b4bDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedActiveOpticForces(MTM1M3_logevent_appliedActiveOpticForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedActiveOpticForces(data);
    sal[SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedActiveOpticForces(MTM1M3_logevent_appliedActiveOpticForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedActiveOpticForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedActiveOpticForces.timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedActiveOpticForces.zForces[iseq];}
   data->fz = lastSample_MTM1M3_logevent_appliedActiveOpticForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedActiveOpticForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedActiveOpticForces.my;
   data->priority = lastSample_MTM1M3_logevent_appliedActiveOpticForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedActiveOpticForces(MTM1M3_logevent_appliedActiveOpticForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedActiveOpticForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedAzimuthForces_7357e272 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedAzimuthForces");
  }
  MTM1M3::logevent_appliedAzimuthForces_7357e272DataWriter_var SALWriter = MTM1M3::logevent_appliedAzimuthForces_7357e272DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("7357e272");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedAzimuthForces_7357e272 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedAzimuthForces_7357e272DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedAzimuthForces_7357e272Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedAzimuthForces");
  }
  MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader_var SALReader = MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedAzimuthForces(MTM1M3_logevent_appliedAzimuthForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedAzimuthForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedAzimuthForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedAzimuthForces_7357e272DataWriter_var SALWriter = MTM1M3::logevent_appliedAzimuthForces_7357e272DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedAzimuthForces_7357e272 Instance;

  Instance.private_revCode = DDS::string_dup("7357e272");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedAzimuthForces_7357e272 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedAzimuthForces_7357e272DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedAzimuthForces(MTM1M3_logevent_appliedAzimuthForcesC *data)
{
  MTM1M3::logevent_appliedAzimuthForces_7357e272Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedAzimuthForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedAzimuthForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader_var SALReader = MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedAzimuthForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedAzimuthForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedAzimuthForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedAzimuthForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedAzimuthForces_7357e272DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedAzimuthForces(MTM1M3_logevent_appliedAzimuthForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedAzimuthForces(data);
    sal[SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedAzimuthForces(MTM1M3_logevent_appliedAzimuthForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedAzimuthForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedAzimuthForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedAzimuthForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedAzimuthForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedAzimuthForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedAzimuthForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedAzimuthForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedAzimuthForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedAzimuthForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedAzimuthForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedAzimuthForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedAzimuthForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedAzimuthForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedAzimuthForces(MTM1M3_logevent_appliedAzimuthForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedAzimuthForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedBalanceForces_3f4cca0a data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedBalanceForces");
  }
  MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataWriter_var SALWriter = MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("3f4cca0a");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedBalanceForces_3f4cca0a writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedBalanceForces_3f4cca0aSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedBalanceForces");
  }
  MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader_var SALReader = MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedBalanceForces(MTM1M3_logevent_appliedBalanceForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedBalanceForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedBalanceForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataWriter_var SALWriter = MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedBalanceForces_3f4cca0a Instance;

  Instance.private_revCode = DDS::string_dup("3f4cca0a");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedBalanceForces_3f4cca0a writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedBalanceForces(MTM1M3_logevent_appliedBalanceForcesC *data)
{
  MTM1M3::logevent_appliedBalanceForces_3f4cca0aSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedBalanceForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedBalanceForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader_var SALReader = MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedBalanceForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedBalanceForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedBalanceForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedBalanceForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedBalanceForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedBalanceForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedBalanceForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedBalanceForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedBalanceForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedBalanceForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedBalanceForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedBalanceForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedBalanceForces_3f4cca0aDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedBalanceForces(MTM1M3_logevent_appliedBalanceForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedBalanceForces(data);
    sal[SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedBalanceForces(MTM1M3_logevent_appliedBalanceForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedBalanceForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedBalanceForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedBalanceForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedBalanceForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedBalanceForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedBalanceForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedBalanceForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedBalanceForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedBalanceForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedBalanceForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedBalanceForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedBalanceForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedBalanceForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedBalanceForces(MTM1M3_logevent_appliedBalanceForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedBalanceForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedCylinderForces_b0d7e6d8 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedCylinderForces");
  }
  MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataWriter_var SALWriter = MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("b0d7e6d8");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedCylinderForces_b0d7e6d8 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedCylinderForces_b0d7e6d8Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedCylinderForces");
  }
  MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader_var SALReader = MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedCylinderForces(MTM1M3_logevent_appliedCylinderForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedCylinderForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedCylinderForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataWriter_var SALWriter = MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedCylinderForces_b0d7e6d8 Instance;

  Instance.private_revCode = DDS::string_dup("b0d7e6d8");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<112;iseq++) {Instance.secondaryCylinderForces[iseq] = data->secondaryCylinderForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.primaryCylinderForces[iseq] = data->primaryCylinderForces[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedCylinderForces_b0d7e6d8 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedCylinderForces(MTM1M3_logevent_appliedCylinderForcesC *data)
{
  MTM1M3::logevent_appliedCylinderForces_b0d7e6d8Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedCylinderForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedCylinderForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader_var SALReader = MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedCylinderForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<112;iseq++) {data->secondaryCylinderForces[iseq] = Instances[j].secondaryCylinderForces[iseq];}
    for (int iseq=0;iseq<112;iseq++) {lastSample_MTM1M3_logevent_appliedCylinderForces.secondaryCylinderForces[iseq] = Instances[j].secondaryCylinderForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->primaryCylinderForces[iseq] = Instances[j].primaryCylinderForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedCylinderForces.primaryCylinderForces[iseq] = Instances[j].primaryCylinderForces[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedCylinderForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedCylinderForces_b0d7e6d8DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedCylinderForces(MTM1M3_logevent_appliedCylinderForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedCylinderForces(data);
    sal[SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedCylinderForces(MTM1M3_logevent_appliedCylinderForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedCylinderForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedCylinderForces.timestamp;
    for (int iseq=0;iseq<112;iseq++) {data->secondaryCylinderForces[iseq] = lastSample_MTM1M3_logevent_appliedCylinderForces.secondaryCylinderForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->primaryCylinderForces[iseq] = lastSample_MTM1M3_logevent_appliedCylinderForces.primaryCylinderForces[iseq];}
   data->priority = lastSample_MTM1M3_logevent_appliedCylinderForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedCylinderForces(MTM1M3_logevent_appliedCylinderForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedCylinderForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedElevationForces_fa715255 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedElevationForces");
  }
  MTM1M3::logevent_appliedElevationForces_fa715255DataWriter_var SALWriter = MTM1M3::logevent_appliedElevationForces_fa715255DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("fa715255");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedElevationForces_fa715255 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedElevationForces_fa715255DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedElevationForces_fa715255Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedElevationForces");
  }
  MTM1M3::logevent_appliedElevationForces_fa715255DataReader_var SALReader = MTM1M3::logevent_appliedElevationForces_fa715255DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedElevationForces_fa715255DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedElevationForces_fa715255DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedElevationForces_fa715255DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedElevationForces(MTM1M3_logevent_appliedElevationForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedElevationForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedElevationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedElevationForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedElevationForces_fa715255DataWriter_var SALWriter = MTM1M3::logevent_appliedElevationForces_fa715255DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedElevationForces_fa715255 Instance;

  Instance.private_revCode = DDS::string_dup("fa715255");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedElevationForces_fa715255 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedElevationForces_fa715255DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedElevationForces(MTM1M3_logevent_appliedElevationForcesC *data)
{
  MTM1M3::logevent_appliedElevationForces_fa715255Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedElevationForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedElevationForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedElevationForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedElevationForces_fa715255DataReader_var SALReader = MTM1M3::logevent_appliedElevationForces_fa715255DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedElevationForces_fa715255DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedElevationForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedElevationForces_fa715255DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedElevationForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedElevationForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedElevationForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedElevationForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedElevationForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedElevationForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedElevationForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedElevationForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedElevationForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedElevationForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedElevationForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedElevationForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedElevationForces_fa715255DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedElevationForces(MTM1M3_logevent_appliedElevationForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedElevationForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedElevationForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedElevationForces(data);
    sal[SAL__MTM1M3_logevent_appliedElevationForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedElevationForces(MTM1M3_logevent_appliedElevationForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedElevationForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedElevationForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedElevationForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedElevationForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedElevationForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedElevationForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedElevationForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedElevationForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedElevationForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedElevationForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedElevationForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedElevationForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedElevationForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedElevationForces(MTM1M3_logevent_appliedElevationForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedElevationForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedElevationForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedElevationForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedElevationForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedForces_1d16999d data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedForces");
  }
  MTM1M3::logevent_appliedForces_1d16999dDataWriter_var SALWriter = MTM1M3::logevent_appliedForces_1d16999dDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("1d16999d");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedForces_1d16999d writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedForces_1d16999dDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedForces_1d16999dSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedForces");
  }
  MTM1M3::logevent_appliedForces_1d16999dDataReader_var SALReader = MTM1M3::logevent_appliedForces_1d16999dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedForces_1d16999dDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedForces_1d16999dDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedForces_1d16999dDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedForces(MTM1M3_logevent_appliedForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedForces_1d16999dDataWriter_var SALWriter = MTM1M3::logevent_appliedForces_1d16999dDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedForces_1d16999d Instance;

  Instance.private_revCode = DDS::string_dup("1d16999d");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedForces_1d16999d writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedForces_1d16999dDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedForces(MTM1M3_logevent_appliedForcesC *data)
{
  MTM1M3::logevent_appliedForces_1d16999dSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedForces_1d16999dDataReader_var SALReader = MTM1M3::logevent_appliedForces_1d16999dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedForces_1d16999dDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedForces_1d16999dDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedForces_1d16999dDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedForces(MTM1M3_logevent_appliedForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedForces(data);
    sal[SAL__MTM1M3_logevent_appliedForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedForces(MTM1M3_logevent_appliedForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedForces(MTM1M3_logevent_appliedForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedOffsetForces_f19befd6 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedOffsetForces");
  }
  MTM1M3::logevent_appliedOffsetForces_f19befd6DataWriter_var SALWriter = MTM1M3::logevent_appliedOffsetForces_f19befd6DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("f19befd6");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedOffsetForces_f19befd6 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedOffsetForces_f19befd6DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedOffsetForces_f19befd6Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedOffsetForces");
  }
  MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader_var SALReader = MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedOffsetForces(MTM1M3_logevent_appliedOffsetForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedOffsetForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedOffsetForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedOffsetForces_f19befd6DataWriter_var SALWriter = MTM1M3::logevent_appliedOffsetForces_f19befd6DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedOffsetForces_f19befd6 Instance;

  Instance.private_revCode = DDS::string_dup("f19befd6");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedOffsetForces_f19befd6 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedOffsetForces_f19befd6DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedOffsetForces(MTM1M3_logevent_appliedOffsetForcesC *data)
{
  MTM1M3::logevent_appliedOffsetForces_f19befd6Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedOffsetForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedOffsetForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader_var SALReader = MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedOffsetForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedOffsetForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedOffsetForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedOffsetForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedOffsetForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedOffsetForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedOffsetForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedOffsetForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedOffsetForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedOffsetForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedOffsetForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedOffsetForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedOffsetForces_f19befd6DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedOffsetForces(MTM1M3_logevent_appliedOffsetForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedOffsetForces(data);
    sal[SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedOffsetForces(MTM1M3_logevent_appliedOffsetForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedOffsetForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedOffsetForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedOffsetForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedOffsetForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedOffsetForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedOffsetForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedOffsetForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedOffsetForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedOffsetForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedOffsetForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedOffsetForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedOffsetForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedOffsetForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedOffsetForces(MTM1M3_logevent_appliedOffsetForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedOffsetForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedSettingsMatchStart");
  }
  MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataWriter_var SALWriter = MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("30ba5c59");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedSettingsMatchStart");
  }
  MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader_var SALReader = MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedSettingsMatchStart(MTM1M3_logevent_appliedSettingsMatchStartC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedSettingsMatchStart");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedSettingsMatchStart");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataWriter_var SALWriter = MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59 Instance;

  Instance.private_revCode = DDS::string_dup("30ba5c59");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.appliedSettingsMatchStartIsTrue = data->appliedSettingsMatchStartIsTrue;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedSettingsMatchStart(MTM1M3_logevent_appliedSettingsMatchStartC *data)
{
  MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedSettingsMatchStart");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedSettingsMatchStart");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader_var SALReader = MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->appliedSettingsMatchStartIsTrue = Instances[j].appliedSettingsMatchStartIsTrue;
    lastSample_MTM1M3_logevent_appliedSettingsMatchStart.appliedSettingsMatchStartIsTrue = Instances[j].appliedSettingsMatchStartIsTrue;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedSettingsMatchStart.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedSettingsMatchStart_30ba5c59DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedSettingsMatchStart(MTM1M3_logevent_appliedSettingsMatchStartC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedSettingsMatchStart(data);
    sal[SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedSettingsMatchStart(MTM1M3_logevent_appliedSettingsMatchStartC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedSettingsMatchStart(data);
    if (istatus == SAL__NO_UPDATES) {
   data->appliedSettingsMatchStartIsTrue = lastSample_MTM1M3_logevent_appliedSettingsMatchStart.appliedSettingsMatchStartIsTrue;
   data->priority = lastSample_MTM1M3_logevent_appliedSettingsMatchStart.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedSettingsMatchStart(MTM1M3_logevent_appliedSettingsMatchStartC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedSettingsMatchStart(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedStaticForces_b210fd2d data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedStaticForces");
  }
  MTM1M3::logevent_appliedStaticForces_b210fd2dDataWriter_var SALWriter = MTM1M3::logevent_appliedStaticForces_b210fd2dDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("b210fd2d");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedStaticForces_b210fd2d writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedStaticForces_b210fd2dDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedStaticForces_b210fd2dSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedStaticForces");
  }
  MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader_var SALReader = MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedStaticForces(MTM1M3_logevent_appliedStaticForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedStaticForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedStaticForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedStaticForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedStaticForces_b210fd2dDataWriter_var SALWriter = MTM1M3::logevent_appliedStaticForces_b210fd2dDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedStaticForces_b210fd2d Instance;

  Instance.private_revCode = DDS::string_dup("b210fd2d");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedStaticForces_b210fd2d writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedStaticForces_b210fd2dDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedStaticForces(MTM1M3_logevent_appliedStaticForcesC *data)
{
  MTM1M3::logevent_appliedStaticForces_b210fd2dSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedStaticForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedStaticForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedStaticForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader_var SALReader = MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedStaticForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedStaticForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedStaticForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedStaticForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedStaticForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedStaticForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedStaticForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedStaticForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedStaticForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedStaticForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedStaticForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedStaticForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedStaticForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedStaticForces_b210fd2dDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedStaticForces(MTM1M3_logevent_appliedStaticForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedStaticForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedStaticForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedStaticForces(data);
    sal[SAL__MTM1M3_logevent_appliedStaticForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedStaticForces(MTM1M3_logevent_appliedStaticForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedStaticForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedStaticForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedStaticForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedStaticForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedStaticForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedStaticForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedStaticForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedStaticForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedStaticForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedStaticForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedStaticForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedStaticForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedStaticForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedStaticForces(MTM1M3_logevent_appliedStaticForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedStaticForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedStaticForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedStaticForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedStaticForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedThermalForces_ee191da4 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedThermalForces");
  }
  MTM1M3::logevent_appliedThermalForces_ee191da4DataWriter_var SALWriter = MTM1M3::logevent_appliedThermalForces_ee191da4DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("ee191da4");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedThermalForces_ee191da4 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedThermalForces_ee191da4DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedThermalForces_ee191da4Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedThermalForces");
  }
  MTM1M3::logevent_appliedThermalForces_ee191da4DataReader_var SALReader = MTM1M3::logevent_appliedThermalForces_ee191da4DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedThermalForces_ee191da4DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedThermalForces_ee191da4DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedThermalForces_ee191da4DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedThermalForces(MTM1M3_logevent_appliedThermalForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedThermalForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedThermalForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedThermalForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedThermalForces_ee191da4DataWriter_var SALWriter = MTM1M3::logevent_appliedThermalForces_ee191da4DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedThermalForces_ee191da4 Instance;

  Instance.private_revCode = DDS::string_dup("ee191da4");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedThermalForces_ee191da4 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedThermalForces_ee191da4DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedThermalForces(MTM1M3_logevent_appliedThermalForcesC *data)
{
  MTM1M3::logevent_appliedThermalForces_ee191da4Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedThermalForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedThermalForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedThermalForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedThermalForces_ee191da4DataReader_var SALReader = MTM1M3::logevent_appliedThermalForces_ee191da4DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedThermalForces_ee191da4DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedThermalForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedThermalForces_ee191da4DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedThermalForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedThermalForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedThermalForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedThermalForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedThermalForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedThermalForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedThermalForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedThermalForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedThermalForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedThermalForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedThermalForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedThermalForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedThermalForces_ee191da4DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedThermalForces(MTM1M3_logevent_appliedThermalForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedThermalForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedThermalForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedThermalForces(data);
    sal[SAL__MTM1M3_logevent_appliedThermalForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedThermalForces(MTM1M3_logevent_appliedThermalForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedThermalForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedThermalForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedThermalForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedThermalForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedThermalForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedThermalForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedThermalForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedThermalForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedThermalForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedThermalForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedThermalForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedThermalForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedThermalForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedThermalForces(MTM1M3_logevent_appliedThermalForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedThermalForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedThermalForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedThermalForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedThermalForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_appliedVelocityForces_88f33d5e data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedVelocityForces");
  }
  MTM1M3::logevent_appliedVelocityForces_88f33d5eDataWriter_var SALWriter = MTM1M3::logevent_appliedVelocityForces_88f33d5eDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("88f33d5e");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedVelocityForces_88f33d5e writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedVelocityForces_88f33d5eDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_appliedVelocityForces_88f33d5eSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedVelocityForces");
  }
  MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader_var SALReader = MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_appliedVelocityForces(MTM1M3_logevent_appliedVelocityForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_appliedVelocityForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_appliedVelocityForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedVelocityForces_88f33d5eDataWriter_var SALWriter = MTM1M3::logevent_appliedVelocityForces_88f33d5eDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_appliedVelocityForces_88f33d5e Instance;

  Instance.private_revCode = DDS::string_dup("88f33d5e");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_appliedVelocityForces_88f33d5e writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_appliedVelocityForces_88f33d5eDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_appliedVelocityForces(MTM1M3_logevent_appliedVelocityForcesC *data)
{
  MTM1M3::logevent_appliedVelocityForces_88f33d5eSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_appliedVelocityForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_appliedVelocityForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader_var SALReader = MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_appliedVelocityForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_appliedVelocityForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_appliedVelocityForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_appliedVelocityForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_appliedVelocityForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_appliedVelocityForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_appliedVelocityForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_appliedVelocityForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_appliedVelocityForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_appliedVelocityForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_appliedVelocityForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_appliedVelocityForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_appliedVelocityForces_88f33d5eDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_appliedVelocityForces(MTM1M3_logevent_appliedVelocityForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_appliedVelocityForces(data);
    sal[SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_appliedVelocityForces(MTM1M3_logevent_appliedVelocityForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_appliedVelocityForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_appliedVelocityForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_appliedVelocityForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_appliedVelocityForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_appliedVelocityForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_appliedVelocityForces.fx;
   data->fy = lastSample_MTM1M3_logevent_appliedVelocityForces.fy;
   data->fz = lastSample_MTM1M3_logevent_appliedVelocityForces.fz;
   data->mx = lastSample_MTM1M3_logevent_appliedVelocityForces.mx;
   data->my = lastSample_MTM1M3_logevent_appliedVelocityForces.my;
   data->mz = lastSample_MTM1M3_logevent_appliedVelocityForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_appliedVelocityForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_appliedVelocityForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_appliedVelocityForces(MTM1M3_logevent_appliedVelocityForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_appliedVelocityForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_cellLightStatus_2a963d17 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_cellLightStatus");
  }
  MTM1M3::logevent_cellLightStatus_2a963d17DataWriter_var SALWriter = MTM1M3::logevent_cellLightStatus_2a963d17DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("2a963d17");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_cellLightStatus_2a963d17 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_cellLightStatus_2a963d17DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_cellLightStatus_2a963d17Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_cellLightStatus");
  }
  MTM1M3::logevent_cellLightStatus_2a963d17DataReader_var SALReader = MTM1M3::logevent_cellLightStatus_2a963d17DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_cellLightStatus_2a963d17DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_cellLightStatus_2a963d17DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_cellLightStatus_2a963d17DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_cellLightStatus(MTM1M3_logevent_cellLightStatusC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_cellLightStatus_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_cellLightStatus");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_cellLightStatus");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_cellLightStatus_2a963d17DataWriter_var SALWriter = MTM1M3::logevent_cellLightStatus_2a963d17DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_cellLightStatus_2a963d17 Instance;

  Instance.private_revCode = DDS::string_dup("2a963d17");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.cellLightsCommandedOn = data->cellLightsCommandedOn;
    Instance.cellLightsOutputOn = data->cellLightsOutputOn;
    Instance.cellLightsOn = data->cellLightsOn;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_cellLightStatus_2a963d17 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_cellLightStatus_2a963d17DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_cellLightStatus(MTM1M3_logevent_cellLightStatusC *data)
{
  MTM1M3::logevent_cellLightStatus_2a963d17Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_cellLightStatus");
  }
  int actorIdx = SAL__MTM1M3_logevent_cellLightStatus_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_cellLightStatus");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_cellLightStatus_2a963d17DataReader_var SALReader = MTM1M3::logevent_cellLightStatus_2a963d17DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_cellLightStatus_2a963d17DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_cellLightStatus_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_cellLightStatus_2a963d17DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_cellLightStatus.timestamp = Instances[j].timestamp;
    data->cellLightsCommandedOn = Instances[j].cellLightsCommandedOn;
    lastSample_MTM1M3_logevent_cellLightStatus.cellLightsCommandedOn = Instances[j].cellLightsCommandedOn;
    data->cellLightsOutputOn = Instances[j].cellLightsOutputOn;
    lastSample_MTM1M3_logevent_cellLightStatus.cellLightsOutputOn = Instances[j].cellLightsOutputOn;
    data->cellLightsOn = Instances[j].cellLightsOn;
    lastSample_MTM1M3_logevent_cellLightStatus.cellLightsOn = Instances[j].cellLightsOn;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_cellLightStatus.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_cellLightStatus_2a963d17DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_cellLightStatus(MTM1M3_logevent_cellLightStatusC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_cellLightStatus_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_cellLightStatus_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_cellLightStatus(data);
    sal[SAL__MTM1M3_logevent_cellLightStatus_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_cellLightStatus(MTM1M3_logevent_cellLightStatusC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_cellLightStatus(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_cellLightStatus.timestamp;
   data->cellLightsCommandedOn = lastSample_MTM1M3_logevent_cellLightStatus.cellLightsCommandedOn;
   data->cellLightsOutputOn = lastSample_MTM1M3_logevent_cellLightStatus.cellLightsOutputOn;
   data->cellLightsOn = lastSample_MTM1M3_logevent_cellLightStatus.cellLightsOn;
   data->priority = lastSample_MTM1M3_logevent_cellLightStatus.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_cellLightStatus(MTM1M3_logevent_cellLightStatusC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_cellLightStatus_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_cellLightStatus_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_cellLightStatus(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_cellLightStatus_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_cellLightWarning_0610a3a7 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_cellLightWarning");
  }
  MTM1M3::logevent_cellLightWarning_0610a3a7DataWriter_var SALWriter = MTM1M3::logevent_cellLightWarning_0610a3a7DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("0610a3a7");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_cellLightWarning_0610a3a7 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_cellLightWarning_0610a3a7DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_cellLightWarning_0610a3a7Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_cellLightWarning");
  }
  MTM1M3::logevent_cellLightWarning_0610a3a7DataReader_var SALReader = MTM1M3::logevent_cellLightWarning_0610a3a7DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_cellLightWarning_0610a3a7DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_cellLightWarning_0610a3a7DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_cellLightWarning_0610a3a7DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_cellLightWarning(MTM1M3_logevent_cellLightWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_cellLightWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_cellLightWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_cellLightWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_cellLightWarning_0610a3a7DataWriter_var SALWriter = MTM1M3::logevent_cellLightWarning_0610a3a7DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_cellLightWarning_0610a3a7 Instance;

  Instance.private_revCode = DDS::string_dup("0610a3a7");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.cellLightsOutputMismatch = data->cellLightsOutputMismatch;
    Instance.cellLightsSensorMismatch = data->cellLightsSensorMismatch;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_cellLightWarning_0610a3a7 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_cellLightWarning_0610a3a7DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_cellLightWarning(MTM1M3_logevent_cellLightWarningC *data)
{
  MTM1M3::logevent_cellLightWarning_0610a3a7Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_cellLightWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_cellLightWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_cellLightWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_cellLightWarning_0610a3a7DataReader_var SALReader = MTM1M3::logevent_cellLightWarning_0610a3a7DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_cellLightWarning_0610a3a7DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_cellLightWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_cellLightWarning_0610a3a7DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_cellLightWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_cellLightWarning.anyWarning = Instances[j].anyWarning;
    data->cellLightsOutputMismatch = Instances[j].cellLightsOutputMismatch;
    lastSample_MTM1M3_logevent_cellLightWarning.cellLightsOutputMismatch = Instances[j].cellLightsOutputMismatch;
    data->cellLightsSensorMismatch = Instances[j].cellLightsSensorMismatch;
    lastSample_MTM1M3_logevent_cellLightWarning.cellLightsSensorMismatch = Instances[j].cellLightsSensorMismatch;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_cellLightWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_cellLightWarning_0610a3a7DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_cellLightWarning(MTM1M3_logevent_cellLightWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_cellLightWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_cellLightWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_cellLightWarning(data);
    sal[SAL__MTM1M3_logevent_cellLightWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_cellLightWarning(MTM1M3_logevent_cellLightWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_cellLightWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_cellLightWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_cellLightWarning.anyWarning;
   data->cellLightsOutputMismatch = lastSample_MTM1M3_logevent_cellLightWarning.cellLightsOutputMismatch;
   data->cellLightsSensorMismatch = lastSample_MTM1M3_logevent_cellLightWarning.cellLightsSensorMismatch;
   data->priority = lastSample_MTM1M3_logevent_cellLightWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_cellLightWarning(MTM1M3_logevent_cellLightWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_cellLightWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_cellLightWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_cellLightWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_cellLightWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_commandRejectionWarning_2445d185 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_commandRejectionWarning");
  }
  MTM1M3::logevent_commandRejectionWarning_2445d185DataWriter_var SALWriter = MTM1M3::logevent_commandRejectionWarning_2445d185DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("2445d185");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_commandRejectionWarning_2445d185 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_commandRejectionWarning_2445d185DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_commandRejectionWarning_2445d185Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_commandRejectionWarning");
  }
  MTM1M3::logevent_commandRejectionWarning_2445d185DataReader_var SALReader = MTM1M3::logevent_commandRejectionWarning_2445d185DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_commandRejectionWarning_2445d185DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_commandRejectionWarning_2445d185DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_commandRejectionWarning_2445d185DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_commandRejectionWarning(MTM1M3_logevent_commandRejectionWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_commandRejectionWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_commandRejectionWarning");
  }
    if ( data->command.length() > 64 ) {
       throw std::length_error("Item command exceeds string length");
    }
    if ( data->reason.length() > 128 ) {
       throw std::length_error("Item reason exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_commandRejectionWarning_2445d185DataWriter_var SALWriter = MTM1M3::logevent_commandRejectionWarning_2445d185DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_commandRejectionWarning_2445d185 Instance;

  Instance.private_revCode = DDS::string_dup("2445d185");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.command = DDS::string_dup(data->command.c_str());
    Instance.reason = DDS::string_dup(data->reason.c_str());
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_commandRejectionWarning_2445d185 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_commandRejectionWarning_2445d185DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_commandRejectionWarning(MTM1M3_logevent_commandRejectionWarningC *data)
{
  MTM1M3::logevent_commandRejectionWarning_2445d185Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_commandRejectionWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_commandRejectionWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_commandRejectionWarning_2445d185DataReader_var SALReader = MTM1M3::logevent_commandRejectionWarning_2445d185DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_commandRejectionWarning_2445d185DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_commandRejectionWarning_2445d185DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_commandRejectionWarning.timestamp = Instances[j].timestamp;
    data->command=Instances[j].command.m_ptr;
    lastSample_MTM1M3_logevent_commandRejectionWarning.command=Instances[j].command.m_ptr;
    data->reason=Instances[j].reason.m_ptr;
    lastSample_MTM1M3_logevent_commandRejectionWarning.reason=Instances[j].reason.m_ptr;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_commandRejectionWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_commandRejectionWarning_2445d185DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_commandRejectionWarning(MTM1M3_logevent_commandRejectionWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_commandRejectionWarning(data);
    sal[SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_commandRejectionWarning(MTM1M3_logevent_commandRejectionWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_commandRejectionWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_commandRejectionWarning.timestamp;
   data->command = lastSample_MTM1M3_logevent_commandRejectionWarning.command;
   data->reason = lastSample_MTM1M3_logevent_commandRejectionWarning.reason;
   data->priority = lastSample_MTM1M3_logevent_commandRejectionWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_commandRejectionWarning(MTM1M3_logevent_commandRejectionWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_commandRejectionWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_detailedState_72060c57 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_detailedState");
  }
  MTM1M3::logevent_detailedState_72060c57DataWriter_var SALWriter = MTM1M3::logevent_detailedState_72060c57DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("72060c57");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_detailedState_72060c57 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_detailedState_72060c57DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_detailedState_72060c57Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_detailedState");
  }
  MTM1M3::logevent_detailedState_72060c57DataReader_var SALReader = MTM1M3::logevent_detailedState_72060c57DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_detailedState_72060c57DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_detailedState_72060c57DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_detailedState_72060c57DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_detailedState(MTM1M3_logevent_detailedStateC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_detailedState_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_detailedState");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_detailedState");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_detailedState_72060c57DataWriter_var SALWriter = MTM1M3::logevent_detailedState_72060c57DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_detailedState_72060c57 Instance;

  Instance.private_revCode = DDS::string_dup("72060c57");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.detailedState = data->detailedState;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_detailedState_72060c57 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_detailedState_72060c57DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_detailedState(MTM1M3_logevent_detailedStateC *data)
{
  MTM1M3::logevent_detailedState_72060c57Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_detailedState");
  }
  int actorIdx = SAL__MTM1M3_logevent_detailedState_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_detailedState");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_detailedState_72060c57DataReader_var SALReader = MTM1M3::logevent_detailedState_72060c57DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_detailedState_72060c57DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_detailedState_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_detailedState_72060c57DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_detailedState.timestamp = Instances[j].timestamp;
    data->detailedState = Instances[j].detailedState;
    lastSample_MTM1M3_logevent_detailedState.detailedState = Instances[j].detailedState;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_detailedState.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_detailedState_72060c57DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_detailedState(MTM1M3_logevent_detailedStateC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_detailedState_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_detailedState_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_detailedState(data);
    sal[SAL__MTM1M3_logevent_detailedState_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_detailedState(MTM1M3_logevent_detailedStateC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_detailedState(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_detailedState.timestamp;
   data->detailedState = lastSample_MTM1M3_logevent_detailedState.detailedState;
   data->priority = lastSample_MTM1M3_logevent_detailedState.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_detailedState(MTM1M3_logevent_detailedStateC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_detailedState_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_detailedState_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_detailedState(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_detailedState_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_displacementSensorWarning_1035d8b2 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_displacementSensorWarning");
  }
  MTM1M3::logevent_displacementSensorWarning_1035d8b2DataWriter_var SALWriter = MTM1M3::logevent_displacementSensorWarning_1035d8b2DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("1035d8b2");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_displacementSensorWarning_1035d8b2 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_displacementSensorWarning_1035d8b2DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_displacementSensorWarning_1035d8b2Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_displacementSensorWarning");
  }
  MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader_var SALReader = MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_displacementSensorWarning(MTM1M3_logevent_displacementSensorWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_displacementSensorWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_displacementSensorWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_displacementSensorWarning_1035d8b2DataWriter_var SALWriter = MTM1M3::logevent_displacementSensorWarning_1035d8b2DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_displacementSensorWarning_1035d8b2 Instance;

  Instance.private_revCode = DDS::string_dup("1035d8b2");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.sensorReportsInvalidCommand = data->sensorReportsInvalidCommand;
    Instance.sensorReportsCommunicationTimeoutError = data->sensorReportsCommunicationTimeoutError;
    Instance.sensorReportsDataLengthError = data->sensorReportsDataLengthError;
    Instance.sensorReportsNumberOfParametersError = data->sensorReportsNumberOfParametersError;
    Instance.sensorReportsParameterError = data->sensorReportsParameterError;
    Instance.sensorReportsCommunicationError = data->sensorReportsCommunicationError;
    Instance.sensorReportsIDNumberError = data->sensorReportsIDNumberError;
    Instance.sensorReportsExpansionLineError = data->sensorReportsExpansionLineError;
    Instance.sensorReportsWriteControlError = data->sensorReportsWriteControlError;
    Instance.responseTimeout = data->responseTimeout;
    Instance.invalidLength = data->invalidLength;
    Instance.invalidResponse = data->invalidResponse;
    Instance.unknownCommand = data->unknownCommand;
    Instance.unknownProblem = data->unknownProblem;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_displacementSensorWarning_1035d8b2 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_displacementSensorWarning_1035d8b2DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_displacementSensorWarning(MTM1M3_logevent_displacementSensorWarningC *data)
{
  MTM1M3::logevent_displacementSensorWarning_1035d8b2Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_displacementSensorWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_displacementSensorWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader_var SALReader = MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_displacementSensorWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_displacementSensorWarning.anyWarning = Instances[j].anyWarning;
    data->sensorReportsInvalidCommand = Instances[j].sensorReportsInvalidCommand;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsInvalidCommand = Instances[j].sensorReportsInvalidCommand;
    data->sensorReportsCommunicationTimeoutError = Instances[j].sensorReportsCommunicationTimeoutError;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsCommunicationTimeoutError = Instances[j].sensorReportsCommunicationTimeoutError;
    data->sensorReportsDataLengthError = Instances[j].sensorReportsDataLengthError;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsDataLengthError = Instances[j].sensorReportsDataLengthError;
    data->sensorReportsNumberOfParametersError = Instances[j].sensorReportsNumberOfParametersError;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsNumberOfParametersError = Instances[j].sensorReportsNumberOfParametersError;
    data->sensorReportsParameterError = Instances[j].sensorReportsParameterError;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsParameterError = Instances[j].sensorReportsParameterError;
    data->sensorReportsCommunicationError = Instances[j].sensorReportsCommunicationError;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsCommunicationError = Instances[j].sensorReportsCommunicationError;
    data->sensorReportsIDNumberError = Instances[j].sensorReportsIDNumberError;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsIDNumberError = Instances[j].sensorReportsIDNumberError;
    data->sensorReportsExpansionLineError = Instances[j].sensorReportsExpansionLineError;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsExpansionLineError = Instances[j].sensorReportsExpansionLineError;
    data->sensorReportsWriteControlError = Instances[j].sensorReportsWriteControlError;
    lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsWriteControlError = Instances[j].sensorReportsWriteControlError;
    data->responseTimeout = Instances[j].responseTimeout;
    lastSample_MTM1M3_logevent_displacementSensorWarning.responseTimeout = Instances[j].responseTimeout;
    data->invalidLength = Instances[j].invalidLength;
    lastSample_MTM1M3_logevent_displacementSensorWarning.invalidLength = Instances[j].invalidLength;
    data->invalidResponse = Instances[j].invalidResponse;
    lastSample_MTM1M3_logevent_displacementSensorWarning.invalidResponse = Instances[j].invalidResponse;
    data->unknownCommand = Instances[j].unknownCommand;
    lastSample_MTM1M3_logevent_displacementSensorWarning.unknownCommand = Instances[j].unknownCommand;
    data->unknownProblem = Instances[j].unknownProblem;
    lastSample_MTM1M3_logevent_displacementSensorWarning.unknownProblem = Instances[j].unknownProblem;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_displacementSensorWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_displacementSensorWarning_1035d8b2DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_displacementSensorWarning(MTM1M3_logevent_displacementSensorWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_displacementSensorWarning(data);
    sal[SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_displacementSensorWarning(MTM1M3_logevent_displacementSensorWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_displacementSensorWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_displacementSensorWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_displacementSensorWarning.anyWarning;
   data->sensorReportsInvalidCommand = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsInvalidCommand;
   data->sensorReportsCommunicationTimeoutError = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsCommunicationTimeoutError;
   data->sensorReportsDataLengthError = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsDataLengthError;
   data->sensorReportsNumberOfParametersError = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsNumberOfParametersError;
   data->sensorReportsParameterError = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsParameterError;
   data->sensorReportsCommunicationError = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsCommunicationError;
   data->sensorReportsIDNumberError = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsIDNumberError;
   data->sensorReportsExpansionLineError = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsExpansionLineError;
   data->sensorReportsWriteControlError = lastSample_MTM1M3_logevent_displacementSensorWarning.sensorReportsWriteControlError;
   data->responseTimeout = lastSample_MTM1M3_logevent_displacementSensorWarning.responseTimeout;
   data->invalidLength = lastSample_MTM1M3_logevent_displacementSensorWarning.invalidLength;
   data->invalidResponse = lastSample_MTM1M3_logevent_displacementSensorWarning.invalidResponse;
   data->unknownCommand = lastSample_MTM1M3_logevent_displacementSensorWarning.unknownCommand;
   data->unknownProblem = lastSample_MTM1M3_logevent_displacementSensorWarning.unknownProblem;
   data->priority = lastSample_MTM1M3_logevent_displacementSensorWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_displacementSensorWarning(MTM1M3_logevent_displacementSensorWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_displacementSensorWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_errorCode_8bce170e data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_errorCode");
  }
  MTM1M3::logevent_errorCode_8bce170eDataWriter_var SALWriter = MTM1M3::logevent_errorCode_8bce170eDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("8bce170e");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_errorCode_8bce170e writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_errorCode_8bce170eDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_errorCode_8bce170eSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_errorCode");
  }
  MTM1M3::logevent_errorCode_8bce170eDataReader_var SALReader = MTM1M3::logevent_errorCode_8bce170eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_errorCode_8bce170eDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_errorCode_8bce170eDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_errorCode_8bce170eDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_errorCode(MTM1M3_logevent_errorCodeC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_errorCode_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_errorCode");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_errorCode");
  }
    if ( data->errorReport.length() > 128 ) {
       throw std::length_error("Item errorReport exceeds string length");
    }
    if ( data->traceback.length() > 128 ) {
       throw std::length_error("Item traceback exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_errorCode_8bce170eDataWriter_var SALWriter = MTM1M3::logevent_errorCode_8bce170eDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_errorCode_8bce170e Instance;

  Instance.private_revCode = DDS::string_dup("8bce170e");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.errorCode = data->errorCode;
    Instance.errorReport = DDS::string_dup(data->errorReport.c_str());
    Instance.traceback = DDS::string_dup(data->traceback.c_str());
    Instance.detailedErrorCode = data->detailedErrorCode;
    Instance.timestamp = data->timestamp;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_errorCode_8bce170e writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_errorCode_8bce170eDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_errorCode(MTM1M3_logevent_errorCodeC *data)
{
  MTM1M3::logevent_errorCode_8bce170eSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_errorCode");
  }
  int actorIdx = SAL__MTM1M3_logevent_errorCode_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_errorCode");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_errorCode_8bce170eDataReader_var SALReader = MTM1M3::logevent_errorCode_8bce170eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_errorCode_8bce170eDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_errorCode_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_errorCode_8bce170eDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->errorCode = Instances[j].errorCode;
    lastSample_MTM1M3_logevent_errorCode.errorCode = Instances[j].errorCode;
    data->errorReport=Instances[j].errorReport.m_ptr;
    lastSample_MTM1M3_logevent_errorCode.errorReport=Instances[j].errorReport.m_ptr;
    data->traceback=Instances[j].traceback.m_ptr;
    lastSample_MTM1M3_logevent_errorCode.traceback=Instances[j].traceback.m_ptr;
    data->detailedErrorCode = Instances[j].detailedErrorCode;
    lastSample_MTM1M3_logevent_errorCode.detailedErrorCode = Instances[j].detailedErrorCode;
    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_errorCode.timestamp = Instances[j].timestamp;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_errorCode.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_errorCode_8bce170eDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_errorCode(MTM1M3_logevent_errorCodeC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_errorCode_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_errorCode_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_errorCode(data);
    sal[SAL__MTM1M3_logevent_errorCode_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_errorCode(MTM1M3_logevent_errorCodeC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_errorCode(data);
    if (istatus == SAL__NO_UPDATES) {
   data->errorCode = lastSample_MTM1M3_logevent_errorCode.errorCode;
   data->errorReport = lastSample_MTM1M3_logevent_errorCode.errorReport;
   data->traceback = lastSample_MTM1M3_logevent_errorCode.traceback;
   data->detailedErrorCode = lastSample_MTM1M3_logevent_errorCode.detailedErrorCode;
   data->timestamp = lastSample_MTM1M3_logevent_errorCode.timestamp;
   data->priority = lastSample_MTM1M3_logevent_errorCode.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_errorCode(MTM1M3_logevent_errorCodeC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_errorCode_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_errorCode_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_errorCode(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_errorCode_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_forceActuatorForceWarning_3a01ad1f data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceActuatorForceWarning");
  }
  MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataWriter_var SALWriter = MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("3a01ad1f");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceActuatorForceWarning_3a01ad1f writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceActuatorForceWarning");
  }
  MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader_var SALReader = MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_forceActuatorForceWarning(MTM1M3_logevent_forceActuatorForceWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_forceActuatorForceWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceActuatorForceWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataWriter_var SALWriter = MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_forceActuatorForceWarning_3a01ad1f Instance;

  Instance.private_revCode = DDS::string_dup("3a01ad1f");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.anyPrimaryAxisMeasuredForceWarning = data->anyPrimaryAxisMeasuredForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.primaryAxisMeasuredForceWarning[iseq] = data->primaryAxisMeasuredForceWarning[iseq];}
    Instance.anySecondaryAxisMeasuredForceWarning = data->anySecondaryAxisMeasuredForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.secondaryAxisMeasuredForceWarning[iseq] = data->secondaryAxisMeasuredForceWarning[iseq];}
    Instance.anyPrimaryAxisFollowingErrorWarning = data->anyPrimaryAxisFollowingErrorWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.primaryAxisFollowingErrorWarning[iseq] = data->primaryAxisFollowingErrorWarning[iseq];}
    Instance.anySecondaryAxisFollowingErrorWarning = data->anySecondaryAxisFollowingErrorWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.secondaryAxisFollowingErrorWarning[iseq] = data->secondaryAxisFollowingErrorWarning[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceActuatorForceWarning_3a01ad1f writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_forceActuatorForceWarning(MTM1M3_logevent_forceActuatorForceWarningC *data)
{
  MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_forceActuatorForceWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceActuatorForceWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader_var SALReader = MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_forceActuatorForceWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_forceActuatorForceWarning.anyWarning = Instances[j].anyWarning;
    data->anyPrimaryAxisMeasuredForceWarning = Instances[j].anyPrimaryAxisMeasuredForceWarning;
    lastSample_MTM1M3_logevent_forceActuatorForceWarning.anyPrimaryAxisMeasuredForceWarning = Instances[j].anyPrimaryAxisMeasuredForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->primaryAxisMeasuredForceWarning[iseq] = Instances[j].primaryAxisMeasuredForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorForceWarning.primaryAxisMeasuredForceWarning[iseq] = Instances[j].primaryAxisMeasuredForceWarning[iseq];}
    data->anySecondaryAxisMeasuredForceWarning = Instances[j].anySecondaryAxisMeasuredForceWarning;
    lastSample_MTM1M3_logevent_forceActuatorForceWarning.anySecondaryAxisMeasuredForceWarning = Instances[j].anySecondaryAxisMeasuredForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->secondaryAxisMeasuredForceWarning[iseq] = Instances[j].secondaryAxisMeasuredForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorForceWarning.secondaryAxisMeasuredForceWarning[iseq] = Instances[j].secondaryAxisMeasuredForceWarning[iseq];}
    data->anyPrimaryAxisFollowingErrorWarning = Instances[j].anyPrimaryAxisFollowingErrorWarning;
    lastSample_MTM1M3_logevent_forceActuatorForceWarning.anyPrimaryAxisFollowingErrorWarning = Instances[j].anyPrimaryAxisFollowingErrorWarning;
    for (int iseq=0;iseq<156;iseq++) {data->primaryAxisFollowingErrorWarning[iseq] = Instances[j].primaryAxisFollowingErrorWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorForceWarning.primaryAxisFollowingErrorWarning[iseq] = Instances[j].primaryAxisFollowingErrorWarning[iseq];}
    data->anySecondaryAxisFollowingErrorWarning = Instances[j].anySecondaryAxisFollowingErrorWarning;
    lastSample_MTM1M3_logevent_forceActuatorForceWarning.anySecondaryAxisFollowingErrorWarning = Instances[j].anySecondaryAxisFollowingErrorWarning;
    for (int iseq=0;iseq<156;iseq++) {data->secondaryAxisFollowingErrorWarning[iseq] = Instances[j].secondaryAxisFollowingErrorWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorForceWarning.secondaryAxisFollowingErrorWarning[iseq] = Instances[j].secondaryAxisFollowingErrorWarning[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_forceActuatorForceWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_forceActuatorForceWarning_3a01ad1fDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_forceActuatorForceWarning(MTM1M3_logevent_forceActuatorForceWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_forceActuatorForceWarning(data);
    sal[SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_forceActuatorForceWarning(MTM1M3_logevent_forceActuatorForceWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_forceActuatorForceWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_forceActuatorForceWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_forceActuatorForceWarning.anyWarning;
   data->anyPrimaryAxisMeasuredForceWarning = lastSample_MTM1M3_logevent_forceActuatorForceWarning.anyPrimaryAxisMeasuredForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->primaryAxisMeasuredForceWarning[iseq] = lastSample_MTM1M3_logevent_forceActuatorForceWarning.primaryAxisMeasuredForceWarning[iseq];}
   data->anySecondaryAxisMeasuredForceWarning = lastSample_MTM1M3_logevent_forceActuatorForceWarning.anySecondaryAxisMeasuredForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->secondaryAxisMeasuredForceWarning[iseq] = lastSample_MTM1M3_logevent_forceActuatorForceWarning.secondaryAxisMeasuredForceWarning[iseq];}
   data->anyPrimaryAxisFollowingErrorWarning = lastSample_MTM1M3_logevent_forceActuatorForceWarning.anyPrimaryAxisFollowingErrorWarning;
    for (int iseq=0;iseq<156;iseq++) {data->primaryAxisFollowingErrorWarning[iseq] = lastSample_MTM1M3_logevent_forceActuatorForceWarning.primaryAxisFollowingErrorWarning[iseq];}
   data->anySecondaryAxisFollowingErrorWarning = lastSample_MTM1M3_logevent_forceActuatorForceWarning.anySecondaryAxisFollowingErrorWarning;
    for (int iseq=0;iseq<156;iseq++) {data->secondaryAxisFollowingErrorWarning[iseq] = lastSample_MTM1M3_logevent_forceActuatorForceWarning.secondaryAxisFollowingErrorWarning[iseq];}
   data->priority = lastSample_MTM1M3_logevent_forceActuatorForceWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_forceActuatorForceWarning(MTM1M3_logevent_forceActuatorForceWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_forceActuatorForceWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_forceActuatorInfo_d0ebe0c5 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceActuatorInfo");
  }
  MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataWriter_var SALWriter = MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("d0ebe0c5");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceActuatorInfo_d0ebe0c5 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_forceActuatorInfo_d0ebe0c5Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceActuatorInfo");
  }
  MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader_var SALReader = MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_forceActuatorInfo(MTM1M3_logevent_forceActuatorInfoC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_forceActuatorInfo");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceActuatorInfo");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataWriter_var SALWriter = MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_forceActuatorInfo_d0ebe0c5 Instance;

  Instance.private_revCode = DDS::string_dup("d0ebe0c5");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<156;iseq++) {Instance.referenceId[iseq] = data->referenceId[iseq];}
    for (int iseq=0;iseq<12;iseq++) {Instance.xDataReferenceId[iseq] = data->xDataReferenceId[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yDataReferenceId[iseq] = data->yDataReferenceId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zDataReferenceId[iseq] = data->zDataReferenceId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.actuatorType[iseq] = data->actuatorType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.actuatorOrientation[iseq] = data->actuatorOrientation[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.modbusSubnet[iseq] = data->modbusSubnet[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.modbusAddress[iseq] = data->modbusAddress[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.xPosition[iseq] = data->xPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.yPosition[iseq] = data->yPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zPosition[iseq] = data->zPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.ilcUniqueId[iseq] = data->ilcUniqueId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.ilcApplicationType[iseq] = data->ilcApplicationType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.networkNodeType[iseq] = data->networkNodeType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.ilcSelectedOptions[iseq] = data->ilcSelectedOptions[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.networkNodeOptions[iseq] = data->networkNodeOptions[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.majorRevision[iseq] = data->majorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.minorRevision[iseq] = data->minorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.adcScanRate[iseq] = data->adcScanRate[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mainPrimaryCylinderCoefficient[iseq] = data->mainPrimaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mainSecondaryCylinderCoefficient[iseq] = data->mainSecondaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mainPrimaryCylinderLoadCellOffset[iseq] = data->mainPrimaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mainSecondaryCylinderLoadCellOffset[iseq] = data->mainSecondaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mainPrimaryCylinderLoadCellSensitivity[iseq] = data->mainPrimaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mainSecondaryCylinderLoadCellSensitivity[iseq] = data->mainSecondaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.backupPrimaryCylinderCoefficient[iseq] = data->backupPrimaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.backupSecondaryCylinderCoefficient[iseq] = data->backupSecondaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.backupPrimaryCylinderLoadCellOffset[iseq] = data->backupPrimaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.backupSecondaryCylinderLoadCellOffset[iseq] = data->backupSecondaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.backupPrimaryCylinderLoadCellSensitivity[iseq] = data->backupPrimaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.backupSecondaryCylinderLoadCellSensitivity[iseq] = data->backupSecondaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzaninePrimaryCylinderGain[iseq] = data->mezzaninePrimaryCylinderGain[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineSecondaryCylinderGain[iseq] = data->mezzanineSecondaryCylinderGain[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineUniqueId[iseq] = data->mezzanineUniqueId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineFirmwareType[iseq] = data->mezzanineFirmwareType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineMajorRevision[iseq] = data->mezzanineMajorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineMinorRevision[iseq] = data->mezzanineMinorRevision[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceActuatorInfo_d0ebe0c5 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_forceActuatorInfo(MTM1M3_logevent_forceActuatorInfoC *data)
{
  MTM1M3::logevent_forceActuatorInfo_d0ebe0c5Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_forceActuatorInfo");
  }
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceActuatorInfo");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader_var SALReader = MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_forceActuatorInfo.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->referenceId[iseq] = Instances[j].referenceId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.referenceId[iseq] = Instances[j].referenceId[iseq];}
    for (int iseq=0;iseq<12;iseq++) {data->xDataReferenceId[iseq] = Instances[j].xDataReferenceId[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.xDataReferenceId[iseq] = Instances[j].xDataReferenceId[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yDataReferenceId[iseq] = Instances[j].yDataReferenceId[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.yDataReferenceId[iseq] = Instances[j].yDataReferenceId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zDataReferenceId[iseq] = Instances[j].zDataReferenceId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.zDataReferenceId[iseq] = Instances[j].zDataReferenceId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->actuatorType[iseq] = Instances[j].actuatorType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.actuatorType[iseq] = Instances[j].actuatorType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->actuatorOrientation[iseq] = Instances[j].actuatorOrientation[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.actuatorOrientation[iseq] = Instances[j].actuatorOrientation[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->modbusSubnet[iseq] = Instances[j].modbusSubnet[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.modbusSubnet[iseq] = Instances[j].modbusSubnet[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->modbusAddress[iseq] = Instances[j].modbusAddress[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.modbusAddress[iseq] = Instances[j].modbusAddress[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->xPosition[iseq] = Instances[j].xPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.xPosition[iseq] = Instances[j].xPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->yPosition[iseq] = Instances[j].yPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.yPosition[iseq] = Instances[j].yPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zPosition[iseq] = Instances[j].zPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.zPosition[iseq] = Instances[j].zPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->ilcUniqueId[iseq] = Instances[j].ilcUniqueId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.ilcUniqueId[iseq] = Instances[j].ilcUniqueId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->ilcApplicationType[iseq] = Instances[j].ilcApplicationType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.ilcApplicationType[iseq] = Instances[j].ilcApplicationType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->networkNodeType[iseq] = Instances[j].networkNodeType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.networkNodeType[iseq] = Instances[j].networkNodeType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->ilcSelectedOptions[iseq] = Instances[j].ilcSelectedOptions[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.ilcSelectedOptions[iseq] = Instances[j].ilcSelectedOptions[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->networkNodeOptions[iseq] = Instances[j].networkNodeOptions[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.networkNodeOptions[iseq] = Instances[j].networkNodeOptions[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->majorRevision[iseq] = Instances[j].majorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.majorRevision[iseq] = Instances[j].majorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->minorRevision[iseq] = Instances[j].minorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.minorRevision[iseq] = Instances[j].minorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->adcScanRate[iseq] = Instances[j].adcScanRate[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.adcScanRate[iseq] = Instances[j].adcScanRate[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainPrimaryCylinderCoefficient[iseq] = Instances[j].mainPrimaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mainPrimaryCylinderCoefficient[iseq] = Instances[j].mainPrimaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainSecondaryCylinderCoefficient[iseq] = Instances[j].mainSecondaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mainSecondaryCylinderCoefficient[iseq] = Instances[j].mainSecondaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainPrimaryCylinderLoadCellOffset[iseq] = Instances[j].mainPrimaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mainPrimaryCylinderLoadCellOffset[iseq] = Instances[j].mainPrimaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainSecondaryCylinderLoadCellOffset[iseq] = Instances[j].mainSecondaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mainSecondaryCylinderLoadCellOffset[iseq] = Instances[j].mainSecondaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainPrimaryCylinderLoadCellSensitivity[iseq] = Instances[j].mainPrimaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mainPrimaryCylinderLoadCellSensitivity[iseq] = Instances[j].mainPrimaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainSecondaryCylinderLoadCellSensitivity[iseq] = Instances[j].mainSecondaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mainSecondaryCylinderLoadCellSensitivity[iseq] = Instances[j].mainSecondaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupPrimaryCylinderCoefficient[iseq] = Instances[j].backupPrimaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.backupPrimaryCylinderCoefficient[iseq] = Instances[j].backupPrimaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupSecondaryCylinderCoefficient[iseq] = Instances[j].backupSecondaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.backupSecondaryCylinderCoefficient[iseq] = Instances[j].backupSecondaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupPrimaryCylinderLoadCellOffset[iseq] = Instances[j].backupPrimaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.backupPrimaryCylinderLoadCellOffset[iseq] = Instances[j].backupPrimaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupSecondaryCylinderLoadCellOffset[iseq] = Instances[j].backupSecondaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.backupSecondaryCylinderLoadCellOffset[iseq] = Instances[j].backupSecondaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupPrimaryCylinderLoadCellSensitivity[iseq] = Instances[j].backupPrimaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.backupPrimaryCylinderLoadCellSensitivity[iseq] = Instances[j].backupPrimaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupSecondaryCylinderLoadCellSensitivity[iseq] = Instances[j].backupSecondaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.backupSecondaryCylinderLoadCellSensitivity[iseq] = Instances[j].backupSecondaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzaninePrimaryCylinderGain[iseq] = Instances[j].mezzaninePrimaryCylinderGain[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mezzaninePrimaryCylinderGain[iseq] = Instances[j].mezzaninePrimaryCylinderGain[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineSecondaryCylinderGain[iseq] = Instances[j].mezzanineSecondaryCylinderGain[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineSecondaryCylinderGain[iseq] = Instances[j].mezzanineSecondaryCylinderGain[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineUniqueId[iseq] = Instances[j].mezzanineUniqueId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineUniqueId[iseq] = Instances[j].mezzanineUniqueId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineFirmwareType[iseq] = Instances[j].mezzanineFirmwareType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineFirmwareType[iseq] = Instances[j].mezzanineFirmwareType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineMajorRevision[iseq] = Instances[j].mezzanineMajorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineMajorRevision[iseq] = Instances[j].mezzanineMajorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineMinorRevision[iseq] = Instances[j].mezzanineMinorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineMinorRevision[iseq] = Instances[j].mezzanineMinorRevision[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_forceActuatorInfo.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_forceActuatorInfo_d0ebe0c5DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_forceActuatorInfo(MTM1M3_logevent_forceActuatorInfoC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_forceActuatorInfo(data);
    sal[SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_forceActuatorInfo(MTM1M3_logevent_forceActuatorInfoC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_forceActuatorInfo(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_forceActuatorInfo.timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->referenceId[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.referenceId[iseq];}
    for (int iseq=0;iseq<12;iseq++) {data->xDataReferenceId[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.xDataReferenceId[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yDataReferenceId[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.yDataReferenceId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zDataReferenceId[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.zDataReferenceId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->actuatorType[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.actuatorType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->actuatorOrientation[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.actuatorOrientation[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->modbusSubnet[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.modbusSubnet[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->modbusAddress[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.modbusAddress[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->xPosition[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.xPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->yPosition[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.yPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zPosition[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.zPosition[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->ilcUniqueId[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.ilcUniqueId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->ilcApplicationType[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.ilcApplicationType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->networkNodeType[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.networkNodeType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->ilcSelectedOptions[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.ilcSelectedOptions[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->networkNodeOptions[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.networkNodeOptions[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->majorRevision[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.majorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->minorRevision[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.minorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->adcScanRate[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.adcScanRate[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainPrimaryCylinderCoefficient[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mainPrimaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainSecondaryCylinderCoefficient[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mainSecondaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainPrimaryCylinderLoadCellOffset[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mainPrimaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainSecondaryCylinderLoadCellOffset[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mainSecondaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainPrimaryCylinderLoadCellSensitivity[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mainPrimaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mainSecondaryCylinderLoadCellSensitivity[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mainSecondaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupPrimaryCylinderCoefficient[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.backupPrimaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupSecondaryCylinderCoefficient[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.backupSecondaryCylinderCoefficient[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupPrimaryCylinderLoadCellOffset[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.backupPrimaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupSecondaryCylinderLoadCellOffset[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.backupSecondaryCylinderLoadCellOffset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupPrimaryCylinderLoadCellSensitivity[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.backupPrimaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->backupSecondaryCylinderLoadCellSensitivity[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.backupSecondaryCylinderLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzaninePrimaryCylinderGain[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mezzaninePrimaryCylinderGain[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineSecondaryCylinderGain[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineSecondaryCylinderGain[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineUniqueId[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineUniqueId[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineFirmwareType[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineFirmwareType[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineMajorRevision[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineMajorRevision[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineMinorRevision[iseq] = lastSample_MTM1M3_logevent_forceActuatorInfo.mezzanineMinorRevision[iseq];}
   data->priority = lastSample_MTM1M3_logevent_forceActuatorInfo.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_forceActuatorInfo(MTM1M3_logevent_forceActuatorInfoC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_forceActuatorInfo(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_forceActuatorState_028222bb data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceActuatorState");
  }
  MTM1M3::logevent_forceActuatorState_028222bbDataWriter_var SALWriter = MTM1M3::logevent_forceActuatorState_028222bbDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("028222bb");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceActuatorState_028222bb writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceActuatorState_028222bbDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_forceActuatorState_028222bbSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceActuatorState");
  }
  MTM1M3::logevent_forceActuatorState_028222bbDataReader_var SALReader = MTM1M3::logevent_forceActuatorState_028222bbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceActuatorState_028222bbDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceActuatorState_028222bbDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_forceActuatorState_028222bbDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_forceActuatorState(MTM1M3_logevent_forceActuatorStateC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorState_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_forceActuatorState");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceActuatorState");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceActuatorState_028222bbDataWriter_var SALWriter = MTM1M3::logevent_forceActuatorState_028222bbDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_forceActuatorState_028222bb Instance;

  Instance.private_revCode = DDS::string_dup("028222bb");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<156;iseq++) {Instance.ilcState[iseq] = data->ilcState[iseq];}
    Instance.slewFlag = data->slewFlag;
    Instance.staticForcesApplied = data->staticForcesApplied;
    Instance.elevationForcesApplied = data->elevationForcesApplied;
    Instance.azimuthForcesApplied = data->azimuthForcesApplied;
    Instance.thermalForcesApplied = data->thermalForcesApplied;
    Instance.offsetForcesApplied = data->offsetForcesApplied;
    Instance.accelerationForcesApplied = data->accelerationForcesApplied;
    Instance.velocityForcesApplied = data->velocityForcesApplied;
    Instance.activeOpticForcesApplied = data->activeOpticForcesApplied;
    Instance.aberrationForcesApplied = data->aberrationForcesApplied;
    Instance.balanceForcesApplied = data->balanceForcesApplied;
    Instance.supportPercentage = data->supportPercentage;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceActuatorState_028222bb writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceActuatorState_028222bbDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_forceActuatorState(MTM1M3_logevent_forceActuatorStateC *data)
{
  MTM1M3::logevent_forceActuatorState_028222bbSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_forceActuatorState");
  }
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorState_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceActuatorState");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceActuatorState_028222bbDataReader_var SALReader = MTM1M3::logevent_forceActuatorState_028222bbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceActuatorState_028222bbDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_forceActuatorState_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceActuatorState_028222bbDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_forceActuatorState.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->ilcState[iseq] = Instances[j].ilcState[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorState.ilcState[iseq] = Instances[j].ilcState[iseq];}
    data->slewFlag = Instances[j].slewFlag;
    lastSample_MTM1M3_logevent_forceActuatorState.slewFlag = Instances[j].slewFlag;
    data->staticForcesApplied = Instances[j].staticForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.staticForcesApplied = Instances[j].staticForcesApplied;
    data->elevationForcesApplied = Instances[j].elevationForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.elevationForcesApplied = Instances[j].elevationForcesApplied;
    data->azimuthForcesApplied = Instances[j].azimuthForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.azimuthForcesApplied = Instances[j].azimuthForcesApplied;
    data->thermalForcesApplied = Instances[j].thermalForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.thermalForcesApplied = Instances[j].thermalForcesApplied;
    data->offsetForcesApplied = Instances[j].offsetForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.offsetForcesApplied = Instances[j].offsetForcesApplied;
    data->accelerationForcesApplied = Instances[j].accelerationForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.accelerationForcesApplied = Instances[j].accelerationForcesApplied;
    data->velocityForcesApplied = Instances[j].velocityForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.velocityForcesApplied = Instances[j].velocityForcesApplied;
    data->activeOpticForcesApplied = Instances[j].activeOpticForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.activeOpticForcesApplied = Instances[j].activeOpticForcesApplied;
    data->aberrationForcesApplied = Instances[j].aberrationForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.aberrationForcesApplied = Instances[j].aberrationForcesApplied;
    data->balanceForcesApplied = Instances[j].balanceForcesApplied;
    lastSample_MTM1M3_logevent_forceActuatorState.balanceForcesApplied = Instances[j].balanceForcesApplied;
    data->supportPercentage = Instances[j].supportPercentage;
    lastSample_MTM1M3_logevent_forceActuatorState.supportPercentage = Instances[j].supportPercentage;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_forceActuatorState.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_forceActuatorState_028222bbDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_forceActuatorState(MTM1M3_logevent_forceActuatorStateC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_forceActuatorState_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_forceActuatorState_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_forceActuatorState(data);
    sal[SAL__MTM1M3_logevent_forceActuatorState_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_forceActuatorState(MTM1M3_logevent_forceActuatorStateC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_forceActuatorState(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_forceActuatorState.timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->ilcState[iseq] = lastSample_MTM1M3_logevent_forceActuatorState.ilcState[iseq];}
   data->slewFlag = lastSample_MTM1M3_logevent_forceActuatorState.slewFlag;
   data->staticForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.staticForcesApplied;
   data->elevationForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.elevationForcesApplied;
   data->azimuthForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.azimuthForcesApplied;
   data->thermalForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.thermalForcesApplied;
   data->offsetForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.offsetForcesApplied;
   data->accelerationForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.accelerationForcesApplied;
   data->velocityForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.velocityForcesApplied;
   data->activeOpticForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.activeOpticForcesApplied;
   data->aberrationForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.aberrationForcesApplied;
   data->balanceForcesApplied = lastSample_MTM1M3_logevent_forceActuatorState.balanceForcesApplied;
   data->supportPercentage = lastSample_MTM1M3_logevent_forceActuatorState.supportPercentage;
   data->priority = lastSample_MTM1M3_logevent_forceActuatorState.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_forceActuatorState(MTM1M3_logevent_forceActuatorStateC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_forceActuatorState_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_forceActuatorState_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_forceActuatorState(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_forceActuatorState_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_forceActuatorWarning_34b69bc9 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceActuatorWarning");
  }
  MTM1M3::logevent_forceActuatorWarning_34b69bc9DataWriter_var SALWriter = MTM1M3::logevent_forceActuatorWarning_34b69bc9DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("34b69bc9");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceActuatorWarning_34b69bc9 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceActuatorWarning_34b69bc9DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_forceActuatorWarning_34b69bc9Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceActuatorWarning");
  }
  MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader_var SALReader = MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_forceActuatorWarning(MTM1M3_logevent_forceActuatorWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_forceActuatorWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceActuatorWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceActuatorWarning_34b69bc9DataWriter_var SALWriter = MTM1M3::logevent_forceActuatorWarning_34b69bc9DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_forceActuatorWarning_34b69bc9 Instance;

  Instance.private_revCode = DDS::string_dup("34b69bc9");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.anyMajorFault = data->anyMajorFault;
    for (int iseq=0;iseq<156;iseq++) {Instance.majorFault[iseq] = data->majorFault[iseq];}
    Instance.anyMinorFault = data->anyMinorFault;
    for (int iseq=0;iseq<156;iseq++) {Instance.minorFault[iseq] = data->minorFault[iseq];}
    Instance.anyFaultOverride = data->anyFaultOverride;
    for (int iseq=0;iseq<156;iseq++) {Instance.faultOverride[iseq] = data->faultOverride[iseq];}
    Instance.anyMainCalibrationError = data->anyMainCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {Instance.mainCalibrationError[iseq] = data->mainCalibrationError[iseq];}
    Instance.anyBackupCalibrationError = data->anyBackupCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {Instance.backupCalibrationError[iseq] = data->backupCalibrationError[iseq];}
    Instance.anyMezzanineError = data->anyMezzanineError;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineError[iseq] = data->mezzanineError[iseq];}
    Instance.anyMezzanineBootloaderActive = data->anyMezzanineBootloaderActive;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineBootloaderActive[iseq] = data->mezzanineBootloaderActive[iseq];}
    Instance.anyUniqueIdCRCError = data->anyUniqueIdCRCError;
    for (int iseq=0;iseq<156;iseq++) {Instance.uniqueIdCRCError[iseq] = data->uniqueIdCRCError[iseq];}
    Instance.anyApplicationTypeMismatch = data->anyApplicationTypeMismatch;
    for (int iseq=0;iseq<156;iseq++) {Instance.applicationTypeMismatch[iseq] = data->applicationTypeMismatch[iseq];}
    Instance.anyApplicationMissing = data->anyApplicationMissing;
    for (int iseq=0;iseq<156;iseq++) {Instance.applicationMissing[iseq] = data->applicationMissing[iseq];}
    Instance.anyApplicationCRCMismatch = data->anyApplicationCRCMismatch;
    for (int iseq=0;iseq<156;iseq++) {Instance.applicationCRCMismatch[iseq] = data->applicationCRCMismatch[iseq];}
    Instance.anyOneWireMissing = data->anyOneWireMissing;
    for (int iseq=0;iseq<156;iseq++) {Instance.oneWireMissing[iseq] = data->oneWireMissing[iseq];}
    Instance.anyOneWire1Mismatch = data->anyOneWire1Mismatch;
    for (int iseq=0;iseq<156;iseq++) {Instance.oneWire1Mismatch[iseq] = data->oneWire1Mismatch[iseq];}
    Instance.anyOneWire2Mismatch = data->anyOneWire2Mismatch;
    for (int iseq=0;iseq<156;iseq++) {Instance.oneWire2Mismatch[iseq] = data->oneWire2Mismatch[iseq];}
    Instance.anyWatchdogReset = data->anyWatchdogReset;
    for (int iseq=0;iseq<156;iseq++) {Instance.watchdogReset[iseq] = data->watchdogReset[iseq];}
    Instance.anyBrownOut = data->anyBrownOut;
    for (int iseq=0;iseq<156;iseq++) {Instance.brownOut[iseq] = data->brownOut[iseq];}
    Instance.anyEventTrapReset = data->anyEventTrapReset;
    for (int iseq=0;iseq<156;iseq++) {Instance.eventTrapReset[iseq] = data->eventTrapReset[iseq];}
    Instance.anySSRPowerFault = data->anySSRPowerFault;
    for (int iseq=0;iseq<156;iseq++) {Instance.ssrPowerFault[iseq] = data->ssrPowerFault[iseq];}
    Instance.anyAuxPowerFault = data->anyAuxPowerFault;
    for (int iseq=0;iseq<156;iseq++) {Instance.auxPowerFault[iseq] = data->auxPowerFault[iseq];}
    Instance.anyMezzaninePowerFault = data->anyMezzaninePowerFault;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzaninePowerFault[iseq] = data->mezzaninePowerFault[iseq];}
    Instance.anyMezzanineCurrentAmp1Fault = data->anyMezzanineCurrentAmp1Fault;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineCurrentAmp1Fault[iseq] = data->mezzanineCurrentAmp1Fault[iseq];}
    Instance.anyMezzanineCurrentAmp2Fault = data->anyMezzanineCurrentAmp2Fault;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineCurrentAmp2Fault[iseq] = data->mezzanineCurrentAmp2Fault[iseq];}
    Instance.anyMezzanineUniqueIdCRCError = data->anyMezzanineUniqueIdCRCError;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineUniqueIdCRCError[iseq] = data->mezzanineUniqueIdCRCError[iseq];}
    Instance.anyMezzanineMainCalibrationError = data->anyMezzanineMainCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineMainCalibrationError[iseq] = data->mezzanineMainCalibrationError[iseq];}
    Instance.anyMezzanineBackupCalibrationError = data->anyMezzanineBackupCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineBackupCalibrationError[iseq] = data->mezzanineBackupCalibrationError[iseq];}
    Instance.anyMezzanineEventTrapReset = data->anyMezzanineEventTrapReset;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineEventTrapReset[iseq] = data->mezzanineEventTrapReset[iseq];}
    Instance.anyMezzanineApplicationMissing = data->anyMezzanineApplicationMissing;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineApplicationMissing[iseq] = data->mezzanineApplicationMissing[iseq];}
    Instance.anyMezzanineApplicationCRCMismatch = data->anyMezzanineApplicationCRCMismatch;
    for (int iseq=0;iseq<156;iseq++) {Instance.mezzanineApplicationCRCMismatch[iseq] = data->mezzanineApplicationCRCMismatch[iseq];}
    Instance.anyILCFault = data->anyILCFault;
    for (int iseq=0;iseq<156;iseq++) {Instance.ilcFault[iseq] = data->ilcFault[iseq];}
    Instance.anyBroadcastCounterWarning = data->anyBroadcastCounterWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.broadcastCounterWarning[iseq] = data->broadcastCounterWarning[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceActuatorWarning_34b69bc9 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceActuatorWarning_34b69bc9DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_forceActuatorWarning(MTM1M3_logevent_forceActuatorWarningC *data)
{
  MTM1M3::logevent_forceActuatorWarning_34b69bc9Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_forceActuatorWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceActuatorWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader_var SALReader = MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_forceActuatorWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyWarning = Instances[j].anyWarning;
    data->anyMajorFault = Instances[j].anyMajorFault;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMajorFault = Instances[j].anyMajorFault;
    for (int iseq=0;iseq<156;iseq++) {data->majorFault[iseq] = Instances[j].majorFault[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.majorFault[iseq] = Instances[j].majorFault[iseq];}
    data->anyMinorFault = Instances[j].anyMinorFault;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMinorFault = Instances[j].anyMinorFault;
    for (int iseq=0;iseq<156;iseq++) {data->minorFault[iseq] = Instances[j].minorFault[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.minorFault[iseq] = Instances[j].minorFault[iseq];}
    data->anyFaultOverride = Instances[j].anyFaultOverride;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyFaultOverride = Instances[j].anyFaultOverride;
    for (int iseq=0;iseq<156;iseq++) {data->faultOverride[iseq] = Instances[j].faultOverride[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.faultOverride[iseq] = Instances[j].faultOverride[iseq];}
    data->anyMainCalibrationError = Instances[j].anyMainCalibrationError;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMainCalibrationError = Instances[j].anyMainCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {data->mainCalibrationError[iseq] = Instances[j].mainCalibrationError[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mainCalibrationError[iseq] = Instances[j].mainCalibrationError[iseq];}
    data->anyBackupCalibrationError = Instances[j].anyBackupCalibrationError;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyBackupCalibrationError = Instances[j].anyBackupCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {data->backupCalibrationError[iseq] = Instances[j].backupCalibrationError[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.backupCalibrationError[iseq] = Instances[j].backupCalibrationError[iseq];}
    data->anyMezzanineError = Instances[j].anyMezzanineError;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineError = Instances[j].anyMezzanineError;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineError[iseq] = Instances[j].mezzanineError[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineError[iseq] = Instances[j].mezzanineError[iseq];}
    data->anyMezzanineBootloaderActive = Instances[j].anyMezzanineBootloaderActive;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineBootloaderActive = Instances[j].anyMezzanineBootloaderActive;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineBootloaderActive[iseq] = Instances[j].mezzanineBootloaderActive[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineBootloaderActive[iseq] = Instances[j].mezzanineBootloaderActive[iseq];}
    data->anyUniqueIdCRCError = Instances[j].anyUniqueIdCRCError;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyUniqueIdCRCError = Instances[j].anyUniqueIdCRCError;
    for (int iseq=0;iseq<156;iseq++) {data->uniqueIdCRCError[iseq] = Instances[j].uniqueIdCRCError[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.uniqueIdCRCError[iseq] = Instances[j].uniqueIdCRCError[iseq];}
    data->anyApplicationTypeMismatch = Instances[j].anyApplicationTypeMismatch;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyApplicationTypeMismatch = Instances[j].anyApplicationTypeMismatch;
    for (int iseq=0;iseq<156;iseq++) {data->applicationTypeMismatch[iseq] = Instances[j].applicationTypeMismatch[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.applicationTypeMismatch[iseq] = Instances[j].applicationTypeMismatch[iseq];}
    data->anyApplicationMissing = Instances[j].anyApplicationMissing;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyApplicationMissing = Instances[j].anyApplicationMissing;
    for (int iseq=0;iseq<156;iseq++) {data->applicationMissing[iseq] = Instances[j].applicationMissing[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.applicationMissing[iseq] = Instances[j].applicationMissing[iseq];}
    data->anyApplicationCRCMismatch = Instances[j].anyApplicationCRCMismatch;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyApplicationCRCMismatch = Instances[j].anyApplicationCRCMismatch;
    for (int iseq=0;iseq<156;iseq++) {data->applicationCRCMismatch[iseq] = Instances[j].applicationCRCMismatch[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.applicationCRCMismatch[iseq] = Instances[j].applicationCRCMismatch[iseq];}
    data->anyOneWireMissing = Instances[j].anyOneWireMissing;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyOneWireMissing = Instances[j].anyOneWireMissing;
    for (int iseq=0;iseq<156;iseq++) {data->oneWireMissing[iseq] = Instances[j].oneWireMissing[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.oneWireMissing[iseq] = Instances[j].oneWireMissing[iseq];}
    data->anyOneWire1Mismatch = Instances[j].anyOneWire1Mismatch;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyOneWire1Mismatch = Instances[j].anyOneWire1Mismatch;
    for (int iseq=0;iseq<156;iseq++) {data->oneWire1Mismatch[iseq] = Instances[j].oneWire1Mismatch[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.oneWire1Mismatch[iseq] = Instances[j].oneWire1Mismatch[iseq];}
    data->anyOneWire2Mismatch = Instances[j].anyOneWire2Mismatch;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyOneWire2Mismatch = Instances[j].anyOneWire2Mismatch;
    for (int iseq=0;iseq<156;iseq++) {data->oneWire2Mismatch[iseq] = Instances[j].oneWire2Mismatch[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.oneWire2Mismatch[iseq] = Instances[j].oneWire2Mismatch[iseq];}
    data->anyWatchdogReset = Instances[j].anyWatchdogReset;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyWatchdogReset = Instances[j].anyWatchdogReset;
    for (int iseq=0;iseq<156;iseq++) {data->watchdogReset[iseq] = Instances[j].watchdogReset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.watchdogReset[iseq] = Instances[j].watchdogReset[iseq];}
    data->anyBrownOut = Instances[j].anyBrownOut;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyBrownOut = Instances[j].anyBrownOut;
    for (int iseq=0;iseq<156;iseq++) {data->brownOut[iseq] = Instances[j].brownOut[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.brownOut[iseq] = Instances[j].brownOut[iseq];}
    data->anyEventTrapReset = Instances[j].anyEventTrapReset;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyEventTrapReset = Instances[j].anyEventTrapReset;
    for (int iseq=0;iseq<156;iseq++) {data->eventTrapReset[iseq] = Instances[j].eventTrapReset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.eventTrapReset[iseq] = Instances[j].eventTrapReset[iseq];}
    data->anySSRPowerFault = Instances[j].anySSRPowerFault;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anySSRPowerFault = Instances[j].anySSRPowerFault;
    for (int iseq=0;iseq<156;iseq++) {data->ssrPowerFault[iseq] = Instances[j].ssrPowerFault[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.ssrPowerFault[iseq] = Instances[j].ssrPowerFault[iseq];}
    data->anyAuxPowerFault = Instances[j].anyAuxPowerFault;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyAuxPowerFault = Instances[j].anyAuxPowerFault;
    for (int iseq=0;iseq<156;iseq++) {data->auxPowerFault[iseq] = Instances[j].auxPowerFault[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.auxPowerFault[iseq] = Instances[j].auxPowerFault[iseq];}
    data->anyMezzaninePowerFault = Instances[j].anyMezzaninePowerFault;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzaninePowerFault = Instances[j].anyMezzaninePowerFault;
    for (int iseq=0;iseq<156;iseq++) {data->mezzaninePowerFault[iseq] = Instances[j].mezzaninePowerFault[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzaninePowerFault[iseq] = Instances[j].mezzaninePowerFault[iseq];}
    data->anyMezzanineCurrentAmp1Fault = Instances[j].anyMezzanineCurrentAmp1Fault;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineCurrentAmp1Fault = Instances[j].anyMezzanineCurrentAmp1Fault;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineCurrentAmp1Fault[iseq] = Instances[j].mezzanineCurrentAmp1Fault[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineCurrentAmp1Fault[iseq] = Instances[j].mezzanineCurrentAmp1Fault[iseq];}
    data->anyMezzanineCurrentAmp2Fault = Instances[j].anyMezzanineCurrentAmp2Fault;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineCurrentAmp2Fault = Instances[j].anyMezzanineCurrentAmp2Fault;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineCurrentAmp2Fault[iseq] = Instances[j].mezzanineCurrentAmp2Fault[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineCurrentAmp2Fault[iseq] = Instances[j].mezzanineCurrentAmp2Fault[iseq];}
    data->anyMezzanineUniqueIdCRCError = Instances[j].anyMezzanineUniqueIdCRCError;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineUniqueIdCRCError = Instances[j].anyMezzanineUniqueIdCRCError;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineUniqueIdCRCError[iseq] = Instances[j].mezzanineUniqueIdCRCError[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineUniqueIdCRCError[iseq] = Instances[j].mezzanineUniqueIdCRCError[iseq];}
    data->anyMezzanineMainCalibrationError = Instances[j].anyMezzanineMainCalibrationError;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineMainCalibrationError = Instances[j].anyMezzanineMainCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineMainCalibrationError[iseq] = Instances[j].mezzanineMainCalibrationError[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineMainCalibrationError[iseq] = Instances[j].mezzanineMainCalibrationError[iseq];}
    data->anyMezzanineBackupCalibrationError = Instances[j].anyMezzanineBackupCalibrationError;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineBackupCalibrationError = Instances[j].anyMezzanineBackupCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineBackupCalibrationError[iseq] = Instances[j].mezzanineBackupCalibrationError[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineBackupCalibrationError[iseq] = Instances[j].mezzanineBackupCalibrationError[iseq];}
    data->anyMezzanineEventTrapReset = Instances[j].anyMezzanineEventTrapReset;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineEventTrapReset = Instances[j].anyMezzanineEventTrapReset;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineEventTrapReset[iseq] = Instances[j].mezzanineEventTrapReset[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineEventTrapReset[iseq] = Instances[j].mezzanineEventTrapReset[iseq];}
    data->anyMezzanineApplicationMissing = Instances[j].anyMezzanineApplicationMissing;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineApplicationMissing = Instances[j].anyMezzanineApplicationMissing;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineApplicationMissing[iseq] = Instances[j].mezzanineApplicationMissing[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineApplicationMissing[iseq] = Instances[j].mezzanineApplicationMissing[iseq];}
    data->anyMezzanineApplicationCRCMismatch = Instances[j].anyMezzanineApplicationCRCMismatch;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineApplicationCRCMismatch = Instances[j].anyMezzanineApplicationCRCMismatch;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineApplicationCRCMismatch[iseq] = Instances[j].mezzanineApplicationCRCMismatch[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineApplicationCRCMismatch[iseq] = Instances[j].mezzanineApplicationCRCMismatch[iseq];}
    data->anyILCFault = Instances[j].anyILCFault;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyILCFault = Instances[j].anyILCFault;
    for (int iseq=0;iseq<156;iseq++) {data->ilcFault[iseq] = Instances[j].ilcFault[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.ilcFault[iseq] = Instances[j].ilcFault[iseq];}
    data->anyBroadcastCounterWarning = Instances[j].anyBroadcastCounterWarning;
    lastSample_MTM1M3_logevent_forceActuatorWarning.anyBroadcastCounterWarning = Instances[j].anyBroadcastCounterWarning;
    for (int iseq=0;iseq<156;iseq++) {data->broadcastCounterWarning[iseq] = Instances[j].broadcastCounterWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceActuatorWarning.broadcastCounterWarning[iseq] = Instances[j].broadcastCounterWarning[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_forceActuatorWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_forceActuatorWarning_34b69bc9DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_forceActuatorWarning(MTM1M3_logevent_forceActuatorWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_forceActuatorWarning(data);
    sal[SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_forceActuatorWarning(MTM1M3_logevent_forceActuatorWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_forceActuatorWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_forceActuatorWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_forceActuatorWarning.anyWarning;
   data->anyMajorFault = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMajorFault;
    for (int iseq=0;iseq<156;iseq++) {data->majorFault[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.majorFault[iseq];}
   data->anyMinorFault = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMinorFault;
    for (int iseq=0;iseq<156;iseq++) {data->minorFault[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.minorFault[iseq];}
   data->anyFaultOverride = lastSample_MTM1M3_logevent_forceActuatorWarning.anyFaultOverride;
    for (int iseq=0;iseq<156;iseq++) {data->faultOverride[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.faultOverride[iseq];}
   data->anyMainCalibrationError = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMainCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {data->mainCalibrationError[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mainCalibrationError[iseq];}
   data->anyBackupCalibrationError = lastSample_MTM1M3_logevent_forceActuatorWarning.anyBackupCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {data->backupCalibrationError[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.backupCalibrationError[iseq];}
   data->anyMezzanineError = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineError;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineError[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineError[iseq];}
   data->anyMezzanineBootloaderActive = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineBootloaderActive;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineBootloaderActive[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineBootloaderActive[iseq];}
   data->anyUniqueIdCRCError = lastSample_MTM1M3_logevent_forceActuatorWarning.anyUniqueIdCRCError;
    for (int iseq=0;iseq<156;iseq++) {data->uniqueIdCRCError[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.uniqueIdCRCError[iseq];}
   data->anyApplicationTypeMismatch = lastSample_MTM1M3_logevent_forceActuatorWarning.anyApplicationTypeMismatch;
    for (int iseq=0;iseq<156;iseq++) {data->applicationTypeMismatch[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.applicationTypeMismatch[iseq];}
   data->anyApplicationMissing = lastSample_MTM1M3_logevent_forceActuatorWarning.anyApplicationMissing;
    for (int iseq=0;iseq<156;iseq++) {data->applicationMissing[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.applicationMissing[iseq];}
   data->anyApplicationCRCMismatch = lastSample_MTM1M3_logevent_forceActuatorWarning.anyApplicationCRCMismatch;
    for (int iseq=0;iseq<156;iseq++) {data->applicationCRCMismatch[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.applicationCRCMismatch[iseq];}
   data->anyOneWireMissing = lastSample_MTM1M3_logevent_forceActuatorWarning.anyOneWireMissing;
    for (int iseq=0;iseq<156;iseq++) {data->oneWireMissing[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.oneWireMissing[iseq];}
   data->anyOneWire1Mismatch = lastSample_MTM1M3_logevent_forceActuatorWarning.anyOneWire1Mismatch;
    for (int iseq=0;iseq<156;iseq++) {data->oneWire1Mismatch[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.oneWire1Mismatch[iseq];}
   data->anyOneWire2Mismatch = lastSample_MTM1M3_logevent_forceActuatorWarning.anyOneWire2Mismatch;
    for (int iseq=0;iseq<156;iseq++) {data->oneWire2Mismatch[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.oneWire2Mismatch[iseq];}
   data->anyWatchdogReset = lastSample_MTM1M3_logevent_forceActuatorWarning.anyWatchdogReset;
    for (int iseq=0;iseq<156;iseq++) {data->watchdogReset[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.watchdogReset[iseq];}
   data->anyBrownOut = lastSample_MTM1M3_logevent_forceActuatorWarning.anyBrownOut;
    for (int iseq=0;iseq<156;iseq++) {data->brownOut[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.brownOut[iseq];}
   data->anyEventTrapReset = lastSample_MTM1M3_logevent_forceActuatorWarning.anyEventTrapReset;
    for (int iseq=0;iseq<156;iseq++) {data->eventTrapReset[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.eventTrapReset[iseq];}
   data->anySSRPowerFault = lastSample_MTM1M3_logevent_forceActuatorWarning.anySSRPowerFault;
    for (int iseq=0;iseq<156;iseq++) {data->ssrPowerFault[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.ssrPowerFault[iseq];}
   data->anyAuxPowerFault = lastSample_MTM1M3_logevent_forceActuatorWarning.anyAuxPowerFault;
    for (int iseq=0;iseq<156;iseq++) {data->auxPowerFault[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.auxPowerFault[iseq];}
   data->anyMezzaninePowerFault = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzaninePowerFault;
    for (int iseq=0;iseq<156;iseq++) {data->mezzaninePowerFault[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzaninePowerFault[iseq];}
   data->anyMezzanineCurrentAmp1Fault = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineCurrentAmp1Fault;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineCurrentAmp1Fault[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineCurrentAmp1Fault[iseq];}
   data->anyMezzanineCurrentAmp2Fault = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineCurrentAmp2Fault;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineCurrentAmp2Fault[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineCurrentAmp2Fault[iseq];}
   data->anyMezzanineUniqueIdCRCError = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineUniqueIdCRCError;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineUniqueIdCRCError[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineUniqueIdCRCError[iseq];}
   data->anyMezzanineMainCalibrationError = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineMainCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineMainCalibrationError[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineMainCalibrationError[iseq];}
   data->anyMezzanineBackupCalibrationError = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineBackupCalibrationError;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineBackupCalibrationError[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineBackupCalibrationError[iseq];}
   data->anyMezzanineEventTrapReset = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineEventTrapReset;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineEventTrapReset[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineEventTrapReset[iseq];}
   data->anyMezzanineApplicationMissing = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineApplicationMissing;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineApplicationMissing[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineApplicationMissing[iseq];}
   data->anyMezzanineApplicationCRCMismatch = lastSample_MTM1M3_logevent_forceActuatorWarning.anyMezzanineApplicationCRCMismatch;
    for (int iseq=0;iseq<156;iseq++) {data->mezzanineApplicationCRCMismatch[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.mezzanineApplicationCRCMismatch[iseq];}
   data->anyILCFault = lastSample_MTM1M3_logevent_forceActuatorWarning.anyILCFault;
    for (int iseq=0;iseq<156;iseq++) {data->ilcFault[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.ilcFault[iseq];}
   data->anyBroadcastCounterWarning = lastSample_MTM1M3_logevent_forceActuatorWarning.anyBroadcastCounterWarning;
    for (int iseq=0;iseq<156;iseq++) {data->broadcastCounterWarning[iseq] = lastSample_MTM1M3_logevent_forceActuatorWarning.broadcastCounterWarning[iseq];}
   data->priority = lastSample_MTM1M3_logevent_forceActuatorWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_forceActuatorWarning(MTM1M3_logevent_forceActuatorWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_forceActuatorWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_forceSetpointWarning_34a43cf6 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceSetpointWarning");
  }
  MTM1M3::logevent_forceSetpointWarning_34a43cf6DataWriter_var SALWriter = MTM1M3::logevent_forceSetpointWarning_34a43cf6DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("34a43cf6");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceSetpointWarning_34a43cf6 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceSetpointWarning_34a43cf6DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_forceSetpointWarning_34a43cf6Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceSetpointWarning");
  }
  MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader_var SALReader = MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_forceSetpointWarning(MTM1M3_logevent_forceSetpointWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_forceSetpointWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_forceSetpointWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceSetpointWarning_34a43cf6DataWriter_var SALWriter = MTM1M3::logevent_forceSetpointWarning_34a43cf6DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_forceSetpointWarning_34a43cf6 Instance;

  Instance.private_revCode = DDS::string_dup("34a43cf6");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.anySafetyLimitWarning = data->anySafetyLimitWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.safetyLimitWarning[iseq] = data->safetyLimitWarning[iseq];}
    Instance.xMomentWarning = data->xMomentWarning;
    Instance.yMomentWarning = data->yMomentWarning;
    Instance.zMomentWarning = data->zMomentWarning;
    Instance.anyNearNeighborWarning = data->anyNearNeighborWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.nearNeighborWarning[iseq] = data->nearNeighborWarning[iseq];}
    Instance.magnitudeWarning = data->magnitudeWarning;
    Instance.anyFarNeighborWarning = data->anyFarNeighborWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.farNeighborWarning[iseq] = data->farNeighborWarning[iseq];}
    Instance.anyElevationForceWarning = data->anyElevationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.elevationForceWarning[iseq] = data->elevationForceWarning[iseq];}
    Instance.anyAzimuthForceWarning = data->anyAzimuthForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.azimuthForceWarning[iseq] = data->azimuthForceWarning[iseq];}
    Instance.anyThermalForceWarning = data->anyThermalForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.thermalForceWarning[iseq] = data->thermalForceWarning[iseq];}
    Instance.anyBalanceForceWarning = data->anyBalanceForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.balanceForceWarning[iseq] = data->balanceForceWarning[iseq];}
    Instance.anyAccelerationForceWarning = data->anyAccelerationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.accelerationForceWarning[iseq] = data->accelerationForceWarning[iseq];}
    Instance.activeOpticNetForceWarning = data->activeOpticNetForceWarning;
    Instance.anyActiveOpticForceWarning = data->anyActiveOpticForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.activeOpticForceWarning[iseq] = data->activeOpticForceWarning[iseq];}
    Instance.anyStaticForceWarning = data->anyStaticForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.staticForceWarning[iseq] = data->staticForceWarning[iseq];}
    Instance.aberrationNetForceWarning = data->aberrationNetForceWarning;
    Instance.anyAberrationForceWarning = data->anyAberrationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.aberrationForceWarning[iseq] = data->aberrationForceWarning[iseq];}
    Instance.anyOffsetForceWarning = data->anyOffsetForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.offsetForceWarning[iseq] = data->offsetForceWarning[iseq];}
    Instance.anyVelocityForceWarning = data->anyVelocityForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.velocityForceWarning[iseq] = data->velocityForceWarning[iseq];}
    Instance.anyForceWarning = data->anyForceWarning;
    for (int iseq=0;iseq<156;iseq++) {Instance.forceWarning[iseq] = data->forceWarning[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_forceSetpointWarning_34a43cf6 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_forceSetpointWarning_34a43cf6DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_forceSetpointWarning(MTM1M3_logevent_forceSetpointWarningC *data)
{
  MTM1M3::logevent_forceSetpointWarning_34a43cf6Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_forceSetpointWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_forceSetpointWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader_var SALReader = MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_forceSetpointWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyWarning = Instances[j].anyWarning;
    data->anySafetyLimitWarning = Instances[j].anySafetyLimitWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anySafetyLimitWarning = Instances[j].anySafetyLimitWarning;
    for (int iseq=0;iseq<156;iseq++) {data->safetyLimitWarning[iseq] = Instances[j].safetyLimitWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.safetyLimitWarning[iseq] = Instances[j].safetyLimitWarning[iseq];}
    data->xMomentWarning = Instances[j].xMomentWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.xMomentWarning = Instances[j].xMomentWarning;
    data->yMomentWarning = Instances[j].yMomentWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.yMomentWarning = Instances[j].yMomentWarning;
    data->zMomentWarning = Instances[j].zMomentWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.zMomentWarning = Instances[j].zMomentWarning;
    data->anyNearNeighborWarning = Instances[j].anyNearNeighborWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyNearNeighborWarning = Instances[j].anyNearNeighborWarning;
    for (int iseq=0;iseq<156;iseq++) {data->nearNeighborWarning[iseq] = Instances[j].nearNeighborWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.nearNeighborWarning[iseq] = Instances[j].nearNeighborWarning[iseq];}
    data->magnitudeWarning = Instances[j].magnitudeWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.magnitudeWarning = Instances[j].magnitudeWarning;
    data->anyFarNeighborWarning = Instances[j].anyFarNeighborWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyFarNeighborWarning = Instances[j].anyFarNeighborWarning;
    for (int iseq=0;iseq<156;iseq++) {data->farNeighborWarning[iseq] = Instances[j].farNeighborWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.farNeighborWarning[iseq] = Instances[j].farNeighborWarning[iseq];}
    data->anyElevationForceWarning = Instances[j].anyElevationForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyElevationForceWarning = Instances[j].anyElevationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->elevationForceWarning[iseq] = Instances[j].elevationForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.elevationForceWarning[iseq] = Instances[j].elevationForceWarning[iseq];}
    data->anyAzimuthForceWarning = Instances[j].anyAzimuthForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyAzimuthForceWarning = Instances[j].anyAzimuthForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->azimuthForceWarning[iseq] = Instances[j].azimuthForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.azimuthForceWarning[iseq] = Instances[j].azimuthForceWarning[iseq];}
    data->anyThermalForceWarning = Instances[j].anyThermalForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyThermalForceWarning = Instances[j].anyThermalForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->thermalForceWarning[iseq] = Instances[j].thermalForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.thermalForceWarning[iseq] = Instances[j].thermalForceWarning[iseq];}
    data->anyBalanceForceWarning = Instances[j].anyBalanceForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyBalanceForceWarning = Instances[j].anyBalanceForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->balanceForceWarning[iseq] = Instances[j].balanceForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.balanceForceWarning[iseq] = Instances[j].balanceForceWarning[iseq];}
    data->anyAccelerationForceWarning = Instances[j].anyAccelerationForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyAccelerationForceWarning = Instances[j].anyAccelerationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->accelerationForceWarning[iseq] = Instances[j].accelerationForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.accelerationForceWarning[iseq] = Instances[j].accelerationForceWarning[iseq];}
    data->activeOpticNetForceWarning = Instances[j].activeOpticNetForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.activeOpticNetForceWarning = Instances[j].activeOpticNetForceWarning;
    data->anyActiveOpticForceWarning = Instances[j].anyActiveOpticForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyActiveOpticForceWarning = Instances[j].anyActiveOpticForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->activeOpticForceWarning[iseq] = Instances[j].activeOpticForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.activeOpticForceWarning[iseq] = Instances[j].activeOpticForceWarning[iseq];}
    data->anyStaticForceWarning = Instances[j].anyStaticForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyStaticForceWarning = Instances[j].anyStaticForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->staticForceWarning[iseq] = Instances[j].staticForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.staticForceWarning[iseq] = Instances[j].staticForceWarning[iseq];}
    data->aberrationNetForceWarning = Instances[j].aberrationNetForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.aberrationNetForceWarning = Instances[j].aberrationNetForceWarning;
    data->anyAberrationForceWarning = Instances[j].anyAberrationForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyAberrationForceWarning = Instances[j].anyAberrationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->aberrationForceWarning[iseq] = Instances[j].aberrationForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.aberrationForceWarning[iseq] = Instances[j].aberrationForceWarning[iseq];}
    data->anyOffsetForceWarning = Instances[j].anyOffsetForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyOffsetForceWarning = Instances[j].anyOffsetForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->offsetForceWarning[iseq] = Instances[j].offsetForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.offsetForceWarning[iseq] = Instances[j].offsetForceWarning[iseq];}
    data->anyVelocityForceWarning = Instances[j].anyVelocityForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyVelocityForceWarning = Instances[j].anyVelocityForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->velocityForceWarning[iseq] = Instances[j].velocityForceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.velocityForceWarning[iseq] = Instances[j].velocityForceWarning[iseq];}
    data->anyForceWarning = Instances[j].anyForceWarning;
    lastSample_MTM1M3_logevent_forceSetpointWarning.anyForceWarning = Instances[j].anyForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->forceWarning[iseq] = Instances[j].forceWarning[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_forceSetpointWarning.forceWarning[iseq] = Instances[j].forceWarning[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_forceSetpointWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_forceSetpointWarning_34a43cf6DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_forceSetpointWarning(MTM1M3_logevent_forceSetpointWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_forceSetpointWarning(data);
    sal[SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_forceSetpointWarning(MTM1M3_logevent_forceSetpointWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_forceSetpointWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_forceSetpointWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyWarning;
   data->anySafetyLimitWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anySafetyLimitWarning;
    for (int iseq=0;iseq<156;iseq++) {data->safetyLimitWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.safetyLimitWarning[iseq];}
   data->xMomentWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.xMomentWarning;
   data->yMomentWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.yMomentWarning;
   data->zMomentWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.zMomentWarning;
   data->anyNearNeighborWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyNearNeighborWarning;
    for (int iseq=0;iseq<156;iseq++) {data->nearNeighborWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.nearNeighborWarning[iseq];}
   data->magnitudeWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.magnitudeWarning;
   data->anyFarNeighborWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyFarNeighborWarning;
    for (int iseq=0;iseq<156;iseq++) {data->farNeighborWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.farNeighborWarning[iseq];}
   data->anyElevationForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyElevationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->elevationForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.elevationForceWarning[iseq];}
   data->anyAzimuthForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyAzimuthForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->azimuthForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.azimuthForceWarning[iseq];}
   data->anyThermalForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyThermalForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->thermalForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.thermalForceWarning[iseq];}
   data->anyBalanceForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyBalanceForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->balanceForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.balanceForceWarning[iseq];}
   data->anyAccelerationForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyAccelerationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->accelerationForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.accelerationForceWarning[iseq];}
   data->activeOpticNetForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.activeOpticNetForceWarning;
   data->anyActiveOpticForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyActiveOpticForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->activeOpticForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.activeOpticForceWarning[iseq];}
   data->anyStaticForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyStaticForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->staticForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.staticForceWarning[iseq];}
   data->aberrationNetForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.aberrationNetForceWarning;
   data->anyAberrationForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyAberrationForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->aberrationForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.aberrationForceWarning[iseq];}
   data->anyOffsetForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyOffsetForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->offsetForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.offsetForceWarning[iseq];}
   data->anyVelocityForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyVelocityForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->velocityForceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.velocityForceWarning[iseq];}
   data->anyForceWarning = lastSample_MTM1M3_logevent_forceSetpointWarning.anyForceWarning;
    for (int iseq=0;iseq<156;iseq++) {data->forceWarning[iseq] = lastSample_MTM1M3_logevent_forceSetpointWarning.forceWarning[iseq];}
   data->priority = lastSample_MTM1M3_logevent_forceSetpointWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_forceSetpointWarning(MTM1M3_logevent_forceSetpointWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_forceSetpointWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_gyroWarning_07c44e13 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_gyroWarning");
  }
  MTM1M3::logevent_gyroWarning_07c44e13DataWriter_var SALWriter = MTM1M3::logevent_gyroWarning_07c44e13DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("07c44e13");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_gyroWarning_07c44e13 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_gyroWarning_07c44e13DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_gyroWarning_07c44e13Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_gyroWarning");
  }
  MTM1M3::logevent_gyroWarning_07c44e13DataReader_var SALReader = MTM1M3::logevent_gyroWarning_07c44e13DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_gyroWarning_07c44e13DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_gyroWarning_07c44e13DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_gyroWarning_07c44e13DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_gyroWarning(MTM1M3_logevent_gyroWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_gyroWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_gyroWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_gyroWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_gyroWarning_07c44e13DataWriter_var SALWriter = MTM1M3::logevent_gyroWarning_07c44e13DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_gyroWarning_07c44e13 Instance;

  Instance.private_revCode = DDS::string_dup("07c44e13");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.gyroXStatusWarning = data->gyroXStatusWarning;
    Instance.gyroYStatusWarning = data->gyroYStatusWarning;
    Instance.gyroZStatusWarning = data->gyroZStatusWarning;
    Instance.sequenceNumberWarning = data->sequenceNumberWarning;
    Instance.crcMismatchWarning = data->crcMismatchWarning;
    Instance.invalidLengthWarning = data->invalidLengthWarning;
    Instance.invalidHeaderWarning = data->invalidHeaderWarning;
    Instance.incompleteFrameWarning = data->incompleteFrameWarning;
    Instance.gyroXSLDWarning = data->gyroXSLDWarning;
    Instance.gyroXMODDACWarning = data->gyroXMODDACWarning;
    Instance.gyroXPhaseWarning = data->gyroXPhaseWarning;
    Instance.gyroXFlashWarning = data->gyroXFlashWarning;
    Instance.gyroYSLDWarning = data->gyroYSLDWarning;
    Instance.gyroYMODDACWarning = data->gyroYMODDACWarning;
    Instance.gyroYPhaseWarning = data->gyroYPhaseWarning;
    Instance.gyroYFlashWarning = data->gyroYFlashWarning;
    Instance.gyroZSLDWarning = data->gyroZSLDWarning;
    Instance.gyroZMODDACWarning = data->gyroZMODDACWarning;
    Instance.gyroZPhaseWarning = data->gyroZPhaseWarning;
    Instance.gyroZFlashWarning = data->gyroZFlashWarning;
    Instance.gyroXSLDTemperatureStatusWarning = data->gyroXSLDTemperatureStatusWarning;
    Instance.gyroYSLDTemperatureStatusWarning = data->gyroYSLDTemperatureStatusWarning;
    Instance.gyroZSLDTemperatureStatusWarning = data->gyroZSLDTemperatureStatusWarning;
    Instance.gcbTemperatureStatusWarning = data->gcbTemperatureStatusWarning;
    Instance.temperatureStatusWarning = data->temperatureStatusWarning;
    Instance.gcbDSPSPIFlashStatusWarning = data->gcbDSPSPIFlashStatusWarning;
    Instance.gcbFPGASPIFlashStatusWarning = data->gcbFPGASPIFlashStatusWarning;
    Instance.dspSPIFlashStatusWarning = data->dspSPIFlashStatusWarning;
    Instance.fpgaSPIFlashStatusWarning = data->fpgaSPIFlashStatusWarning;
    Instance.gcb1_2VStatusWarning = data->gcb1_2VStatusWarning;
    Instance.gcb3_3VStatusWarning = data->gcb3_3VStatusWarning;
    Instance.gcb5VStatusWarning = data->gcb5VStatusWarning;
    Instance.v1_2StatusWarning = data->v1_2StatusWarning;
    Instance.v3_3StatusWarning = data->v3_3StatusWarning;
    Instance.v5StatusWarning = data->v5StatusWarning;
    Instance.gcbFPGAStatusWarning = data->gcbFPGAStatusWarning;
    Instance.fpgaStatusWarning = data->fpgaStatusWarning;
    Instance.hiSpeedSPORTStatusWarning = data->hiSpeedSPORTStatusWarning;
    Instance.auxSPORTStatusWarning = data->auxSPORTStatusWarning;
    Instance.sufficientSoftwareResourcesWarning = data->sufficientSoftwareResourcesWarning;
    Instance.gyroEOVoltsPositiveWarning = data->gyroEOVoltsPositiveWarning;
    Instance.gyroEOVoltsNegativeWarning = data->gyroEOVoltsNegativeWarning;
    Instance.gyroXVoltsWarning = data->gyroXVoltsWarning;
    Instance.gyroYVoltsWarning = data->gyroYVoltsWarning;
    Instance.gyroZVoltsWarning = data->gyroZVoltsWarning;
    Instance.gcbADCCommsWarning = data->gcbADCCommsWarning;
    Instance.mSYNCExternalTimingWarning = data->mSYNCExternalTimingWarning;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_gyroWarning_07c44e13 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_gyroWarning_07c44e13DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_gyroWarning(MTM1M3_logevent_gyroWarningC *data)
{
  MTM1M3::logevent_gyroWarning_07c44e13Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_gyroWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_gyroWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_gyroWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_gyroWarning_07c44e13DataReader_var SALReader = MTM1M3::logevent_gyroWarning_07c44e13DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_gyroWarning_07c44e13DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_gyroWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_gyroWarning_07c44e13DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_gyroWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_gyroWarning.anyWarning = Instances[j].anyWarning;
    data->gyroXStatusWarning = Instances[j].gyroXStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroXStatusWarning = Instances[j].gyroXStatusWarning;
    data->gyroYStatusWarning = Instances[j].gyroYStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroYStatusWarning = Instances[j].gyroYStatusWarning;
    data->gyroZStatusWarning = Instances[j].gyroZStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroZStatusWarning = Instances[j].gyroZStatusWarning;
    data->sequenceNumberWarning = Instances[j].sequenceNumberWarning;
    lastSample_MTM1M3_logevent_gyroWarning.sequenceNumberWarning = Instances[j].sequenceNumberWarning;
    data->crcMismatchWarning = Instances[j].crcMismatchWarning;
    lastSample_MTM1M3_logevent_gyroWarning.crcMismatchWarning = Instances[j].crcMismatchWarning;
    data->invalidLengthWarning = Instances[j].invalidLengthWarning;
    lastSample_MTM1M3_logevent_gyroWarning.invalidLengthWarning = Instances[j].invalidLengthWarning;
    data->invalidHeaderWarning = Instances[j].invalidHeaderWarning;
    lastSample_MTM1M3_logevent_gyroWarning.invalidHeaderWarning = Instances[j].invalidHeaderWarning;
    data->incompleteFrameWarning = Instances[j].incompleteFrameWarning;
    lastSample_MTM1M3_logevent_gyroWarning.incompleteFrameWarning = Instances[j].incompleteFrameWarning;
    data->gyroXSLDWarning = Instances[j].gyroXSLDWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroXSLDWarning = Instances[j].gyroXSLDWarning;
    data->gyroXMODDACWarning = Instances[j].gyroXMODDACWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroXMODDACWarning = Instances[j].gyroXMODDACWarning;
    data->gyroXPhaseWarning = Instances[j].gyroXPhaseWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroXPhaseWarning = Instances[j].gyroXPhaseWarning;
    data->gyroXFlashWarning = Instances[j].gyroXFlashWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroXFlashWarning = Instances[j].gyroXFlashWarning;
    data->gyroYSLDWarning = Instances[j].gyroYSLDWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroYSLDWarning = Instances[j].gyroYSLDWarning;
    data->gyroYMODDACWarning = Instances[j].gyroYMODDACWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroYMODDACWarning = Instances[j].gyroYMODDACWarning;
    data->gyroYPhaseWarning = Instances[j].gyroYPhaseWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroYPhaseWarning = Instances[j].gyroYPhaseWarning;
    data->gyroYFlashWarning = Instances[j].gyroYFlashWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroYFlashWarning = Instances[j].gyroYFlashWarning;
    data->gyroZSLDWarning = Instances[j].gyroZSLDWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroZSLDWarning = Instances[j].gyroZSLDWarning;
    data->gyroZMODDACWarning = Instances[j].gyroZMODDACWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroZMODDACWarning = Instances[j].gyroZMODDACWarning;
    data->gyroZPhaseWarning = Instances[j].gyroZPhaseWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroZPhaseWarning = Instances[j].gyroZPhaseWarning;
    data->gyroZFlashWarning = Instances[j].gyroZFlashWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroZFlashWarning = Instances[j].gyroZFlashWarning;
    data->gyroXSLDTemperatureStatusWarning = Instances[j].gyroXSLDTemperatureStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroXSLDTemperatureStatusWarning = Instances[j].gyroXSLDTemperatureStatusWarning;
    data->gyroYSLDTemperatureStatusWarning = Instances[j].gyroYSLDTemperatureStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroYSLDTemperatureStatusWarning = Instances[j].gyroYSLDTemperatureStatusWarning;
    data->gyroZSLDTemperatureStatusWarning = Instances[j].gyroZSLDTemperatureStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroZSLDTemperatureStatusWarning = Instances[j].gyroZSLDTemperatureStatusWarning;
    data->gcbTemperatureStatusWarning = Instances[j].gcbTemperatureStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gcbTemperatureStatusWarning = Instances[j].gcbTemperatureStatusWarning;
    data->temperatureStatusWarning = Instances[j].temperatureStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.temperatureStatusWarning = Instances[j].temperatureStatusWarning;
    data->gcbDSPSPIFlashStatusWarning = Instances[j].gcbDSPSPIFlashStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gcbDSPSPIFlashStatusWarning = Instances[j].gcbDSPSPIFlashStatusWarning;
    data->gcbFPGASPIFlashStatusWarning = Instances[j].gcbFPGASPIFlashStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gcbFPGASPIFlashStatusWarning = Instances[j].gcbFPGASPIFlashStatusWarning;
    data->dspSPIFlashStatusWarning = Instances[j].dspSPIFlashStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.dspSPIFlashStatusWarning = Instances[j].dspSPIFlashStatusWarning;
    data->fpgaSPIFlashStatusWarning = Instances[j].fpgaSPIFlashStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.fpgaSPIFlashStatusWarning = Instances[j].fpgaSPIFlashStatusWarning;
    data->gcb1_2VStatusWarning = Instances[j].gcb1_2VStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gcb1_2VStatusWarning = Instances[j].gcb1_2VStatusWarning;
    data->gcb3_3VStatusWarning = Instances[j].gcb3_3VStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gcb3_3VStatusWarning = Instances[j].gcb3_3VStatusWarning;
    data->gcb5VStatusWarning = Instances[j].gcb5VStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gcb5VStatusWarning = Instances[j].gcb5VStatusWarning;
    data->v1_2StatusWarning = Instances[j].v1_2StatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.v1_2StatusWarning = Instances[j].v1_2StatusWarning;
    data->v3_3StatusWarning = Instances[j].v3_3StatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.v3_3StatusWarning = Instances[j].v3_3StatusWarning;
    data->v5StatusWarning = Instances[j].v5StatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.v5StatusWarning = Instances[j].v5StatusWarning;
    data->gcbFPGAStatusWarning = Instances[j].gcbFPGAStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gcbFPGAStatusWarning = Instances[j].gcbFPGAStatusWarning;
    data->fpgaStatusWarning = Instances[j].fpgaStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.fpgaStatusWarning = Instances[j].fpgaStatusWarning;
    data->hiSpeedSPORTStatusWarning = Instances[j].hiSpeedSPORTStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.hiSpeedSPORTStatusWarning = Instances[j].hiSpeedSPORTStatusWarning;
    data->auxSPORTStatusWarning = Instances[j].auxSPORTStatusWarning;
    lastSample_MTM1M3_logevent_gyroWarning.auxSPORTStatusWarning = Instances[j].auxSPORTStatusWarning;
    data->sufficientSoftwareResourcesWarning = Instances[j].sufficientSoftwareResourcesWarning;
    lastSample_MTM1M3_logevent_gyroWarning.sufficientSoftwareResourcesWarning = Instances[j].sufficientSoftwareResourcesWarning;
    data->gyroEOVoltsPositiveWarning = Instances[j].gyroEOVoltsPositiveWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroEOVoltsPositiveWarning = Instances[j].gyroEOVoltsPositiveWarning;
    data->gyroEOVoltsNegativeWarning = Instances[j].gyroEOVoltsNegativeWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroEOVoltsNegativeWarning = Instances[j].gyroEOVoltsNegativeWarning;
    data->gyroXVoltsWarning = Instances[j].gyroXVoltsWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroXVoltsWarning = Instances[j].gyroXVoltsWarning;
    data->gyroYVoltsWarning = Instances[j].gyroYVoltsWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroYVoltsWarning = Instances[j].gyroYVoltsWarning;
    data->gyroZVoltsWarning = Instances[j].gyroZVoltsWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gyroZVoltsWarning = Instances[j].gyroZVoltsWarning;
    data->gcbADCCommsWarning = Instances[j].gcbADCCommsWarning;
    lastSample_MTM1M3_logevent_gyroWarning.gcbADCCommsWarning = Instances[j].gcbADCCommsWarning;
    data->mSYNCExternalTimingWarning = Instances[j].mSYNCExternalTimingWarning;
    lastSample_MTM1M3_logevent_gyroWarning.mSYNCExternalTimingWarning = Instances[j].mSYNCExternalTimingWarning;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_gyroWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_gyroWarning_07c44e13DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_gyroWarning(MTM1M3_logevent_gyroWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_gyroWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_gyroWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_gyroWarning(data);
    sal[SAL__MTM1M3_logevent_gyroWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_gyroWarning(MTM1M3_logevent_gyroWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_gyroWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_gyroWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_gyroWarning.anyWarning;
   data->gyroXStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroXStatusWarning;
   data->gyroYStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroYStatusWarning;
   data->gyroZStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroZStatusWarning;
   data->sequenceNumberWarning = lastSample_MTM1M3_logevent_gyroWarning.sequenceNumberWarning;
   data->crcMismatchWarning = lastSample_MTM1M3_logevent_gyroWarning.crcMismatchWarning;
   data->invalidLengthWarning = lastSample_MTM1M3_logevent_gyroWarning.invalidLengthWarning;
   data->invalidHeaderWarning = lastSample_MTM1M3_logevent_gyroWarning.invalidHeaderWarning;
   data->incompleteFrameWarning = lastSample_MTM1M3_logevent_gyroWarning.incompleteFrameWarning;
   data->gyroXSLDWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroXSLDWarning;
   data->gyroXMODDACWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroXMODDACWarning;
   data->gyroXPhaseWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroXPhaseWarning;
   data->gyroXFlashWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroXFlashWarning;
   data->gyroYSLDWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroYSLDWarning;
   data->gyroYMODDACWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroYMODDACWarning;
   data->gyroYPhaseWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroYPhaseWarning;
   data->gyroYFlashWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroYFlashWarning;
   data->gyroZSLDWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroZSLDWarning;
   data->gyroZMODDACWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroZMODDACWarning;
   data->gyroZPhaseWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroZPhaseWarning;
   data->gyroZFlashWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroZFlashWarning;
   data->gyroXSLDTemperatureStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroXSLDTemperatureStatusWarning;
   data->gyroYSLDTemperatureStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroYSLDTemperatureStatusWarning;
   data->gyroZSLDTemperatureStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroZSLDTemperatureStatusWarning;
   data->gcbTemperatureStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gcbTemperatureStatusWarning;
   data->temperatureStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.temperatureStatusWarning;
   data->gcbDSPSPIFlashStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gcbDSPSPIFlashStatusWarning;
   data->gcbFPGASPIFlashStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gcbFPGASPIFlashStatusWarning;
   data->dspSPIFlashStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.dspSPIFlashStatusWarning;
   data->fpgaSPIFlashStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.fpgaSPIFlashStatusWarning;
   data->gcb1_2VStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gcb1_2VStatusWarning;
   data->gcb3_3VStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gcb3_3VStatusWarning;
   data->gcb5VStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gcb5VStatusWarning;
   data->v1_2StatusWarning = lastSample_MTM1M3_logevent_gyroWarning.v1_2StatusWarning;
   data->v3_3StatusWarning = lastSample_MTM1M3_logevent_gyroWarning.v3_3StatusWarning;
   data->v5StatusWarning = lastSample_MTM1M3_logevent_gyroWarning.v5StatusWarning;
   data->gcbFPGAStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.gcbFPGAStatusWarning;
   data->fpgaStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.fpgaStatusWarning;
   data->hiSpeedSPORTStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.hiSpeedSPORTStatusWarning;
   data->auxSPORTStatusWarning = lastSample_MTM1M3_logevent_gyroWarning.auxSPORTStatusWarning;
   data->sufficientSoftwareResourcesWarning = lastSample_MTM1M3_logevent_gyroWarning.sufficientSoftwareResourcesWarning;
   data->gyroEOVoltsPositiveWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroEOVoltsPositiveWarning;
   data->gyroEOVoltsNegativeWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroEOVoltsNegativeWarning;
   data->gyroXVoltsWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroXVoltsWarning;
   data->gyroYVoltsWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroYVoltsWarning;
   data->gyroZVoltsWarning = lastSample_MTM1M3_logevent_gyroWarning.gyroZVoltsWarning;
   data->gcbADCCommsWarning = lastSample_MTM1M3_logevent_gyroWarning.gcbADCCommsWarning;
   data->mSYNCExternalTimingWarning = lastSample_MTM1M3_logevent_gyroWarning.mSYNCExternalTimingWarning;
   data->priority = lastSample_MTM1M3_logevent_gyroWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_gyroWarning(MTM1M3_logevent_gyroWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_gyroWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_gyroWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_gyroWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_gyroWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_hardpointActuatorInfo_d713e706 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointActuatorInfo");
  }
  MTM1M3::logevent_hardpointActuatorInfo_d713e706DataWriter_var SALWriter = MTM1M3::logevent_hardpointActuatorInfo_d713e706DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("d713e706");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointActuatorInfo_d713e706 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorInfo_d713e706DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_hardpointActuatorInfo_d713e706Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointActuatorInfo");
  }
  MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader_var SALReader = MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_hardpointActuatorInfo(MTM1M3_logevent_hardpointActuatorInfoC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_hardpointActuatorInfo");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointActuatorInfo");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointActuatorInfo_d713e706DataWriter_var SALWriter = MTM1M3::logevent_hardpointActuatorInfo_d713e706DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_hardpointActuatorInfo_d713e706 Instance;

  Instance.private_revCode = DDS::string_dup("d713e706");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<6;iseq++) {Instance.referenceId[iseq] = data->referenceId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.referencePosition[iseq] = data->referencePosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.modbusSubnet[iseq] = data->modbusSubnet[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.modbusAddress[iseq] = data->modbusAddress[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.xPosition[iseq] = data->xPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.yPosition[iseq] = data->yPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.zPosition[iseq] = data->zPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.ilcUniqueId[iseq] = data->ilcUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.ilcApplicationType[iseq] = data->ilcApplicationType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.networkNodeType[iseq] = data->networkNodeType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.ilcSelectedOptions[iseq] = data->ilcSelectedOptions[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.networkNodeOptions[iseq] = data->networkNodeOptions[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.majorRevision[iseq] = data->majorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.minorRevision[iseq] = data->minorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.adcScanRate[iseq] = data->adcScanRate[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.mainLoadCellCoefficient[iseq] = data->mainLoadCellCoefficient[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.mainLoadCellOffset[iseq] = data->mainLoadCellOffset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.mainLoadCellSensitivity[iseq] = data->mainLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.backupLoadCellCoefficient[iseq] = data->backupLoadCellCoefficient[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.backupLoadCellOffset[iseq] = data->backupLoadCellOffset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.backupLoadCellSensitivity[iseq] = data->backupLoadCellSensitivity[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointActuatorInfo_d713e706 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorInfo_d713e706DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_hardpointActuatorInfo(MTM1M3_logevent_hardpointActuatorInfoC *data)
{
  MTM1M3::logevent_hardpointActuatorInfo_d713e706Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_hardpointActuatorInfo");
  }
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointActuatorInfo");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader_var SALReader = MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_hardpointActuatorInfo.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->referenceId[iseq] = Instances[j].referenceId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.referenceId[iseq] = Instances[j].referenceId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->referencePosition[iseq] = Instances[j].referencePosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.referencePosition[iseq] = Instances[j].referencePosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->modbusSubnet[iseq] = Instances[j].modbusSubnet[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.modbusSubnet[iseq] = Instances[j].modbusSubnet[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->modbusAddress[iseq] = Instances[j].modbusAddress[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.modbusAddress[iseq] = Instances[j].modbusAddress[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->xPosition[iseq] = Instances[j].xPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.xPosition[iseq] = Instances[j].xPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->yPosition[iseq] = Instances[j].yPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.yPosition[iseq] = Instances[j].yPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->zPosition[iseq] = Instances[j].zPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.zPosition[iseq] = Instances[j].zPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcUniqueId[iseq] = Instances[j].ilcUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.ilcUniqueId[iseq] = Instances[j].ilcUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcApplicationType[iseq] = Instances[j].ilcApplicationType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.ilcApplicationType[iseq] = Instances[j].ilcApplicationType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->networkNodeType[iseq] = Instances[j].networkNodeType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.networkNodeType[iseq] = Instances[j].networkNodeType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcSelectedOptions[iseq] = Instances[j].ilcSelectedOptions[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.ilcSelectedOptions[iseq] = Instances[j].ilcSelectedOptions[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->networkNodeOptions[iseq] = Instances[j].networkNodeOptions[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.networkNodeOptions[iseq] = Instances[j].networkNodeOptions[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->majorRevision[iseq] = Instances[j].majorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.majorRevision[iseq] = Instances[j].majorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->minorRevision[iseq] = Instances[j].minorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.minorRevision[iseq] = Instances[j].minorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->adcScanRate[iseq] = Instances[j].adcScanRate[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.adcScanRate[iseq] = Instances[j].adcScanRate[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mainLoadCellCoefficient[iseq] = Instances[j].mainLoadCellCoefficient[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.mainLoadCellCoefficient[iseq] = Instances[j].mainLoadCellCoefficient[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mainLoadCellOffset[iseq] = Instances[j].mainLoadCellOffset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.mainLoadCellOffset[iseq] = Instances[j].mainLoadCellOffset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mainLoadCellSensitivity[iseq] = Instances[j].mainLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.mainLoadCellSensitivity[iseq] = Instances[j].mainLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->backupLoadCellCoefficient[iseq] = Instances[j].backupLoadCellCoefficient[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.backupLoadCellCoefficient[iseq] = Instances[j].backupLoadCellCoefficient[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->backupLoadCellOffset[iseq] = Instances[j].backupLoadCellOffset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.backupLoadCellOffset[iseq] = Instances[j].backupLoadCellOffset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->backupLoadCellSensitivity[iseq] = Instances[j].backupLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorInfo.backupLoadCellSensitivity[iseq] = Instances[j].backupLoadCellSensitivity[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_hardpointActuatorInfo.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorInfo_d713e706DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_hardpointActuatorInfo(MTM1M3_logevent_hardpointActuatorInfoC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_hardpointActuatorInfo(data);
    sal[SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_hardpointActuatorInfo(MTM1M3_logevent_hardpointActuatorInfoC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_hardpointActuatorInfo(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_hardpointActuatorInfo.timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->referenceId[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.referenceId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->referencePosition[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.referencePosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->modbusSubnet[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.modbusSubnet[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->modbusAddress[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.modbusAddress[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->xPosition[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.xPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->yPosition[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.yPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->zPosition[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.zPosition[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcUniqueId[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.ilcUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcApplicationType[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.ilcApplicationType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->networkNodeType[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.networkNodeType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcSelectedOptions[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.ilcSelectedOptions[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->networkNodeOptions[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.networkNodeOptions[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->majorRevision[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.majorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->minorRevision[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.minorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->adcScanRate[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.adcScanRate[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mainLoadCellCoefficient[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.mainLoadCellCoefficient[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mainLoadCellOffset[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.mainLoadCellOffset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mainLoadCellSensitivity[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.mainLoadCellSensitivity[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->backupLoadCellCoefficient[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.backupLoadCellCoefficient[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->backupLoadCellOffset[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.backupLoadCellOffset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->backupLoadCellSensitivity[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorInfo.backupLoadCellSensitivity[iseq];}
   data->priority = lastSample_MTM1M3_logevent_hardpointActuatorInfo.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_hardpointActuatorInfo(MTM1M3_logevent_hardpointActuatorInfoC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_hardpointActuatorInfo(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_hardpointActuatorState_dfd8f788 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointActuatorState");
  }
  MTM1M3::logevent_hardpointActuatorState_dfd8f788DataWriter_var SALWriter = MTM1M3::logevent_hardpointActuatorState_dfd8f788DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("dfd8f788");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointActuatorState_dfd8f788 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorState_dfd8f788DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_hardpointActuatorState_dfd8f788Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointActuatorState");
  }
  MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader_var SALReader = MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_hardpointActuatorState(MTM1M3_logevent_hardpointActuatorStateC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_hardpointActuatorState");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointActuatorState");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointActuatorState_dfd8f788DataWriter_var SALWriter = MTM1M3::logevent_hardpointActuatorState_dfd8f788DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_hardpointActuatorState_dfd8f788 Instance;

  Instance.private_revCode = DDS::string_dup("dfd8f788");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<6;iseq++) {Instance.ilcState[iseq] = data->ilcState[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.motionState[iseq] = data->motionState[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointActuatorState_dfd8f788 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorState_dfd8f788DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_hardpointActuatorState(MTM1M3_logevent_hardpointActuatorStateC *data)
{
  MTM1M3::logevent_hardpointActuatorState_dfd8f788Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_hardpointActuatorState");
  }
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointActuatorState");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader_var SALReader = MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_hardpointActuatorState.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->ilcState[iseq] = Instances[j].ilcState[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorState.ilcState[iseq] = Instances[j].ilcState[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->motionState[iseq] = Instances[j].motionState[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorState.motionState[iseq] = Instances[j].motionState[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_hardpointActuatorState.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorState_dfd8f788DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_hardpointActuatorState(MTM1M3_logevent_hardpointActuatorStateC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_hardpointActuatorState(data);
    sal[SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_hardpointActuatorState(MTM1M3_logevent_hardpointActuatorStateC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_hardpointActuatorState(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_hardpointActuatorState.timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->ilcState[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorState.ilcState[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->motionState[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorState.motionState[iseq];}
   data->priority = lastSample_MTM1M3_logevent_hardpointActuatorState.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_hardpointActuatorState(MTM1M3_logevent_hardpointActuatorStateC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_hardpointActuatorState(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_hardpointActuatorWarning_dcc7d946 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointActuatorWarning");
  }
  MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataWriter_var SALWriter = MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("dcc7d946");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointActuatorWarning_dcc7d946 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_hardpointActuatorWarning_dcc7d946Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointActuatorWarning");
  }
  MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader_var SALReader = MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_hardpointActuatorWarning(MTM1M3_logevent_hardpointActuatorWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_hardpointActuatorWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointActuatorWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataWriter_var SALWriter = MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_hardpointActuatorWarning_dcc7d946 Instance;

  Instance.private_revCode = DDS::string_dup("dcc7d946");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.anyMajorFault = data->anyMajorFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.majorFault[iseq] = data->majorFault[iseq];}
    Instance.anyMinorFault = data->anyMinorFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.minorFault[iseq] = data->minorFault[iseq];}
    Instance.anyFaultOverride = data->anyFaultOverride;
    for (int iseq=0;iseq<6;iseq++) {Instance.faultOverride[iseq] = data->faultOverride[iseq];}
    Instance.anyMainCalibrationError = data->anyMainCalibrationError;
    for (int iseq=0;iseq<6;iseq++) {Instance.mainCalibrationError[iseq] = data->mainCalibrationError[iseq];}
    Instance.anyBackupCalibrationError = data->anyBackupCalibrationError;
    for (int iseq=0;iseq<6;iseq++) {Instance.backupCalibrationError[iseq] = data->backupCalibrationError[iseq];}
    Instance.anyLimitSwitch1Operated = data->anyLimitSwitch1Operated;
    for (int iseq=0;iseq<6;iseq++) {Instance.limitSwitch1Operated[iseq] = data->limitSwitch1Operated[iseq];}
    Instance.anyLimitSwitch2Operated = data->anyLimitSwitch2Operated;
    for (int iseq=0;iseq<6;iseq++) {Instance.limitSwitch2Operated[iseq] = data->limitSwitch2Operated[iseq];}
    Instance.anyUniqueIdCRCError = data->anyUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {Instance.uniqueIdCRCError[iseq] = data->uniqueIdCRCError[iseq];}
    Instance.anyApplicationTypeMismatch = data->anyApplicationTypeMismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.applicationTypeMismatch[iseq] = data->applicationTypeMismatch[iseq];}
    Instance.anyApplicationMissing = data->anyApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {Instance.applicationMissing[iseq] = data->applicationMissing[iseq];}
    Instance.anyApplicationCRCMismatch = data->anyApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.applicationCRCMismatch[iseq] = data->applicationCRCMismatch[iseq];}
    Instance.anyOneWireMissing = data->anyOneWireMissing;
    for (int iseq=0;iseq<6;iseq++) {Instance.oneWireMissing[iseq] = data->oneWireMissing[iseq];}
    Instance.anyOneWire1Mismatch = data->anyOneWire1Mismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.oneWire1Mismatch[iseq] = data->oneWire1Mismatch[iseq];}
    Instance.anyOneWire2Mismatch = data->anyOneWire2Mismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.oneWire2Mismatch[iseq] = data->oneWire2Mismatch[iseq];}
    Instance.anyWatchdogReset = data->anyWatchdogReset;
    for (int iseq=0;iseq<6;iseq++) {Instance.watchdogReset[iseq] = data->watchdogReset[iseq];}
    Instance.anyBrownOut = data->anyBrownOut;
    for (int iseq=0;iseq<6;iseq++) {Instance.brownOut[iseq] = data->brownOut[iseq];}
    Instance.anyEventTrapReset = data->anyEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {Instance.eventTrapReset[iseq] = data->eventTrapReset[iseq];}
    Instance.anyMotorDriverFault = data->anyMotorDriverFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.motorDriverFault[iseq] = data->motorDriverFault[iseq];}
    Instance.anySSRPowerFault = data->anySSRPowerFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.ssrPowerFault[iseq] = data->ssrPowerFault[iseq];}
    Instance.anyAuxPowerFault = data->anyAuxPowerFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.auxPowerFault[iseq] = data->auxPowerFault[iseq];}
    Instance.anySMCPowerFault = data->anySMCPowerFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.smcPowerFault[iseq] = data->smcPowerFault[iseq];}
    Instance.anyILCFault = data->anyILCFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.ilcFault[iseq] = data->ilcFault[iseq];}
    Instance.anyBroadcastCounterWarning = data->anyBroadcastCounterWarning;
    for (int iseq=0;iseq<6;iseq++) {Instance.broadcastCounterWarning[iseq] = data->broadcastCounterWarning[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointActuatorWarning_dcc7d946 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_hardpointActuatorWarning(MTM1M3_logevent_hardpointActuatorWarningC *data)
{
  MTM1M3::logevent_hardpointActuatorWarning_dcc7d946Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_hardpointActuatorWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointActuatorWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader_var SALReader = MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyWarning = Instances[j].anyWarning;
    data->anyMajorFault = Instances[j].anyMajorFault;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyMajorFault = Instances[j].anyMajorFault;
    for (int iseq=0;iseq<6;iseq++) {data->majorFault[iseq] = Instances[j].majorFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.majorFault[iseq] = Instances[j].majorFault[iseq];}
    data->anyMinorFault = Instances[j].anyMinorFault;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyMinorFault = Instances[j].anyMinorFault;
    for (int iseq=0;iseq<6;iseq++) {data->minorFault[iseq] = Instances[j].minorFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.minorFault[iseq] = Instances[j].minorFault[iseq];}
    data->anyFaultOverride = Instances[j].anyFaultOverride;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyFaultOverride = Instances[j].anyFaultOverride;
    for (int iseq=0;iseq<6;iseq++) {data->faultOverride[iseq] = Instances[j].faultOverride[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.faultOverride[iseq] = Instances[j].faultOverride[iseq];}
    data->anyMainCalibrationError = Instances[j].anyMainCalibrationError;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyMainCalibrationError = Instances[j].anyMainCalibrationError;
    for (int iseq=0;iseq<6;iseq++) {data->mainCalibrationError[iseq] = Instances[j].mainCalibrationError[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.mainCalibrationError[iseq] = Instances[j].mainCalibrationError[iseq];}
    data->anyBackupCalibrationError = Instances[j].anyBackupCalibrationError;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyBackupCalibrationError = Instances[j].anyBackupCalibrationError;
    for (int iseq=0;iseq<6;iseq++) {data->backupCalibrationError[iseq] = Instances[j].backupCalibrationError[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.backupCalibrationError[iseq] = Instances[j].backupCalibrationError[iseq];}
    data->anyLimitSwitch1Operated = Instances[j].anyLimitSwitch1Operated;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyLimitSwitch1Operated = Instances[j].anyLimitSwitch1Operated;
    for (int iseq=0;iseq<6;iseq++) {data->limitSwitch1Operated[iseq] = Instances[j].limitSwitch1Operated[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.limitSwitch1Operated[iseq] = Instances[j].limitSwitch1Operated[iseq];}
    data->anyLimitSwitch2Operated = Instances[j].anyLimitSwitch2Operated;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyLimitSwitch2Operated = Instances[j].anyLimitSwitch2Operated;
    for (int iseq=0;iseq<6;iseq++) {data->limitSwitch2Operated[iseq] = Instances[j].limitSwitch2Operated[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.limitSwitch2Operated[iseq] = Instances[j].limitSwitch2Operated[iseq];}
    data->anyUniqueIdCRCError = Instances[j].anyUniqueIdCRCError;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyUniqueIdCRCError = Instances[j].anyUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {data->uniqueIdCRCError[iseq] = Instances[j].uniqueIdCRCError[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.uniqueIdCRCError[iseq] = Instances[j].uniqueIdCRCError[iseq];}
    data->anyApplicationTypeMismatch = Instances[j].anyApplicationTypeMismatch;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyApplicationTypeMismatch = Instances[j].anyApplicationTypeMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->applicationTypeMismatch[iseq] = Instances[j].applicationTypeMismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.applicationTypeMismatch[iseq] = Instances[j].applicationTypeMismatch[iseq];}
    data->anyApplicationMissing = Instances[j].anyApplicationMissing;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyApplicationMissing = Instances[j].anyApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {data->applicationMissing[iseq] = Instances[j].applicationMissing[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.applicationMissing[iseq] = Instances[j].applicationMissing[iseq];}
    data->anyApplicationCRCMismatch = Instances[j].anyApplicationCRCMismatch;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyApplicationCRCMismatch = Instances[j].anyApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->applicationCRCMismatch[iseq] = Instances[j].applicationCRCMismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.applicationCRCMismatch[iseq] = Instances[j].applicationCRCMismatch[iseq];}
    data->anyOneWireMissing = Instances[j].anyOneWireMissing;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyOneWireMissing = Instances[j].anyOneWireMissing;
    for (int iseq=0;iseq<6;iseq++) {data->oneWireMissing[iseq] = Instances[j].oneWireMissing[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.oneWireMissing[iseq] = Instances[j].oneWireMissing[iseq];}
    data->anyOneWire1Mismatch = Instances[j].anyOneWire1Mismatch;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyOneWire1Mismatch = Instances[j].anyOneWire1Mismatch;
    for (int iseq=0;iseq<6;iseq++) {data->oneWire1Mismatch[iseq] = Instances[j].oneWire1Mismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.oneWire1Mismatch[iseq] = Instances[j].oneWire1Mismatch[iseq];}
    data->anyOneWire2Mismatch = Instances[j].anyOneWire2Mismatch;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyOneWire2Mismatch = Instances[j].anyOneWire2Mismatch;
    for (int iseq=0;iseq<6;iseq++) {data->oneWire2Mismatch[iseq] = Instances[j].oneWire2Mismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.oneWire2Mismatch[iseq] = Instances[j].oneWire2Mismatch[iseq];}
    data->anyWatchdogReset = Instances[j].anyWatchdogReset;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyWatchdogReset = Instances[j].anyWatchdogReset;
    for (int iseq=0;iseq<6;iseq++) {data->watchdogReset[iseq] = Instances[j].watchdogReset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.watchdogReset[iseq] = Instances[j].watchdogReset[iseq];}
    data->anyBrownOut = Instances[j].anyBrownOut;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyBrownOut = Instances[j].anyBrownOut;
    for (int iseq=0;iseq<6;iseq++) {data->brownOut[iseq] = Instances[j].brownOut[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.brownOut[iseq] = Instances[j].brownOut[iseq];}
    data->anyEventTrapReset = Instances[j].anyEventTrapReset;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyEventTrapReset = Instances[j].anyEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {data->eventTrapReset[iseq] = Instances[j].eventTrapReset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.eventTrapReset[iseq] = Instances[j].eventTrapReset[iseq];}
    data->anyMotorDriverFault = Instances[j].anyMotorDriverFault;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyMotorDriverFault = Instances[j].anyMotorDriverFault;
    for (int iseq=0;iseq<6;iseq++) {data->motorDriverFault[iseq] = Instances[j].motorDriverFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.motorDriverFault[iseq] = Instances[j].motorDriverFault[iseq];}
    data->anySSRPowerFault = Instances[j].anySSRPowerFault;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anySSRPowerFault = Instances[j].anySSRPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->ssrPowerFault[iseq] = Instances[j].ssrPowerFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.ssrPowerFault[iseq] = Instances[j].ssrPowerFault[iseq];}
    data->anyAuxPowerFault = Instances[j].anyAuxPowerFault;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyAuxPowerFault = Instances[j].anyAuxPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->auxPowerFault[iseq] = Instances[j].auxPowerFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.auxPowerFault[iseq] = Instances[j].auxPowerFault[iseq];}
    data->anySMCPowerFault = Instances[j].anySMCPowerFault;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anySMCPowerFault = Instances[j].anySMCPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->smcPowerFault[iseq] = Instances[j].smcPowerFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.smcPowerFault[iseq] = Instances[j].smcPowerFault[iseq];}
    data->anyILCFault = Instances[j].anyILCFault;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyILCFault = Instances[j].anyILCFault;
    for (int iseq=0;iseq<6;iseq++) {data->ilcFault[iseq] = Instances[j].ilcFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.ilcFault[iseq] = Instances[j].ilcFault[iseq];}
    data->anyBroadcastCounterWarning = Instances[j].anyBroadcastCounterWarning;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyBroadcastCounterWarning = Instances[j].anyBroadcastCounterWarning;
    for (int iseq=0;iseq<6;iseq++) {data->broadcastCounterWarning[iseq] = Instances[j].broadcastCounterWarning[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointActuatorWarning.broadcastCounterWarning[iseq] = Instances[j].broadcastCounterWarning[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_hardpointActuatorWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_hardpointActuatorWarning_dcc7d946DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_hardpointActuatorWarning(MTM1M3_logevent_hardpointActuatorWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_hardpointActuatorWarning(data);
    sal[SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_hardpointActuatorWarning(MTM1M3_logevent_hardpointActuatorWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_hardpointActuatorWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_hardpointActuatorWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyWarning;
   data->anyMajorFault = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyMajorFault;
    for (int iseq=0;iseq<6;iseq++) {data->majorFault[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.majorFault[iseq];}
   data->anyMinorFault = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyMinorFault;
    for (int iseq=0;iseq<6;iseq++) {data->minorFault[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.minorFault[iseq];}
   data->anyFaultOverride = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyFaultOverride;
    for (int iseq=0;iseq<6;iseq++) {data->faultOverride[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.faultOverride[iseq];}
   data->anyMainCalibrationError = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyMainCalibrationError;
    for (int iseq=0;iseq<6;iseq++) {data->mainCalibrationError[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.mainCalibrationError[iseq];}
   data->anyBackupCalibrationError = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyBackupCalibrationError;
    for (int iseq=0;iseq<6;iseq++) {data->backupCalibrationError[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.backupCalibrationError[iseq];}
   data->anyLimitSwitch1Operated = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyLimitSwitch1Operated;
    for (int iseq=0;iseq<6;iseq++) {data->limitSwitch1Operated[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.limitSwitch1Operated[iseq];}
   data->anyLimitSwitch2Operated = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyLimitSwitch2Operated;
    for (int iseq=0;iseq<6;iseq++) {data->limitSwitch2Operated[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.limitSwitch2Operated[iseq];}
   data->anyUniqueIdCRCError = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {data->uniqueIdCRCError[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.uniqueIdCRCError[iseq];}
   data->anyApplicationTypeMismatch = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyApplicationTypeMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->applicationTypeMismatch[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.applicationTypeMismatch[iseq];}
   data->anyApplicationMissing = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {data->applicationMissing[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.applicationMissing[iseq];}
   data->anyApplicationCRCMismatch = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->applicationCRCMismatch[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.applicationCRCMismatch[iseq];}
   data->anyOneWireMissing = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyOneWireMissing;
    for (int iseq=0;iseq<6;iseq++) {data->oneWireMissing[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.oneWireMissing[iseq];}
   data->anyOneWire1Mismatch = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyOneWire1Mismatch;
    for (int iseq=0;iseq<6;iseq++) {data->oneWire1Mismatch[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.oneWire1Mismatch[iseq];}
   data->anyOneWire2Mismatch = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyOneWire2Mismatch;
    for (int iseq=0;iseq<6;iseq++) {data->oneWire2Mismatch[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.oneWire2Mismatch[iseq];}
   data->anyWatchdogReset = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyWatchdogReset;
    for (int iseq=0;iseq<6;iseq++) {data->watchdogReset[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.watchdogReset[iseq];}
   data->anyBrownOut = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyBrownOut;
    for (int iseq=0;iseq<6;iseq++) {data->brownOut[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.brownOut[iseq];}
   data->anyEventTrapReset = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {data->eventTrapReset[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.eventTrapReset[iseq];}
   data->anyMotorDriverFault = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyMotorDriverFault;
    for (int iseq=0;iseq<6;iseq++) {data->motorDriverFault[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.motorDriverFault[iseq];}
   data->anySSRPowerFault = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anySSRPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->ssrPowerFault[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.ssrPowerFault[iseq];}
   data->anyAuxPowerFault = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyAuxPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->auxPowerFault[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.auxPowerFault[iseq];}
   data->anySMCPowerFault = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anySMCPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->smcPowerFault[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.smcPowerFault[iseq];}
   data->anyILCFault = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyILCFault;
    for (int iseq=0;iseq<6;iseq++) {data->ilcFault[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.ilcFault[iseq];}
   data->anyBroadcastCounterWarning = lastSample_MTM1M3_logevent_hardpointActuatorWarning.anyBroadcastCounterWarning;
    for (int iseq=0;iseq<6;iseq++) {data->broadcastCounterWarning[iseq] = lastSample_MTM1M3_logevent_hardpointActuatorWarning.broadcastCounterWarning[iseq];}
   data->priority = lastSample_MTM1M3_logevent_hardpointActuatorWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_hardpointActuatorWarning(MTM1M3_logevent_hardpointActuatorWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_hardpointActuatorWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_hardpointMonitorInfo_5dc92c27 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointMonitorInfo");
  }
  MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataWriter_var SALWriter = MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("5dc92c27");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointMonitorInfo_5dc92c27 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_hardpointMonitorInfo_5dc92c27Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointMonitorInfo");
  }
  MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader_var SALReader = MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_hardpointMonitorInfo(MTM1M3_logevent_hardpointMonitorInfoC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_hardpointMonitorInfo");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointMonitorInfo");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataWriter_var SALWriter = MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_hardpointMonitorInfo_5dc92c27 Instance;

  Instance.private_revCode = DDS::string_dup("5dc92c27");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<6;iseq++) {Instance.referenceId[iseq] = data->referenceId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.modbusSubnet[iseq] = data->modbusSubnet[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.modbusAddress[iseq] = data->modbusAddress[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.ilcUniqueId[iseq] = data->ilcUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.ilcApplicationType[iseq] = data->ilcApplicationType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.networkNodeType[iseq] = data->networkNodeType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.majorRevision[iseq] = data->majorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.minorRevision[iseq] = data->minorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineUniqueId[iseq] = data->mezzanineUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineFirmwareType[iseq] = data->mezzanineFirmwareType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineMajorRevision[iseq] = data->mezzanineMajorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineMinorRevision[iseq] = data->mezzanineMinorRevision[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointMonitorInfo_5dc92c27 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_hardpointMonitorInfo(MTM1M3_logevent_hardpointMonitorInfoC *data)
{
  MTM1M3::logevent_hardpointMonitorInfo_5dc92c27Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_hardpointMonitorInfo");
  }
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointMonitorInfo");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader_var SALReader = MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_hardpointMonitorInfo.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->referenceId[iseq] = Instances[j].referenceId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.referenceId[iseq] = Instances[j].referenceId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->modbusSubnet[iseq] = Instances[j].modbusSubnet[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.modbusSubnet[iseq] = Instances[j].modbusSubnet[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->modbusAddress[iseq] = Instances[j].modbusAddress[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.modbusAddress[iseq] = Instances[j].modbusAddress[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcUniqueId[iseq] = Instances[j].ilcUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.ilcUniqueId[iseq] = Instances[j].ilcUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcApplicationType[iseq] = Instances[j].ilcApplicationType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.ilcApplicationType[iseq] = Instances[j].ilcApplicationType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->networkNodeType[iseq] = Instances[j].networkNodeType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.networkNodeType[iseq] = Instances[j].networkNodeType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->majorRevision[iseq] = Instances[j].majorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.majorRevision[iseq] = Instances[j].majorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->minorRevision[iseq] = Instances[j].minorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.minorRevision[iseq] = Instances[j].minorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineUniqueId[iseq] = Instances[j].mezzanineUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.mezzanineUniqueId[iseq] = Instances[j].mezzanineUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineFirmwareType[iseq] = Instances[j].mezzanineFirmwareType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.mezzanineFirmwareType[iseq] = Instances[j].mezzanineFirmwareType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineMajorRevision[iseq] = Instances[j].mezzanineMajorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.mezzanineMajorRevision[iseq] = Instances[j].mezzanineMajorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineMinorRevision[iseq] = Instances[j].mezzanineMinorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorInfo.mezzanineMinorRevision[iseq] = Instances[j].mezzanineMinorRevision[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_hardpointMonitorInfo.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorInfo_5dc92c27DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_hardpointMonitorInfo(MTM1M3_logevent_hardpointMonitorInfoC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_hardpointMonitorInfo(data);
    sal[SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_hardpointMonitorInfo(MTM1M3_logevent_hardpointMonitorInfoC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_hardpointMonitorInfo(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_hardpointMonitorInfo.timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->referenceId[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.referenceId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->modbusSubnet[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.modbusSubnet[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->modbusAddress[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.modbusAddress[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcUniqueId[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.ilcUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->ilcApplicationType[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.ilcApplicationType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->networkNodeType[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.networkNodeType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->majorRevision[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.majorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->minorRevision[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.minorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineUniqueId[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.mezzanineUniqueId[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineFirmwareType[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.mezzanineFirmwareType[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineMajorRevision[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.mezzanineMajorRevision[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineMinorRevision[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorInfo.mezzanineMinorRevision[iseq];}
   data->priority = lastSample_MTM1M3_logevent_hardpointMonitorInfo.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_hardpointMonitorInfo(MTM1M3_logevent_hardpointMonitorInfoC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_hardpointMonitorInfo(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_hardpointMonitorState_0dad41d1 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointMonitorState");
  }
  MTM1M3::logevent_hardpointMonitorState_0dad41d1DataWriter_var SALWriter = MTM1M3::logevent_hardpointMonitorState_0dad41d1DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("0dad41d1");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointMonitorState_0dad41d1 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorState_0dad41d1DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_hardpointMonitorState_0dad41d1Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointMonitorState");
  }
  MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader_var SALReader = MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_hardpointMonitorState(MTM1M3_logevent_hardpointMonitorStateC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_hardpointMonitorState");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointMonitorState");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointMonitorState_0dad41d1DataWriter_var SALWriter = MTM1M3::logevent_hardpointMonitorState_0dad41d1DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_hardpointMonitorState_0dad41d1 Instance;

  Instance.private_revCode = DDS::string_dup("0dad41d1");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<6;iseq++) {Instance.ilcState[iseq] = data->ilcState[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointMonitorState_0dad41d1 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorState_0dad41d1DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_hardpointMonitorState(MTM1M3_logevent_hardpointMonitorStateC *data)
{
  MTM1M3::logevent_hardpointMonitorState_0dad41d1Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_hardpointMonitorState");
  }
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointMonitorState");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader_var SALReader = MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_hardpointMonitorState.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->ilcState[iseq] = Instances[j].ilcState[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorState.ilcState[iseq] = Instances[j].ilcState[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_hardpointMonitorState.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorState_0dad41d1DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_hardpointMonitorState(MTM1M3_logevent_hardpointMonitorStateC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_hardpointMonitorState(data);
    sal[SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_hardpointMonitorState(MTM1M3_logevent_hardpointMonitorStateC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_hardpointMonitorState(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_hardpointMonitorState.timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->ilcState[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorState.ilcState[iseq];}
   data->priority = lastSample_MTM1M3_logevent_hardpointMonitorState.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_hardpointMonitorState(MTM1M3_logevent_hardpointMonitorStateC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_hardpointMonitorState(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointMonitorWarning");
  }
  MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataWriter_var SALWriter = MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("d5ab85e8");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointMonitorWarning");
  }
  MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader_var SALReader = MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_hardpointMonitorWarning(MTM1M3_logevent_hardpointMonitorWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_hardpointMonitorWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_hardpointMonitorWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataWriter_var SALWriter = MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8 Instance;

  Instance.private_revCode = DDS::string_dup("d5ab85e8");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.anyMajorFault = data->anyMajorFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.majorFault[iseq] = data->majorFault[iseq];}
    Instance.anyMinorFault = data->anyMinorFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.minorFault[iseq] = data->minorFault[iseq];}
    Instance.anyFaultOverride = data->anyFaultOverride;
    for (int iseq=0;iseq<6;iseq++) {Instance.faultOverride[iseq] = data->faultOverride[iseq];}
    Instance.anyInstrumentError = data->anyInstrumentError;
    for (int iseq=0;iseq<6;iseq++) {Instance.instrumentError[iseq] = data->instrumentError[iseq];}
    Instance.anyMezzanineError = data->anyMezzanineError;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineError[iseq] = data->mezzanineError[iseq];}
    Instance.anyMezzanineBootloaderActive = data->anyMezzanineBootloaderActive;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineBootloaderActive[iseq] = data->mezzanineBootloaderActive[iseq];}
    Instance.anyUniqueIdCRCError = data->anyUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {Instance.uniqueIdCRCError[iseq] = data->uniqueIdCRCError[iseq];}
    Instance.anyApplicationTypeMismatch = data->anyApplicationTypeMismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.applicationTypeMismatch[iseq] = data->applicationTypeMismatch[iseq];}
    Instance.anyApplicationMissing = data->anyApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {Instance.applicationMissing[iseq] = data->applicationMissing[iseq];}
    Instance.anyApplicationCRCMismatch = data->anyApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.applicationCRCMismatch[iseq] = data->applicationCRCMismatch[iseq];}
    Instance.anyOneWireMissing = data->anyOneWireMissing;
    for (int iseq=0;iseq<6;iseq++) {Instance.oneWireMissing[iseq] = data->oneWireMissing[iseq];}
    Instance.anyOneWire1Mismatch = data->anyOneWire1Mismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.oneWire1Mismatch[iseq] = data->oneWire1Mismatch[iseq];}
    Instance.anyOneWire2Mismatch = data->anyOneWire2Mismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.oneWire2Mismatch[iseq] = data->oneWire2Mismatch[iseq];}
    Instance.anyWatchdogReset = data->anyWatchdogReset;
    for (int iseq=0;iseq<6;iseq++) {Instance.watchdogReset[iseq] = data->watchdogReset[iseq];}
    Instance.anyBrownOut = data->anyBrownOut;
    for (int iseq=0;iseq<6;iseq++) {Instance.brownOut[iseq] = data->brownOut[iseq];}
    Instance.anyEventTrapReset = data->anyEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {Instance.eventTrapReset[iseq] = data->eventTrapReset[iseq];}
    Instance.anySSRPowerFault = data->anySSRPowerFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.ssrPowerFault[iseq] = data->ssrPowerFault[iseq];}
    Instance.anyAuxPowerFault = data->anyAuxPowerFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.auxPowerFault[iseq] = data->auxPowerFault[iseq];}
    Instance.anyMezzanineS1AInterface1Fault = data->anyMezzanineS1AInterface1Fault;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineS1AInterface1Fault[iseq] = data->mezzanineS1AInterface1Fault[iseq];}
    Instance.anyMezzanineS1ALVDT1Fault = data->anyMezzanineS1ALVDT1Fault;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineS1ALVDT1Fault[iseq] = data->mezzanineS1ALVDT1Fault[iseq];}
    Instance.anyMezzanineS1AInterface2Fault = data->anyMezzanineS1AInterface2Fault;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineS1AInterface2Fault[iseq] = data->mezzanineS1AInterface2Fault[iseq];}
    Instance.anyMezzanineS1ALVDT2Fault = data->anyMezzanineS1ALVDT2Fault;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineS1ALVDT2Fault[iseq] = data->mezzanineS1ALVDT2Fault[iseq];}
    Instance.anyMezzanineUniqueIdCRCError = data->anyMezzanineUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineUniqueIdCRCError[iseq] = data->mezzanineUniqueIdCRCError[iseq];}
    Instance.anyMezzanineEventTrapReset = data->anyMezzanineEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineEventTrapReset[iseq] = data->mezzanineEventTrapReset[iseq];}
    Instance.anyMezzanineDCPRS422ChipFault = data->anyMezzanineDCPRS422ChipFault;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineDCPRS422ChipFault[iseq] = data->mezzanineDCPRS422ChipFault[iseq];}
    Instance.anyMezzanineApplicationMissing = data->anyMezzanineApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineApplicationMissing[iseq] = data->mezzanineApplicationMissing[iseq];}
    Instance.anyMezzanineApplicationCRCMismatch = data->anyMezzanineApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {Instance.mezzanineApplicationCRCMismatch[iseq] = data->mezzanineApplicationCRCMismatch[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_hardpointMonitorWarning(MTM1M3_logevent_hardpointMonitorWarningC *data)
{
  MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_hardpointMonitorWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_hardpointMonitorWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader_var SALReader = MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyWarning = Instances[j].anyWarning;
    data->anyMajorFault = Instances[j].anyMajorFault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMajorFault = Instances[j].anyMajorFault;
    for (int iseq=0;iseq<6;iseq++) {data->majorFault[iseq] = Instances[j].majorFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.majorFault[iseq] = Instances[j].majorFault[iseq];}
    data->anyMinorFault = Instances[j].anyMinorFault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMinorFault = Instances[j].anyMinorFault;
    for (int iseq=0;iseq<6;iseq++) {data->minorFault[iseq] = Instances[j].minorFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.minorFault[iseq] = Instances[j].minorFault[iseq];}
    data->anyFaultOverride = Instances[j].anyFaultOverride;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyFaultOverride = Instances[j].anyFaultOverride;
    for (int iseq=0;iseq<6;iseq++) {data->faultOverride[iseq] = Instances[j].faultOverride[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.faultOverride[iseq] = Instances[j].faultOverride[iseq];}
    data->anyInstrumentError = Instances[j].anyInstrumentError;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyInstrumentError = Instances[j].anyInstrumentError;
    for (int iseq=0;iseq<6;iseq++) {data->instrumentError[iseq] = Instances[j].instrumentError[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.instrumentError[iseq] = Instances[j].instrumentError[iseq];}
    data->anyMezzanineError = Instances[j].anyMezzanineError;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineError = Instances[j].anyMezzanineError;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineError[iseq] = Instances[j].mezzanineError[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineError[iseq] = Instances[j].mezzanineError[iseq];}
    data->anyMezzanineBootloaderActive = Instances[j].anyMezzanineBootloaderActive;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineBootloaderActive = Instances[j].anyMezzanineBootloaderActive;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineBootloaderActive[iseq] = Instances[j].mezzanineBootloaderActive[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineBootloaderActive[iseq] = Instances[j].mezzanineBootloaderActive[iseq];}
    data->anyUniqueIdCRCError = Instances[j].anyUniqueIdCRCError;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyUniqueIdCRCError = Instances[j].anyUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {data->uniqueIdCRCError[iseq] = Instances[j].uniqueIdCRCError[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.uniqueIdCRCError[iseq] = Instances[j].uniqueIdCRCError[iseq];}
    data->anyApplicationTypeMismatch = Instances[j].anyApplicationTypeMismatch;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyApplicationTypeMismatch = Instances[j].anyApplicationTypeMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->applicationTypeMismatch[iseq] = Instances[j].applicationTypeMismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.applicationTypeMismatch[iseq] = Instances[j].applicationTypeMismatch[iseq];}
    data->anyApplicationMissing = Instances[j].anyApplicationMissing;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyApplicationMissing = Instances[j].anyApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {data->applicationMissing[iseq] = Instances[j].applicationMissing[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.applicationMissing[iseq] = Instances[j].applicationMissing[iseq];}
    data->anyApplicationCRCMismatch = Instances[j].anyApplicationCRCMismatch;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyApplicationCRCMismatch = Instances[j].anyApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->applicationCRCMismatch[iseq] = Instances[j].applicationCRCMismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.applicationCRCMismatch[iseq] = Instances[j].applicationCRCMismatch[iseq];}
    data->anyOneWireMissing = Instances[j].anyOneWireMissing;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyOneWireMissing = Instances[j].anyOneWireMissing;
    for (int iseq=0;iseq<6;iseq++) {data->oneWireMissing[iseq] = Instances[j].oneWireMissing[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.oneWireMissing[iseq] = Instances[j].oneWireMissing[iseq];}
    data->anyOneWire1Mismatch = Instances[j].anyOneWire1Mismatch;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyOneWire1Mismatch = Instances[j].anyOneWire1Mismatch;
    for (int iseq=0;iseq<6;iseq++) {data->oneWire1Mismatch[iseq] = Instances[j].oneWire1Mismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.oneWire1Mismatch[iseq] = Instances[j].oneWire1Mismatch[iseq];}
    data->anyOneWire2Mismatch = Instances[j].anyOneWire2Mismatch;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyOneWire2Mismatch = Instances[j].anyOneWire2Mismatch;
    for (int iseq=0;iseq<6;iseq++) {data->oneWire2Mismatch[iseq] = Instances[j].oneWire2Mismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.oneWire2Mismatch[iseq] = Instances[j].oneWire2Mismatch[iseq];}
    data->anyWatchdogReset = Instances[j].anyWatchdogReset;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyWatchdogReset = Instances[j].anyWatchdogReset;
    for (int iseq=0;iseq<6;iseq++) {data->watchdogReset[iseq] = Instances[j].watchdogReset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.watchdogReset[iseq] = Instances[j].watchdogReset[iseq];}
    data->anyBrownOut = Instances[j].anyBrownOut;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyBrownOut = Instances[j].anyBrownOut;
    for (int iseq=0;iseq<6;iseq++) {data->brownOut[iseq] = Instances[j].brownOut[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.brownOut[iseq] = Instances[j].brownOut[iseq];}
    data->anyEventTrapReset = Instances[j].anyEventTrapReset;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyEventTrapReset = Instances[j].anyEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {data->eventTrapReset[iseq] = Instances[j].eventTrapReset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.eventTrapReset[iseq] = Instances[j].eventTrapReset[iseq];}
    data->anySSRPowerFault = Instances[j].anySSRPowerFault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anySSRPowerFault = Instances[j].anySSRPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->ssrPowerFault[iseq] = Instances[j].ssrPowerFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.ssrPowerFault[iseq] = Instances[j].ssrPowerFault[iseq];}
    data->anyAuxPowerFault = Instances[j].anyAuxPowerFault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyAuxPowerFault = Instances[j].anyAuxPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->auxPowerFault[iseq] = Instances[j].auxPowerFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.auxPowerFault[iseq] = Instances[j].auxPowerFault[iseq];}
    data->anyMezzanineS1AInterface1Fault = Instances[j].anyMezzanineS1AInterface1Fault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineS1AInterface1Fault = Instances[j].anyMezzanineS1AInterface1Fault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineS1AInterface1Fault[iseq] = Instances[j].mezzanineS1AInterface1Fault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineS1AInterface1Fault[iseq] = Instances[j].mezzanineS1AInterface1Fault[iseq];}
    data->anyMezzanineS1ALVDT1Fault = Instances[j].anyMezzanineS1ALVDT1Fault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineS1ALVDT1Fault = Instances[j].anyMezzanineS1ALVDT1Fault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineS1ALVDT1Fault[iseq] = Instances[j].mezzanineS1ALVDT1Fault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineS1ALVDT1Fault[iseq] = Instances[j].mezzanineS1ALVDT1Fault[iseq];}
    data->anyMezzanineS1AInterface2Fault = Instances[j].anyMezzanineS1AInterface2Fault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineS1AInterface2Fault = Instances[j].anyMezzanineS1AInterface2Fault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineS1AInterface2Fault[iseq] = Instances[j].mezzanineS1AInterface2Fault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineS1AInterface2Fault[iseq] = Instances[j].mezzanineS1AInterface2Fault[iseq];}
    data->anyMezzanineS1ALVDT2Fault = Instances[j].anyMezzanineS1ALVDT2Fault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineS1ALVDT2Fault = Instances[j].anyMezzanineS1ALVDT2Fault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineS1ALVDT2Fault[iseq] = Instances[j].mezzanineS1ALVDT2Fault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineS1ALVDT2Fault[iseq] = Instances[j].mezzanineS1ALVDT2Fault[iseq];}
    data->anyMezzanineUniqueIdCRCError = Instances[j].anyMezzanineUniqueIdCRCError;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineUniqueIdCRCError = Instances[j].anyMezzanineUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineUniqueIdCRCError[iseq] = Instances[j].mezzanineUniqueIdCRCError[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineUniqueIdCRCError[iseq] = Instances[j].mezzanineUniqueIdCRCError[iseq];}
    data->anyMezzanineEventTrapReset = Instances[j].anyMezzanineEventTrapReset;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineEventTrapReset = Instances[j].anyMezzanineEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineEventTrapReset[iseq] = Instances[j].mezzanineEventTrapReset[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineEventTrapReset[iseq] = Instances[j].mezzanineEventTrapReset[iseq];}
    data->anyMezzanineDCPRS422ChipFault = Instances[j].anyMezzanineDCPRS422ChipFault;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineDCPRS422ChipFault = Instances[j].anyMezzanineDCPRS422ChipFault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineDCPRS422ChipFault[iseq] = Instances[j].mezzanineDCPRS422ChipFault[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineDCPRS422ChipFault[iseq] = Instances[j].mezzanineDCPRS422ChipFault[iseq];}
    data->anyMezzanineApplicationMissing = Instances[j].anyMezzanineApplicationMissing;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineApplicationMissing = Instances[j].anyMezzanineApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineApplicationMissing[iseq] = Instances[j].mezzanineApplicationMissing[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineApplicationMissing[iseq] = Instances[j].mezzanineApplicationMissing[iseq];}
    data->anyMezzanineApplicationCRCMismatch = Instances[j].anyMezzanineApplicationCRCMismatch;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineApplicationCRCMismatch = Instances[j].anyMezzanineApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineApplicationCRCMismatch[iseq] = Instances[j].mezzanineApplicationCRCMismatch[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineApplicationCRCMismatch[iseq] = Instances[j].mezzanineApplicationCRCMismatch[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_hardpointMonitorWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_hardpointMonitorWarning_d5ab85e8DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_hardpointMonitorWarning(MTM1M3_logevent_hardpointMonitorWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_hardpointMonitorWarning(data);
    sal[SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_hardpointMonitorWarning(MTM1M3_logevent_hardpointMonitorWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_hardpointMonitorWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_hardpointMonitorWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyWarning;
   data->anyMajorFault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMajorFault;
    for (int iseq=0;iseq<6;iseq++) {data->majorFault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.majorFault[iseq];}
   data->anyMinorFault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMinorFault;
    for (int iseq=0;iseq<6;iseq++) {data->minorFault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.minorFault[iseq];}
   data->anyFaultOverride = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyFaultOverride;
    for (int iseq=0;iseq<6;iseq++) {data->faultOverride[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.faultOverride[iseq];}
   data->anyInstrumentError = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyInstrumentError;
    for (int iseq=0;iseq<6;iseq++) {data->instrumentError[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.instrumentError[iseq];}
   data->anyMezzanineError = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineError;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineError[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineError[iseq];}
   data->anyMezzanineBootloaderActive = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineBootloaderActive;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineBootloaderActive[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineBootloaderActive[iseq];}
   data->anyUniqueIdCRCError = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {data->uniqueIdCRCError[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.uniqueIdCRCError[iseq];}
   data->anyApplicationTypeMismatch = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyApplicationTypeMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->applicationTypeMismatch[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.applicationTypeMismatch[iseq];}
   data->anyApplicationMissing = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {data->applicationMissing[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.applicationMissing[iseq];}
   data->anyApplicationCRCMismatch = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->applicationCRCMismatch[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.applicationCRCMismatch[iseq];}
   data->anyOneWireMissing = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyOneWireMissing;
    for (int iseq=0;iseq<6;iseq++) {data->oneWireMissing[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.oneWireMissing[iseq];}
   data->anyOneWire1Mismatch = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyOneWire1Mismatch;
    for (int iseq=0;iseq<6;iseq++) {data->oneWire1Mismatch[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.oneWire1Mismatch[iseq];}
   data->anyOneWire2Mismatch = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyOneWire2Mismatch;
    for (int iseq=0;iseq<6;iseq++) {data->oneWire2Mismatch[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.oneWire2Mismatch[iseq];}
   data->anyWatchdogReset = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyWatchdogReset;
    for (int iseq=0;iseq<6;iseq++) {data->watchdogReset[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.watchdogReset[iseq];}
   data->anyBrownOut = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyBrownOut;
    for (int iseq=0;iseq<6;iseq++) {data->brownOut[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.brownOut[iseq];}
   data->anyEventTrapReset = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {data->eventTrapReset[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.eventTrapReset[iseq];}
   data->anySSRPowerFault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anySSRPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->ssrPowerFault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.ssrPowerFault[iseq];}
   data->anyAuxPowerFault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyAuxPowerFault;
    for (int iseq=0;iseq<6;iseq++) {data->auxPowerFault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.auxPowerFault[iseq];}
   data->anyMezzanineS1AInterface1Fault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineS1AInterface1Fault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineS1AInterface1Fault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineS1AInterface1Fault[iseq];}
   data->anyMezzanineS1ALVDT1Fault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineS1ALVDT1Fault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineS1ALVDT1Fault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineS1ALVDT1Fault[iseq];}
   data->anyMezzanineS1AInterface2Fault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineS1AInterface2Fault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineS1AInterface2Fault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineS1AInterface2Fault[iseq];}
   data->anyMezzanineS1ALVDT2Fault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineS1ALVDT2Fault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineS1ALVDT2Fault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineS1ALVDT2Fault[iseq];}
   data->anyMezzanineUniqueIdCRCError = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineUniqueIdCRCError;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineUniqueIdCRCError[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineUniqueIdCRCError[iseq];}
   data->anyMezzanineEventTrapReset = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineEventTrapReset;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineEventTrapReset[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineEventTrapReset[iseq];}
   data->anyMezzanineDCPRS422ChipFault = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineDCPRS422ChipFault;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineDCPRS422ChipFault[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineDCPRS422ChipFault[iseq];}
   data->anyMezzanineApplicationMissing = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineApplicationMissing;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineApplicationMissing[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineApplicationMissing[iseq];}
   data->anyMezzanineApplicationCRCMismatch = lastSample_MTM1M3_logevent_hardpointMonitorWarning.anyMezzanineApplicationCRCMismatch;
    for (int iseq=0;iseq<6;iseq++) {data->mezzanineApplicationCRCMismatch[iseq] = lastSample_MTM1M3_logevent_hardpointMonitorWarning.mezzanineApplicationCRCMismatch[iseq];}
   data->priority = lastSample_MTM1M3_logevent_hardpointMonitorWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_hardpointMonitorWarning(MTM1M3_logevent_hardpointMonitorWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_hardpointMonitorWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_heartbeat_85347670 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_heartbeat");
  }
  MTM1M3::logevent_heartbeat_85347670DataWriter_var SALWriter = MTM1M3::logevent_heartbeat_85347670DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("85347670");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_heartbeat_85347670 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_heartbeat_85347670DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_heartbeat_85347670Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_heartbeat");
  }
  MTM1M3::logevent_heartbeat_85347670DataReader_var SALReader = MTM1M3::logevent_heartbeat_85347670DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_heartbeat_85347670DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_heartbeat_85347670DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_heartbeat_85347670DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_heartbeat(MTM1M3_logevent_heartbeatC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_heartbeat_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_heartbeat");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_heartbeat");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_heartbeat_85347670DataWriter_var SALWriter = MTM1M3::logevent_heartbeat_85347670DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_heartbeat_85347670 Instance;

  Instance.private_revCode = DDS::string_dup("85347670");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.heartbeat = data->heartbeat;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_heartbeat_85347670 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_heartbeat_85347670DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_heartbeat(MTM1M3_logevent_heartbeatC *data)
{
  MTM1M3::logevent_heartbeat_85347670Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_heartbeat");
  }
  int actorIdx = SAL__MTM1M3_logevent_heartbeat_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_heartbeat");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_heartbeat_85347670DataReader_var SALReader = MTM1M3::logevent_heartbeat_85347670DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_heartbeat_85347670DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_heartbeat_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_heartbeat_85347670DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->heartbeat = Instances[j].heartbeat;
    lastSample_MTM1M3_logevent_heartbeat.heartbeat = Instances[j].heartbeat;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_heartbeat.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_heartbeat_85347670DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_heartbeat(MTM1M3_logevent_heartbeatC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_heartbeat_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_heartbeat_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_heartbeat(data);
    sal[SAL__MTM1M3_logevent_heartbeat_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_heartbeat(MTM1M3_logevent_heartbeatC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_heartbeat(data);
    if (istatus == SAL__NO_UPDATES) {
   data->heartbeat = lastSample_MTM1M3_logevent_heartbeat.heartbeat;
   data->priority = lastSample_MTM1M3_logevent_heartbeat.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_heartbeat(MTM1M3_logevent_heartbeatC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_heartbeat_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_heartbeat_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_heartbeat(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_heartbeat_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_ilcWarning_22b9286f data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_ilcWarning");
  }
  MTM1M3::logevent_ilcWarning_22b9286fDataWriter_var SALWriter = MTM1M3::logevent_ilcWarning_22b9286fDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("22b9286f");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_ilcWarning_22b9286f writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_ilcWarning_22b9286fDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_ilcWarning_22b9286fSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_ilcWarning");
  }
  MTM1M3::logevent_ilcWarning_22b9286fDataReader_var SALReader = MTM1M3::logevent_ilcWarning_22b9286fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_ilcWarning_22b9286fDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_ilcWarning_22b9286fDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_ilcWarning_22b9286fDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_ilcWarning(MTM1M3_logevent_ilcWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_ilcWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_ilcWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_ilcWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_ilcWarning_22b9286fDataWriter_var SALWriter = MTM1M3::logevent_ilcWarning_22b9286fDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_ilcWarning_22b9286f Instance;

  Instance.private_revCode = DDS::string_dup("22b9286f");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.actuatorId = data->actuatorId;
    Instance.anyWarning = data->anyWarning;
    Instance.responseTimeout = data->responseTimeout;
    Instance.invalidCRC = data->invalidCRC;
    Instance.illegalFunction = data->illegalFunction;
    Instance.illegalDataValue = data->illegalDataValue;
    Instance.invalidLength = data->invalidLength;
    Instance.unknownSubnet = data->unknownSubnet;
    Instance.unknownAddress = data->unknownAddress;
    Instance.unknownFunction = data->unknownFunction;
    Instance.unknownProblem = data->unknownProblem;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_ilcWarning_22b9286f writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_ilcWarning_22b9286fDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_ilcWarning(MTM1M3_logevent_ilcWarningC *data)
{
  MTM1M3::logevent_ilcWarning_22b9286fSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_ilcWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_ilcWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_ilcWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_ilcWarning_22b9286fDataReader_var SALReader = MTM1M3::logevent_ilcWarning_22b9286fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_ilcWarning_22b9286fDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_ilcWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_ilcWarning_22b9286fDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_ilcWarning.timestamp = Instances[j].timestamp;
    data->actuatorId = Instances[j].actuatorId;
    lastSample_MTM1M3_logevent_ilcWarning.actuatorId = Instances[j].actuatorId;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_ilcWarning.anyWarning = Instances[j].anyWarning;
    data->responseTimeout = Instances[j].responseTimeout;
    lastSample_MTM1M3_logevent_ilcWarning.responseTimeout = Instances[j].responseTimeout;
    data->invalidCRC = Instances[j].invalidCRC;
    lastSample_MTM1M3_logevent_ilcWarning.invalidCRC = Instances[j].invalidCRC;
    data->illegalFunction = Instances[j].illegalFunction;
    lastSample_MTM1M3_logevent_ilcWarning.illegalFunction = Instances[j].illegalFunction;
    data->illegalDataValue = Instances[j].illegalDataValue;
    lastSample_MTM1M3_logevent_ilcWarning.illegalDataValue = Instances[j].illegalDataValue;
    data->invalidLength = Instances[j].invalidLength;
    lastSample_MTM1M3_logevent_ilcWarning.invalidLength = Instances[j].invalidLength;
    data->unknownSubnet = Instances[j].unknownSubnet;
    lastSample_MTM1M3_logevent_ilcWarning.unknownSubnet = Instances[j].unknownSubnet;
    data->unknownAddress = Instances[j].unknownAddress;
    lastSample_MTM1M3_logevent_ilcWarning.unknownAddress = Instances[j].unknownAddress;
    data->unknownFunction = Instances[j].unknownFunction;
    lastSample_MTM1M3_logevent_ilcWarning.unknownFunction = Instances[j].unknownFunction;
    data->unknownProblem = Instances[j].unknownProblem;
    lastSample_MTM1M3_logevent_ilcWarning.unknownProblem = Instances[j].unknownProblem;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_ilcWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_ilcWarning_22b9286fDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_ilcWarning(MTM1M3_logevent_ilcWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_ilcWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_ilcWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_ilcWarning(data);
    sal[SAL__MTM1M3_logevent_ilcWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_ilcWarning(MTM1M3_logevent_ilcWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_ilcWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_ilcWarning.timestamp;
   data->actuatorId = lastSample_MTM1M3_logevent_ilcWarning.actuatorId;
   data->anyWarning = lastSample_MTM1M3_logevent_ilcWarning.anyWarning;
   data->responseTimeout = lastSample_MTM1M3_logevent_ilcWarning.responseTimeout;
   data->invalidCRC = lastSample_MTM1M3_logevent_ilcWarning.invalidCRC;
   data->illegalFunction = lastSample_MTM1M3_logevent_ilcWarning.illegalFunction;
   data->illegalDataValue = lastSample_MTM1M3_logevent_ilcWarning.illegalDataValue;
   data->invalidLength = lastSample_MTM1M3_logevent_ilcWarning.invalidLength;
   data->unknownSubnet = lastSample_MTM1M3_logevent_ilcWarning.unknownSubnet;
   data->unknownAddress = lastSample_MTM1M3_logevent_ilcWarning.unknownAddress;
   data->unknownFunction = lastSample_MTM1M3_logevent_ilcWarning.unknownFunction;
   data->unknownProblem = lastSample_MTM1M3_logevent_ilcWarning.unknownProblem;
   data->priority = lastSample_MTM1M3_logevent_ilcWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_ilcWarning(MTM1M3_logevent_ilcWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_ilcWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_ilcWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_ilcWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_ilcWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_inclinometerSensorWarning_4d115eb8 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_inclinometerSensorWarning");
  }
  MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataWriter_var SALWriter = MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("4d115eb8");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_inclinometerSensorWarning_4d115eb8 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_inclinometerSensorWarning_4d115eb8Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_inclinometerSensorWarning");
  }
  MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader_var SALReader = MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_inclinometerSensorWarning(MTM1M3_logevent_inclinometerSensorWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_inclinometerSensorWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_inclinometerSensorWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataWriter_var SALWriter = MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_inclinometerSensorWarning_4d115eb8 Instance;

  Instance.private_revCode = DDS::string_dup("4d115eb8");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.sensorReportsIllegalFunction = data->sensorReportsIllegalFunction;
    Instance.sensorReportsIllegalDataAddress = data->sensorReportsIllegalDataAddress;
    Instance.responseTimeout = data->responseTimeout;
    Instance.invalidCRC = data->invalidCRC;
    Instance.invalidLength = data->invalidLength;
    Instance.unknownAddress = data->unknownAddress;
    Instance.unknownFunction = data->unknownFunction;
    Instance.unknownProblem = data->unknownProblem;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_inclinometerSensorWarning_4d115eb8 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_inclinometerSensorWarning(MTM1M3_logevent_inclinometerSensorWarningC *data)
{
  MTM1M3::logevent_inclinometerSensorWarning_4d115eb8Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_inclinometerSensorWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_inclinometerSensorWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader_var SALReader = MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.anyWarning = Instances[j].anyWarning;
    data->sensorReportsIllegalFunction = Instances[j].sensorReportsIllegalFunction;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.sensorReportsIllegalFunction = Instances[j].sensorReportsIllegalFunction;
    data->sensorReportsIllegalDataAddress = Instances[j].sensorReportsIllegalDataAddress;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.sensorReportsIllegalDataAddress = Instances[j].sensorReportsIllegalDataAddress;
    data->responseTimeout = Instances[j].responseTimeout;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.responseTimeout = Instances[j].responseTimeout;
    data->invalidCRC = Instances[j].invalidCRC;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.invalidCRC = Instances[j].invalidCRC;
    data->invalidLength = Instances[j].invalidLength;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.invalidLength = Instances[j].invalidLength;
    data->unknownAddress = Instances[j].unknownAddress;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.unknownAddress = Instances[j].unknownAddress;
    data->unknownFunction = Instances[j].unknownFunction;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.unknownFunction = Instances[j].unknownFunction;
    data->unknownProblem = Instances[j].unknownProblem;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.unknownProblem = Instances[j].unknownProblem;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_inclinometerSensorWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_inclinometerSensorWarning_4d115eb8DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_inclinometerSensorWarning(MTM1M3_logevent_inclinometerSensorWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_inclinometerSensorWarning(data);
    sal[SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_inclinometerSensorWarning(MTM1M3_logevent_inclinometerSensorWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_inclinometerSensorWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_inclinometerSensorWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_inclinometerSensorWarning.anyWarning;
   data->sensorReportsIllegalFunction = lastSample_MTM1M3_logevent_inclinometerSensorWarning.sensorReportsIllegalFunction;
   data->sensorReportsIllegalDataAddress = lastSample_MTM1M3_logevent_inclinometerSensorWarning.sensorReportsIllegalDataAddress;
   data->responseTimeout = lastSample_MTM1M3_logevent_inclinometerSensorWarning.responseTimeout;
   data->invalidCRC = lastSample_MTM1M3_logevent_inclinometerSensorWarning.invalidCRC;
   data->invalidLength = lastSample_MTM1M3_logevent_inclinometerSensorWarning.invalidLength;
   data->unknownAddress = lastSample_MTM1M3_logevent_inclinometerSensorWarning.unknownAddress;
   data->unknownFunction = lastSample_MTM1M3_logevent_inclinometerSensorWarning.unknownFunction;
   data->unknownProblem = lastSample_MTM1M3_logevent_inclinometerSensorWarning.unknownProblem;
   data->priority = lastSample_MTM1M3_logevent_inclinometerSensorWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_inclinometerSensorWarning(MTM1M3_logevent_inclinometerSensorWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_inclinometerSensorWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_interlockStatus_5c0ae7f7 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_interlockStatus");
  }
  MTM1M3::logevent_interlockStatus_5c0ae7f7DataWriter_var SALWriter = MTM1M3::logevent_interlockStatus_5c0ae7f7DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("5c0ae7f7");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_interlockStatus_5c0ae7f7 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_interlockStatus_5c0ae7f7DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_interlockStatus_5c0ae7f7Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_interlockStatus");
  }
  MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader_var SALReader = MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_interlockStatus(MTM1M3_logevent_interlockStatusC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_interlockStatus_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_interlockStatus");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_interlockStatus");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_interlockStatus_5c0ae7f7DataWriter_var SALWriter = MTM1M3::logevent_interlockStatus_5c0ae7f7DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_interlockStatus_5c0ae7f7 Instance;

  Instance.private_revCode = DDS::string_dup("5c0ae7f7");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.heartbeatCommandedState = data->heartbeatCommandedState;
    Instance.heartbeatOutputState = data->heartbeatOutputState;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_interlockStatus_5c0ae7f7 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_interlockStatus_5c0ae7f7DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_interlockStatus(MTM1M3_logevent_interlockStatusC *data)
{
  MTM1M3::logevent_interlockStatus_5c0ae7f7Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_interlockStatus");
  }
  int actorIdx = SAL__MTM1M3_logevent_interlockStatus_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_interlockStatus");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader_var SALReader = MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_interlockStatus_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_interlockStatus.timestamp = Instances[j].timestamp;
    data->heartbeatCommandedState = Instances[j].heartbeatCommandedState;
    lastSample_MTM1M3_logevent_interlockStatus.heartbeatCommandedState = Instances[j].heartbeatCommandedState;
    data->heartbeatOutputState = Instances[j].heartbeatOutputState;
    lastSample_MTM1M3_logevent_interlockStatus.heartbeatOutputState = Instances[j].heartbeatOutputState;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_interlockStatus.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_interlockStatus_5c0ae7f7DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_interlockStatus(MTM1M3_logevent_interlockStatusC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_interlockStatus_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_interlockStatus_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_interlockStatus(data);
    sal[SAL__MTM1M3_logevent_interlockStatus_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_interlockStatus(MTM1M3_logevent_interlockStatusC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_interlockStatus(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_interlockStatus.timestamp;
   data->heartbeatCommandedState = lastSample_MTM1M3_logevent_interlockStatus.heartbeatCommandedState;
   data->heartbeatOutputState = lastSample_MTM1M3_logevent_interlockStatus.heartbeatOutputState;
   data->priority = lastSample_MTM1M3_logevent_interlockStatus.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_interlockStatus(MTM1M3_logevent_interlockStatusC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_interlockStatus_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_interlockStatus_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_interlockStatus(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_interlockStatus_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_interlockWarning_bc69e2ea data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_interlockWarning");
  }
  MTM1M3::logevent_interlockWarning_bc69e2eaDataWriter_var SALWriter = MTM1M3::logevent_interlockWarning_bc69e2eaDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("bc69e2ea");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_interlockWarning_bc69e2ea writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_interlockWarning_bc69e2eaDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_interlockWarning_bc69e2eaSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_interlockWarning");
  }
  MTM1M3::logevent_interlockWarning_bc69e2eaDataReader_var SALReader = MTM1M3::logevent_interlockWarning_bc69e2eaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_interlockWarning_bc69e2eaDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_interlockWarning_bc69e2eaDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_interlockWarning_bc69e2eaDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_interlockWarning(MTM1M3_logevent_interlockWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_interlockWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_interlockWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_interlockWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_interlockWarning_bc69e2eaDataWriter_var SALWriter = MTM1M3::logevent_interlockWarning_bc69e2eaDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_interlockWarning_bc69e2ea Instance;

  Instance.private_revCode = DDS::string_dup("bc69e2ea");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.heartbeatStateOutputMismatch = data->heartbeatStateOutputMismatch;
    Instance.auxPowerNetworksOff = data->auxPowerNetworksOff;
    Instance.thermalEquipmentOff = data->thermalEquipmentOff;
    Instance.airSupplyOff = data->airSupplyOff;
    Instance.tmaMotionStop = data->tmaMotionStop;
    Instance.gisHeartbeatLost = data->gisHeartbeatLost;
    Instance.cabinetDoorOpen = data->cabinetDoorOpen;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_interlockWarning_bc69e2ea writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_interlockWarning_bc69e2eaDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_interlockWarning(MTM1M3_logevent_interlockWarningC *data)
{
  MTM1M3::logevent_interlockWarning_bc69e2eaSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_interlockWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_interlockWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_interlockWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_interlockWarning_bc69e2eaDataReader_var SALReader = MTM1M3::logevent_interlockWarning_bc69e2eaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_interlockWarning_bc69e2eaDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_interlockWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_interlockWarning_bc69e2eaDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_interlockWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_interlockWarning.anyWarning = Instances[j].anyWarning;
    data->heartbeatStateOutputMismatch = Instances[j].heartbeatStateOutputMismatch;
    lastSample_MTM1M3_logevent_interlockWarning.heartbeatStateOutputMismatch = Instances[j].heartbeatStateOutputMismatch;
    data->auxPowerNetworksOff = Instances[j].auxPowerNetworksOff;
    lastSample_MTM1M3_logevent_interlockWarning.auxPowerNetworksOff = Instances[j].auxPowerNetworksOff;
    data->thermalEquipmentOff = Instances[j].thermalEquipmentOff;
    lastSample_MTM1M3_logevent_interlockWarning.thermalEquipmentOff = Instances[j].thermalEquipmentOff;
    data->airSupplyOff = Instances[j].airSupplyOff;
    lastSample_MTM1M3_logevent_interlockWarning.airSupplyOff = Instances[j].airSupplyOff;
    data->tmaMotionStop = Instances[j].tmaMotionStop;
    lastSample_MTM1M3_logevent_interlockWarning.tmaMotionStop = Instances[j].tmaMotionStop;
    data->gisHeartbeatLost = Instances[j].gisHeartbeatLost;
    lastSample_MTM1M3_logevent_interlockWarning.gisHeartbeatLost = Instances[j].gisHeartbeatLost;
    data->cabinetDoorOpen = Instances[j].cabinetDoorOpen;
    lastSample_MTM1M3_logevent_interlockWarning.cabinetDoorOpen = Instances[j].cabinetDoorOpen;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_interlockWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_interlockWarning_bc69e2eaDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_interlockWarning(MTM1M3_logevent_interlockWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_interlockWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_interlockWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_interlockWarning(data);
    sal[SAL__MTM1M3_logevent_interlockWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_interlockWarning(MTM1M3_logevent_interlockWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_interlockWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_interlockWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_interlockWarning.anyWarning;
   data->heartbeatStateOutputMismatch = lastSample_MTM1M3_logevent_interlockWarning.heartbeatStateOutputMismatch;
   data->auxPowerNetworksOff = lastSample_MTM1M3_logevent_interlockWarning.auxPowerNetworksOff;
   data->thermalEquipmentOff = lastSample_MTM1M3_logevent_interlockWarning.thermalEquipmentOff;
   data->airSupplyOff = lastSample_MTM1M3_logevent_interlockWarning.airSupplyOff;
   data->tmaMotionStop = lastSample_MTM1M3_logevent_interlockWarning.tmaMotionStop;
   data->gisHeartbeatLost = lastSample_MTM1M3_logevent_interlockWarning.gisHeartbeatLost;
   data->cabinetDoorOpen = lastSample_MTM1M3_logevent_interlockWarning.cabinetDoorOpen;
   data->priority = lastSample_MTM1M3_logevent_interlockWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_interlockWarning(MTM1M3_logevent_interlockWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_interlockWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_interlockWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_interlockWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_interlockWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_logLevel_83d14d18 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_logLevel");
  }
  MTM1M3::logevent_logLevel_83d14d18DataWriter_var SALWriter = MTM1M3::logevent_logLevel_83d14d18DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("83d14d18");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_logLevel_83d14d18 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_logLevel_83d14d18DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_logLevel_83d14d18Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_logLevel");
  }
  MTM1M3::logevent_logLevel_83d14d18DataReader_var SALReader = MTM1M3::logevent_logLevel_83d14d18DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_logLevel_83d14d18DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_logLevel_83d14d18DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_logLevel_83d14d18DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_logLevel(MTM1M3_logevent_logLevelC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_logLevel_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_logLevel");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_logLevel");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_logLevel_83d14d18DataWriter_var SALWriter = MTM1M3::logevent_logLevel_83d14d18DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_logLevel_83d14d18 Instance;

  Instance.private_revCode = DDS::string_dup("83d14d18");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.level = data->level;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_logLevel_83d14d18 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_logLevel_83d14d18DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_logLevel(MTM1M3_logevent_logLevelC *data)
{
  MTM1M3::logevent_logLevel_83d14d18Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_logLevel");
  }
  int actorIdx = SAL__MTM1M3_logevent_logLevel_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_logLevel");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_logLevel_83d14d18DataReader_var SALReader = MTM1M3::logevent_logLevel_83d14d18DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_logLevel_83d14d18DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_logLevel_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_logLevel_83d14d18DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->level = Instances[j].level;
    lastSample_MTM1M3_logevent_logLevel.level = Instances[j].level;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_logLevel.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_logLevel_83d14d18DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_logLevel(MTM1M3_logevent_logLevelC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_logLevel_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_logLevel_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_logLevel(data);
    sal[SAL__MTM1M3_logevent_logLevel_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_logLevel(MTM1M3_logevent_logLevelC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_logLevel(data);
    if (istatus == SAL__NO_UPDATES) {
   data->level = lastSample_MTM1M3_logevent_logLevel.level;
   data->priority = lastSample_MTM1M3_logevent_logLevel.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_logLevel(MTM1M3_logevent_logLevelC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_logLevel_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_logLevel_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_logLevel(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_logLevel_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_logMessage_60a1ee35 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_logMessage");
  }
  MTM1M3::logevent_logMessage_60a1ee35DataWriter_var SALWriter = MTM1M3::logevent_logMessage_60a1ee35DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("60a1ee35");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_logMessage_60a1ee35 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_logMessage_60a1ee35DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_logMessage_60a1ee35Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_logMessage");
  }
  MTM1M3::logevent_logMessage_60a1ee35DataReader_var SALReader = MTM1M3::logevent_logMessage_60a1ee35DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_logMessage_60a1ee35DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_logMessage_60a1ee35DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_logMessage_60a1ee35DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_logMessage(MTM1M3_logevent_logMessageC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_logMessage_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_logMessage");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_logMessage");
  }
    if ( data->message.length() > 128 ) {
       throw std::length_error("Item message exceeds string length");
    }
    if ( data->traceback.length() > 128 ) {
       throw std::length_error("Item traceback exceeds string length");
    }
    if ( data->filePath.length() > 128 ) {
       throw std::length_error("Item filePath exceeds string length");
    }
    if ( data->functionName.length() > 128 ) {
       throw std::length_error("Item functionName exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_logMessage_60a1ee35DataWriter_var SALWriter = MTM1M3::logevent_logMessage_60a1ee35DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_logMessage_60a1ee35 Instance;

  Instance.private_revCode = DDS::string_dup("60a1ee35");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.level = data->level;
    Instance.message = DDS::string_dup(data->message.c_str());
    Instance.traceback = DDS::string_dup(data->traceback.c_str());
    Instance.filePath = DDS::string_dup(data->filePath.c_str());
    Instance.functionName = DDS::string_dup(data->functionName.c_str());
    Instance.lineNumber = data->lineNumber;
    Instance.process = data->process;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_logMessage_60a1ee35 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_logMessage_60a1ee35DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_logMessage(MTM1M3_logevent_logMessageC *data)
{
  MTM1M3::logevent_logMessage_60a1ee35Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_logMessage");
  }
  int actorIdx = SAL__MTM1M3_logevent_logMessage_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_logMessage");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_logMessage_60a1ee35DataReader_var SALReader = MTM1M3::logevent_logMessage_60a1ee35DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_logMessage_60a1ee35DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_logMessage_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_logMessage_60a1ee35DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->level = Instances[j].level;
    lastSample_MTM1M3_logevent_logMessage.level = Instances[j].level;
    data->message=Instances[j].message.m_ptr;
    lastSample_MTM1M3_logevent_logMessage.message=Instances[j].message.m_ptr;
    data->traceback=Instances[j].traceback.m_ptr;
    lastSample_MTM1M3_logevent_logMessage.traceback=Instances[j].traceback.m_ptr;
    data->filePath=Instances[j].filePath.m_ptr;
    lastSample_MTM1M3_logevent_logMessage.filePath=Instances[j].filePath.m_ptr;
    data->functionName=Instances[j].functionName.m_ptr;
    lastSample_MTM1M3_logevent_logMessage.functionName=Instances[j].functionName.m_ptr;
    data->lineNumber = Instances[j].lineNumber;
    lastSample_MTM1M3_logevent_logMessage.lineNumber = Instances[j].lineNumber;
    data->process = Instances[j].process;
    lastSample_MTM1M3_logevent_logMessage.process = Instances[j].process;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_logMessage.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_logMessage_60a1ee35DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_logMessage(MTM1M3_logevent_logMessageC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_logMessage_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_logMessage_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_logMessage(data);
    sal[SAL__MTM1M3_logevent_logMessage_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_logMessage(MTM1M3_logevent_logMessageC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_logMessage(data);
    if (istatus == SAL__NO_UPDATES) {
   data->level = lastSample_MTM1M3_logevent_logMessage.level;
   data->message = lastSample_MTM1M3_logevent_logMessage.message;
   data->traceback = lastSample_MTM1M3_logevent_logMessage.traceback;
   data->filePath = lastSample_MTM1M3_logevent_logMessage.filePath;
   data->functionName = lastSample_MTM1M3_logevent_logMessage.functionName;
   data->lineNumber = lastSample_MTM1M3_logevent_logMessage.lineNumber;
   data->process = lastSample_MTM1M3_logevent_logMessage.process;
   data->priority = lastSample_MTM1M3_logevent_logMessage.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_logMessage(MTM1M3_logevent_logMessageC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_logMessage_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_logMessage_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_logMessage(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_logMessage_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_modbusResponse_9c022b06 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_modbusResponse");
  }
  MTM1M3::logevent_modbusResponse_9c022b06DataWriter_var SALWriter = MTM1M3::logevent_modbusResponse_9c022b06DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("9c022b06");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_modbusResponse_9c022b06 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_modbusResponse_9c022b06DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_modbusResponse_9c022b06Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_modbusResponse");
  }
  MTM1M3::logevent_modbusResponse_9c022b06DataReader_var SALReader = MTM1M3::logevent_modbusResponse_9c022b06DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_modbusResponse_9c022b06DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_modbusResponse_9c022b06DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_modbusResponse_9c022b06DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_modbusResponse(MTM1M3_logevent_modbusResponseC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_modbusResponse_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_modbusResponse");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_modbusResponse");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_modbusResponse_9c022b06DataWriter_var SALWriter = MTM1M3::logevent_modbusResponse_9c022b06DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_modbusResponse_9c022b06 Instance;

  Instance.private_revCode = DDS::string_dup("9c022b06");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.responseValid = data->responseValid;
    Instance.address = data->address;
    Instance.functionCode = data->functionCode;
    Instance.dataLength = data->dataLength;
    for (int iseq=0;iseq<252;iseq++) {Instance.data[iseq] = data->data[iseq];}
    Instance.crc = data->crc;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_modbusResponse_9c022b06 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_modbusResponse_9c022b06DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_modbusResponse(MTM1M3_logevent_modbusResponseC *data)
{
  MTM1M3::logevent_modbusResponse_9c022b06Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_modbusResponse");
  }
  int actorIdx = SAL__MTM1M3_logevent_modbusResponse_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_modbusResponse");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_modbusResponse_9c022b06DataReader_var SALReader = MTM1M3::logevent_modbusResponse_9c022b06DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_modbusResponse_9c022b06DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_modbusResponse_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_modbusResponse_9c022b06DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_modbusResponse.timestamp = Instances[j].timestamp;
    data->responseValid = Instances[j].responseValid;
    lastSample_MTM1M3_logevent_modbusResponse.responseValid = Instances[j].responseValid;
    data->address = Instances[j].address;
    lastSample_MTM1M3_logevent_modbusResponse.address = Instances[j].address;
    data->functionCode = Instances[j].functionCode;
    lastSample_MTM1M3_logevent_modbusResponse.functionCode = Instances[j].functionCode;
    data->dataLength = Instances[j].dataLength;
    lastSample_MTM1M3_logevent_modbusResponse.dataLength = Instances[j].dataLength;
    for (int iseq=0;iseq<252;iseq++) {data->data[iseq] = Instances[j].data[iseq];}
    for (int iseq=0;iseq<252;iseq++) {lastSample_MTM1M3_logevent_modbusResponse.data[iseq] = Instances[j].data[iseq];}
    data->crc = Instances[j].crc;
    lastSample_MTM1M3_logevent_modbusResponse.crc = Instances[j].crc;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_modbusResponse.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_modbusResponse_9c022b06DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_modbusResponse(MTM1M3_logevent_modbusResponseC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_modbusResponse_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_modbusResponse_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_modbusResponse(data);
    sal[SAL__MTM1M3_logevent_modbusResponse_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_modbusResponse(MTM1M3_logevent_modbusResponseC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_modbusResponse(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_modbusResponse.timestamp;
   data->responseValid = lastSample_MTM1M3_logevent_modbusResponse.responseValid;
   data->address = lastSample_MTM1M3_logevent_modbusResponse.address;
   data->functionCode = lastSample_MTM1M3_logevent_modbusResponse.functionCode;
   data->dataLength = lastSample_MTM1M3_logevent_modbusResponse.dataLength;
    for (int iseq=0;iseq<252;iseq++) {data->data[iseq] = lastSample_MTM1M3_logevent_modbusResponse.data[iseq];}
   data->crc = lastSample_MTM1M3_logevent_modbusResponse.crc;
   data->priority = lastSample_MTM1M3_logevent_modbusResponse.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_modbusResponse(MTM1M3_logevent_modbusResponseC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_modbusResponse_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_modbusResponse_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_modbusResponse(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_modbusResponse_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_pidInfo_858eca99 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_pidInfo");
  }
  MTM1M3::logevent_pidInfo_858eca99DataWriter_var SALWriter = MTM1M3::logevent_pidInfo_858eca99DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("858eca99");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_pidInfo_858eca99 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_pidInfo_858eca99DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_pidInfo_858eca99Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_pidInfo");
  }
  MTM1M3::logevent_pidInfo_858eca99DataReader_var SALReader = MTM1M3::logevent_pidInfo_858eca99DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_pidInfo_858eca99DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_pidInfo_858eca99DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_pidInfo_858eca99DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_pidInfo(MTM1M3_logevent_pidInfoC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_pidInfo_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_pidInfo");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_pidInfo");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_pidInfo_858eca99DataWriter_var SALWriter = MTM1M3::logevent_pidInfo_858eca99DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_pidInfo_858eca99 Instance;

  Instance.private_revCode = DDS::string_dup("858eca99");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<6;iseq++) {Instance.timestep[iseq] = data->timestep[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.p[iseq] = data->p[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.i[iseq] = data->i[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.d[iseq] = data->d[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.n[iseq] = data->n[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.calculatedA[iseq] = data->calculatedA[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.calculatedB[iseq] = data->calculatedB[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.calculatedC[iseq] = data->calculatedC[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.calculatedD[iseq] = data->calculatedD[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.calculatedE[iseq] = data->calculatedE[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_pidInfo_858eca99 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_pidInfo_858eca99DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_pidInfo(MTM1M3_logevent_pidInfoC *data)
{
  MTM1M3::logevent_pidInfo_858eca99Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_pidInfo");
  }
  int actorIdx = SAL__MTM1M3_logevent_pidInfo_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_pidInfo");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_pidInfo_858eca99DataReader_var SALReader = MTM1M3::logevent_pidInfo_858eca99DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_pidInfo_858eca99DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_pidInfo_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_pidInfo_858eca99DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_pidInfo.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->timestep[iseq] = Instances[j].timestep[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.timestep[iseq] = Instances[j].timestep[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->p[iseq] = Instances[j].p[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.p[iseq] = Instances[j].p[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->i[iseq] = Instances[j].i[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.i[iseq] = Instances[j].i[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->d[iseq] = Instances[j].d[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.d[iseq] = Instances[j].d[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->n[iseq] = Instances[j].n[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.n[iseq] = Instances[j].n[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedA[iseq] = Instances[j].calculatedA[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.calculatedA[iseq] = Instances[j].calculatedA[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedB[iseq] = Instances[j].calculatedB[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.calculatedB[iseq] = Instances[j].calculatedB[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedC[iseq] = Instances[j].calculatedC[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.calculatedC[iseq] = Instances[j].calculatedC[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedD[iseq] = Instances[j].calculatedD[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.calculatedD[iseq] = Instances[j].calculatedD[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedE[iseq] = Instances[j].calculatedE[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_logevent_pidInfo.calculatedE[iseq] = Instances[j].calculatedE[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_pidInfo.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_pidInfo_858eca99DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_pidInfo(MTM1M3_logevent_pidInfoC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_pidInfo_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_pidInfo_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_pidInfo(data);
    sal[SAL__MTM1M3_logevent_pidInfo_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_pidInfo(MTM1M3_logevent_pidInfoC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_pidInfo(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_pidInfo.timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->timestep[iseq] = lastSample_MTM1M3_logevent_pidInfo.timestep[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->p[iseq] = lastSample_MTM1M3_logevent_pidInfo.p[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->i[iseq] = lastSample_MTM1M3_logevent_pidInfo.i[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->d[iseq] = lastSample_MTM1M3_logevent_pidInfo.d[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->n[iseq] = lastSample_MTM1M3_logevent_pidInfo.n[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedA[iseq] = lastSample_MTM1M3_logevent_pidInfo.calculatedA[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedB[iseq] = lastSample_MTM1M3_logevent_pidInfo.calculatedB[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedC[iseq] = lastSample_MTM1M3_logevent_pidInfo.calculatedC[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedD[iseq] = lastSample_MTM1M3_logevent_pidInfo.calculatedD[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->calculatedE[iseq] = lastSample_MTM1M3_logevent_pidInfo.calculatedE[iseq];}
   data->priority = lastSample_MTM1M3_logevent_pidInfo.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_pidInfo(MTM1M3_logevent_pidInfoC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_pidInfo_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_pidInfo_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_pidInfo(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_pidInfo_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_powerStatus_846d5845 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_powerStatus");
  }
  MTM1M3::logevent_powerStatus_846d5845DataWriter_var SALWriter = MTM1M3::logevent_powerStatus_846d5845DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("846d5845");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_powerStatus_846d5845 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_powerStatus_846d5845DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_powerStatus_846d5845Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_powerStatus");
  }
  MTM1M3::logevent_powerStatus_846d5845DataReader_var SALReader = MTM1M3::logevent_powerStatus_846d5845DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_powerStatus_846d5845DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_powerStatus_846d5845DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_powerStatus_846d5845DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_powerStatus(MTM1M3_logevent_powerStatusC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_powerStatus_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_powerStatus");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_powerStatus");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_powerStatus_846d5845DataWriter_var SALWriter = MTM1M3::logevent_powerStatus_846d5845DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_powerStatus_846d5845 Instance;

  Instance.private_revCode = DDS::string_dup("846d5845");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.powerNetworkACommandedOn = data->powerNetworkACommandedOn;
    Instance.powerNetworkAOutputOn = data->powerNetworkAOutputOn;
    Instance.powerNetworkBCommandedOn = data->powerNetworkBCommandedOn;
    Instance.powerNetworkBOutputOn = data->powerNetworkBOutputOn;
    Instance.powerNetworkCCommandedOn = data->powerNetworkCCommandedOn;
    Instance.powerNetworkCOutputOn = data->powerNetworkCOutputOn;
    Instance.powerNetworkDCommandedOn = data->powerNetworkDCommandedOn;
    Instance.powerNetworkDOutputOn = data->powerNetworkDOutputOn;
    Instance.auxPowerNetworkACommandedOn = data->auxPowerNetworkACommandedOn;
    Instance.auxPowerNetworkAOutputOn = data->auxPowerNetworkAOutputOn;
    Instance.auxPowerNetworkBCommandedOn = data->auxPowerNetworkBCommandedOn;
    Instance.auxPowerNetworkBOutputOn = data->auxPowerNetworkBOutputOn;
    Instance.auxPowerNetworkCCommandedOn = data->auxPowerNetworkCCommandedOn;
    Instance.auxPowerNetworkCOutputOn = data->auxPowerNetworkCOutputOn;
    Instance.auxPowerNetworkDCommandedOn = data->auxPowerNetworkDCommandedOn;
    Instance.auxPowerNetworkDOutputOn = data->auxPowerNetworkDOutputOn;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_powerStatus_846d5845 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_powerStatus_846d5845DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_powerStatus(MTM1M3_logevent_powerStatusC *data)
{
  MTM1M3::logevent_powerStatus_846d5845Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_powerStatus");
  }
  int actorIdx = SAL__MTM1M3_logevent_powerStatus_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_powerStatus");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_powerStatus_846d5845DataReader_var SALReader = MTM1M3::logevent_powerStatus_846d5845DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_powerStatus_846d5845DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_powerStatus_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_powerStatus_846d5845DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_powerStatus.timestamp = Instances[j].timestamp;
    data->powerNetworkACommandedOn = Instances[j].powerNetworkACommandedOn;
    lastSample_MTM1M3_logevent_powerStatus.powerNetworkACommandedOn = Instances[j].powerNetworkACommandedOn;
    data->powerNetworkAOutputOn = Instances[j].powerNetworkAOutputOn;
    lastSample_MTM1M3_logevent_powerStatus.powerNetworkAOutputOn = Instances[j].powerNetworkAOutputOn;
    data->powerNetworkBCommandedOn = Instances[j].powerNetworkBCommandedOn;
    lastSample_MTM1M3_logevent_powerStatus.powerNetworkBCommandedOn = Instances[j].powerNetworkBCommandedOn;
    data->powerNetworkBOutputOn = Instances[j].powerNetworkBOutputOn;
    lastSample_MTM1M3_logevent_powerStatus.powerNetworkBOutputOn = Instances[j].powerNetworkBOutputOn;
    data->powerNetworkCCommandedOn = Instances[j].powerNetworkCCommandedOn;
    lastSample_MTM1M3_logevent_powerStatus.powerNetworkCCommandedOn = Instances[j].powerNetworkCCommandedOn;
    data->powerNetworkCOutputOn = Instances[j].powerNetworkCOutputOn;
    lastSample_MTM1M3_logevent_powerStatus.powerNetworkCOutputOn = Instances[j].powerNetworkCOutputOn;
    data->powerNetworkDCommandedOn = Instances[j].powerNetworkDCommandedOn;
    lastSample_MTM1M3_logevent_powerStatus.powerNetworkDCommandedOn = Instances[j].powerNetworkDCommandedOn;
    data->powerNetworkDOutputOn = Instances[j].powerNetworkDOutputOn;
    lastSample_MTM1M3_logevent_powerStatus.powerNetworkDOutputOn = Instances[j].powerNetworkDOutputOn;
    data->auxPowerNetworkACommandedOn = Instances[j].auxPowerNetworkACommandedOn;
    lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkACommandedOn = Instances[j].auxPowerNetworkACommandedOn;
    data->auxPowerNetworkAOutputOn = Instances[j].auxPowerNetworkAOutputOn;
    lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkAOutputOn = Instances[j].auxPowerNetworkAOutputOn;
    data->auxPowerNetworkBCommandedOn = Instances[j].auxPowerNetworkBCommandedOn;
    lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkBCommandedOn = Instances[j].auxPowerNetworkBCommandedOn;
    data->auxPowerNetworkBOutputOn = Instances[j].auxPowerNetworkBOutputOn;
    lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkBOutputOn = Instances[j].auxPowerNetworkBOutputOn;
    data->auxPowerNetworkCCommandedOn = Instances[j].auxPowerNetworkCCommandedOn;
    lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkCCommandedOn = Instances[j].auxPowerNetworkCCommandedOn;
    data->auxPowerNetworkCOutputOn = Instances[j].auxPowerNetworkCOutputOn;
    lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkCOutputOn = Instances[j].auxPowerNetworkCOutputOn;
    data->auxPowerNetworkDCommandedOn = Instances[j].auxPowerNetworkDCommandedOn;
    lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkDCommandedOn = Instances[j].auxPowerNetworkDCommandedOn;
    data->auxPowerNetworkDOutputOn = Instances[j].auxPowerNetworkDOutputOn;
    lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkDOutputOn = Instances[j].auxPowerNetworkDOutputOn;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_powerStatus.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_powerStatus_846d5845DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_powerStatus(MTM1M3_logevent_powerStatusC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_powerStatus_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_powerStatus_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_powerStatus(data);
    sal[SAL__MTM1M3_logevent_powerStatus_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_powerStatus(MTM1M3_logevent_powerStatusC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_powerStatus(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_powerStatus.timestamp;
   data->powerNetworkACommandedOn = lastSample_MTM1M3_logevent_powerStatus.powerNetworkACommandedOn;
   data->powerNetworkAOutputOn = lastSample_MTM1M3_logevent_powerStatus.powerNetworkAOutputOn;
   data->powerNetworkBCommandedOn = lastSample_MTM1M3_logevent_powerStatus.powerNetworkBCommandedOn;
   data->powerNetworkBOutputOn = lastSample_MTM1M3_logevent_powerStatus.powerNetworkBOutputOn;
   data->powerNetworkCCommandedOn = lastSample_MTM1M3_logevent_powerStatus.powerNetworkCCommandedOn;
   data->powerNetworkCOutputOn = lastSample_MTM1M3_logevent_powerStatus.powerNetworkCOutputOn;
   data->powerNetworkDCommandedOn = lastSample_MTM1M3_logevent_powerStatus.powerNetworkDCommandedOn;
   data->powerNetworkDOutputOn = lastSample_MTM1M3_logevent_powerStatus.powerNetworkDOutputOn;
   data->auxPowerNetworkACommandedOn = lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkACommandedOn;
   data->auxPowerNetworkAOutputOn = lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkAOutputOn;
   data->auxPowerNetworkBCommandedOn = lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkBCommandedOn;
   data->auxPowerNetworkBOutputOn = lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkBOutputOn;
   data->auxPowerNetworkCCommandedOn = lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkCCommandedOn;
   data->auxPowerNetworkCOutputOn = lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkCOutputOn;
   data->auxPowerNetworkDCommandedOn = lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkDCommandedOn;
   data->auxPowerNetworkDOutputOn = lastSample_MTM1M3_logevent_powerStatus.auxPowerNetworkDOutputOn;
   data->priority = lastSample_MTM1M3_logevent_powerStatus.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_powerStatus(MTM1M3_logevent_powerStatusC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_powerStatus_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_powerStatus_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_powerStatus(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_powerStatus_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_powerSupplyStatus_9f37ac09 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_powerSupplyStatus");
  }
  MTM1M3::logevent_powerSupplyStatus_9f37ac09DataWriter_var SALWriter = MTM1M3::logevent_powerSupplyStatus_9f37ac09DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("9f37ac09");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_powerSupplyStatus_9f37ac09 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_powerSupplyStatus_9f37ac09DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_powerSupplyStatus_9f37ac09Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_powerSupplyStatus");
  }
  MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader_var SALReader = MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_powerSupplyStatus(MTM1M3_logevent_powerSupplyStatusC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_powerSupplyStatus");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_powerSupplyStatus");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_powerSupplyStatus_9f37ac09DataWriter_var SALWriter = MTM1M3::logevent_powerSupplyStatus_9f37ac09DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_powerSupplyStatus_9f37ac09 Instance;

  Instance.private_revCode = DDS::string_dup("9f37ac09");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.rcpMirrorCellUtility220VAC1Status = data->rcpMirrorCellUtility220VAC1Status;
    Instance.rcpCabinetUtility220VACStatus = data->rcpCabinetUtility220VACStatus;
    Instance.rcpExternalEquipment220VACStatus = data->rcpExternalEquipment220VACStatus;
    Instance.rcpMirrorCellUtility220VAC2Status = data->rcpMirrorCellUtility220VAC2Status;
    Instance.rcpMirrorCellUtility220VAC3Status = data->rcpMirrorCellUtility220VAC3Status;
    Instance.powerNetworkARedundancyControlStatus = data->powerNetworkARedundancyControlStatus;
    Instance.powerNetworkBRedundancyControlStatus = data->powerNetworkBRedundancyControlStatus;
    Instance.powerNetworkCRedundancyControlStatus = data->powerNetworkCRedundancyControlStatus;
    Instance.powerNetworkDRedundancyControlStatus = data->powerNetworkDRedundancyControlStatus;
    Instance.controlsPowerNetworkRedundancyControlStatus = data->controlsPowerNetworkRedundancyControlStatus;
    Instance.powerNetworkAStatus = data->powerNetworkAStatus;
    Instance.powerNetworkARedundantStatus = data->powerNetworkARedundantStatus;
    Instance.powerNetworkBStatus = data->powerNetworkBStatus;
    Instance.powerNetworkBRedundantStatus = data->powerNetworkBRedundantStatus;
    Instance.powerNetworkCStatus = data->powerNetworkCStatus;
    Instance.powerNetworkCRedundantStatus = data->powerNetworkCRedundantStatus;
    Instance.powerNetworkDStatus = data->powerNetworkDStatus;
    Instance.powerNetworkDRedundantStatus = data->powerNetworkDRedundantStatus;
    Instance.controlsPowerNetworkStatus = data->controlsPowerNetworkStatus;
    Instance.controlsPowerNetworkRedundantStatus = data->controlsPowerNetworkRedundantStatus;
    Instance.lightPowerNetworkStatus = data->lightPowerNetworkStatus;
    Instance.externalEquipmentPowerNetworkStatus = data->externalEquipmentPowerNetworkStatus;
    Instance.laserTrackerPowerNetworkStatus = data->laserTrackerPowerNetworkStatus;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_powerSupplyStatus_9f37ac09 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_powerSupplyStatus_9f37ac09DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_powerSupplyStatus(MTM1M3_logevent_powerSupplyStatusC *data)
{
  MTM1M3::logevent_powerSupplyStatus_9f37ac09Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_powerSupplyStatus");
  }
  int actorIdx = SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_powerSupplyStatus");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader_var SALReader = MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_powerSupplyStatus.timestamp = Instances[j].timestamp;
    data->rcpMirrorCellUtility220VAC1Status = Instances[j].rcpMirrorCellUtility220VAC1Status;
    lastSample_MTM1M3_logevent_powerSupplyStatus.rcpMirrorCellUtility220VAC1Status = Instances[j].rcpMirrorCellUtility220VAC1Status;
    data->rcpCabinetUtility220VACStatus = Instances[j].rcpCabinetUtility220VACStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.rcpCabinetUtility220VACStatus = Instances[j].rcpCabinetUtility220VACStatus;
    data->rcpExternalEquipment220VACStatus = Instances[j].rcpExternalEquipment220VACStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.rcpExternalEquipment220VACStatus = Instances[j].rcpExternalEquipment220VACStatus;
    data->rcpMirrorCellUtility220VAC2Status = Instances[j].rcpMirrorCellUtility220VAC2Status;
    lastSample_MTM1M3_logevent_powerSupplyStatus.rcpMirrorCellUtility220VAC2Status = Instances[j].rcpMirrorCellUtility220VAC2Status;
    data->rcpMirrorCellUtility220VAC3Status = Instances[j].rcpMirrorCellUtility220VAC3Status;
    lastSample_MTM1M3_logevent_powerSupplyStatus.rcpMirrorCellUtility220VAC3Status = Instances[j].rcpMirrorCellUtility220VAC3Status;
    data->powerNetworkARedundancyControlStatus = Instances[j].powerNetworkARedundancyControlStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkARedundancyControlStatus = Instances[j].powerNetworkARedundancyControlStatus;
    data->powerNetworkBRedundancyControlStatus = Instances[j].powerNetworkBRedundancyControlStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkBRedundancyControlStatus = Instances[j].powerNetworkBRedundancyControlStatus;
    data->powerNetworkCRedundancyControlStatus = Instances[j].powerNetworkCRedundancyControlStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkCRedundancyControlStatus = Instances[j].powerNetworkCRedundancyControlStatus;
    data->powerNetworkDRedundancyControlStatus = Instances[j].powerNetworkDRedundancyControlStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkDRedundancyControlStatus = Instances[j].powerNetworkDRedundancyControlStatus;
    data->controlsPowerNetworkRedundancyControlStatus = Instances[j].controlsPowerNetworkRedundancyControlStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.controlsPowerNetworkRedundancyControlStatus = Instances[j].controlsPowerNetworkRedundancyControlStatus;
    data->powerNetworkAStatus = Instances[j].powerNetworkAStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkAStatus = Instances[j].powerNetworkAStatus;
    data->powerNetworkARedundantStatus = Instances[j].powerNetworkARedundantStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkARedundantStatus = Instances[j].powerNetworkARedundantStatus;
    data->powerNetworkBStatus = Instances[j].powerNetworkBStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkBStatus = Instances[j].powerNetworkBStatus;
    data->powerNetworkBRedundantStatus = Instances[j].powerNetworkBRedundantStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkBRedundantStatus = Instances[j].powerNetworkBRedundantStatus;
    data->powerNetworkCStatus = Instances[j].powerNetworkCStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkCStatus = Instances[j].powerNetworkCStatus;
    data->powerNetworkCRedundantStatus = Instances[j].powerNetworkCRedundantStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkCRedundantStatus = Instances[j].powerNetworkCRedundantStatus;
    data->powerNetworkDStatus = Instances[j].powerNetworkDStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkDStatus = Instances[j].powerNetworkDStatus;
    data->powerNetworkDRedundantStatus = Instances[j].powerNetworkDRedundantStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkDRedundantStatus = Instances[j].powerNetworkDRedundantStatus;
    data->controlsPowerNetworkStatus = Instances[j].controlsPowerNetworkStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.controlsPowerNetworkStatus = Instances[j].controlsPowerNetworkStatus;
    data->controlsPowerNetworkRedundantStatus = Instances[j].controlsPowerNetworkRedundantStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.controlsPowerNetworkRedundantStatus = Instances[j].controlsPowerNetworkRedundantStatus;
    data->lightPowerNetworkStatus = Instances[j].lightPowerNetworkStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.lightPowerNetworkStatus = Instances[j].lightPowerNetworkStatus;
    data->externalEquipmentPowerNetworkStatus = Instances[j].externalEquipmentPowerNetworkStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.externalEquipmentPowerNetworkStatus = Instances[j].externalEquipmentPowerNetworkStatus;
    data->laserTrackerPowerNetworkStatus = Instances[j].laserTrackerPowerNetworkStatus;
    lastSample_MTM1M3_logevent_powerSupplyStatus.laserTrackerPowerNetworkStatus = Instances[j].laserTrackerPowerNetworkStatus;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_powerSupplyStatus.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_powerSupplyStatus_9f37ac09DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_powerSupplyStatus(MTM1M3_logevent_powerSupplyStatusC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_powerSupplyStatus(data);
    sal[SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_powerSupplyStatus(MTM1M3_logevent_powerSupplyStatusC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_powerSupplyStatus(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_powerSupplyStatus.timestamp;
   data->rcpMirrorCellUtility220VAC1Status = lastSample_MTM1M3_logevent_powerSupplyStatus.rcpMirrorCellUtility220VAC1Status;
   data->rcpCabinetUtility220VACStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.rcpCabinetUtility220VACStatus;
   data->rcpExternalEquipment220VACStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.rcpExternalEquipment220VACStatus;
   data->rcpMirrorCellUtility220VAC2Status = lastSample_MTM1M3_logevent_powerSupplyStatus.rcpMirrorCellUtility220VAC2Status;
   data->rcpMirrorCellUtility220VAC3Status = lastSample_MTM1M3_logevent_powerSupplyStatus.rcpMirrorCellUtility220VAC3Status;
   data->powerNetworkARedundancyControlStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkARedundancyControlStatus;
   data->powerNetworkBRedundancyControlStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkBRedundancyControlStatus;
   data->powerNetworkCRedundancyControlStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkCRedundancyControlStatus;
   data->powerNetworkDRedundancyControlStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkDRedundancyControlStatus;
   data->controlsPowerNetworkRedundancyControlStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.controlsPowerNetworkRedundancyControlStatus;
   data->powerNetworkAStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkAStatus;
   data->powerNetworkARedundantStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkARedundantStatus;
   data->powerNetworkBStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkBStatus;
   data->powerNetworkBRedundantStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkBRedundantStatus;
   data->powerNetworkCStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkCStatus;
   data->powerNetworkCRedundantStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkCRedundantStatus;
   data->powerNetworkDStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkDStatus;
   data->powerNetworkDRedundantStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.powerNetworkDRedundantStatus;
   data->controlsPowerNetworkStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.controlsPowerNetworkStatus;
   data->controlsPowerNetworkRedundantStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.controlsPowerNetworkRedundantStatus;
   data->lightPowerNetworkStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.lightPowerNetworkStatus;
   data->externalEquipmentPowerNetworkStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.externalEquipmentPowerNetworkStatus;
   data->laserTrackerPowerNetworkStatus = lastSample_MTM1M3_logevent_powerSupplyStatus.laserTrackerPowerNetworkStatus;
   data->priority = lastSample_MTM1M3_logevent_powerSupplyStatus.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_powerSupplyStatus(MTM1M3_logevent_powerSupplyStatusC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_powerSupplyStatus(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_powerWarning_cedc8628 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_powerWarning");
  }
  MTM1M3::logevent_powerWarning_cedc8628DataWriter_var SALWriter = MTM1M3::logevent_powerWarning_cedc8628DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("cedc8628");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_powerWarning_cedc8628 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_powerWarning_cedc8628DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_powerWarning_cedc8628Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_powerWarning");
  }
  MTM1M3::logevent_powerWarning_cedc8628DataReader_var SALReader = MTM1M3::logevent_powerWarning_cedc8628DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_powerWarning_cedc8628DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_powerWarning_cedc8628DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_powerWarning_cedc8628DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_powerWarning(MTM1M3_logevent_powerWarningC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_powerWarning_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_powerWarning");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_powerWarning");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_powerWarning_cedc8628DataWriter_var SALWriter = MTM1M3::logevent_powerWarning_cedc8628DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_powerWarning_cedc8628 Instance;

  Instance.private_revCode = DDS::string_dup("cedc8628");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.anyWarning = data->anyWarning;
    Instance.powerNetworkAOutputMismatch = data->powerNetworkAOutputMismatch;
    Instance.powerNetworkBOutputMismatch = data->powerNetworkBOutputMismatch;
    Instance.powerNetworkCOutputMismatch = data->powerNetworkCOutputMismatch;
    Instance.powerNetworkDOutputMismatch = data->powerNetworkDOutputMismatch;
    Instance.auxPowerNetworkAOutputMismatch = data->auxPowerNetworkAOutputMismatch;
    Instance.auxPowerNetworkBOutputMismatch = data->auxPowerNetworkBOutputMismatch;
    Instance.auxPowerNetworkCOutputMismatch = data->auxPowerNetworkCOutputMismatch;
    Instance.auxPowerNetworkDOutputMismatch = data->auxPowerNetworkDOutputMismatch;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_powerWarning_cedc8628 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_powerWarning_cedc8628DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_powerWarning(MTM1M3_logevent_powerWarningC *data)
{
  MTM1M3::logevent_powerWarning_cedc8628Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_powerWarning");
  }
  int actorIdx = SAL__MTM1M3_logevent_powerWarning_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_powerWarning");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_powerWarning_cedc8628DataReader_var SALReader = MTM1M3::logevent_powerWarning_cedc8628DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_powerWarning_cedc8628DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_powerWarning_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_powerWarning_cedc8628DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_powerWarning.timestamp = Instances[j].timestamp;
    data->anyWarning = Instances[j].anyWarning;
    lastSample_MTM1M3_logevent_powerWarning.anyWarning = Instances[j].anyWarning;
    data->powerNetworkAOutputMismatch = Instances[j].powerNetworkAOutputMismatch;
    lastSample_MTM1M3_logevent_powerWarning.powerNetworkAOutputMismatch = Instances[j].powerNetworkAOutputMismatch;
    data->powerNetworkBOutputMismatch = Instances[j].powerNetworkBOutputMismatch;
    lastSample_MTM1M3_logevent_powerWarning.powerNetworkBOutputMismatch = Instances[j].powerNetworkBOutputMismatch;
    data->powerNetworkCOutputMismatch = Instances[j].powerNetworkCOutputMismatch;
    lastSample_MTM1M3_logevent_powerWarning.powerNetworkCOutputMismatch = Instances[j].powerNetworkCOutputMismatch;
    data->powerNetworkDOutputMismatch = Instances[j].powerNetworkDOutputMismatch;
    lastSample_MTM1M3_logevent_powerWarning.powerNetworkDOutputMismatch = Instances[j].powerNetworkDOutputMismatch;
    data->auxPowerNetworkAOutputMismatch = Instances[j].auxPowerNetworkAOutputMismatch;
    lastSample_MTM1M3_logevent_powerWarning.auxPowerNetworkAOutputMismatch = Instances[j].auxPowerNetworkAOutputMismatch;
    data->auxPowerNetworkBOutputMismatch = Instances[j].auxPowerNetworkBOutputMismatch;
    lastSample_MTM1M3_logevent_powerWarning.auxPowerNetworkBOutputMismatch = Instances[j].auxPowerNetworkBOutputMismatch;
    data->auxPowerNetworkCOutputMismatch = Instances[j].auxPowerNetworkCOutputMismatch;
    lastSample_MTM1M3_logevent_powerWarning.auxPowerNetworkCOutputMismatch = Instances[j].auxPowerNetworkCOutputMismatch;
    data->auxPowerNetworkDOutputMismatch = Instances[j].auxPowerNetworkDOutputMismatch;
    lastSample_MTM1M3_logevent_powerWarning.auxPowerNetworkDOutputMismatch = Instances[j].auxPowerNetworkDOutputMismatch;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_powerWarning.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_powerWarning_cedc8628DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_powerWarning(MTM1M3_logevent_powerWarningC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_powerWarning_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_powerWarning_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_powerWarning(data);
    sal[SAL__MTM1M3_logevent_powerWarning_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_powerWarning(MTM1M3_logevent_powerWarningC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_powerWarning(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_powerWarning.timestamp;
   data->anyWarning = lastSample_MTM1M3_logevent_powerWarning.anyWarning;
   data->powerNetworkAOutputMismatch = lastSample_MTM1M3_logevent_powerWarning.powerNetworkAOutputMismatch;
   data->powerNetworkBOutputMismatch = lastSample_MTM1M3_logevent_powerWarning.powerNetworkBOutputMismatch;
   data->powerNetworkCOutputMismatch = lastSample_MTM1M3_logevent_powerWarning.powerNetworkCOutputMismatch;
   data->powerNetworkDOutputMismatch = lastSample_MTM1M3_logevent_powerWarning.powerNetworkDOutputMismatch;
   data->auxPowerNetworkAOutputMismatch = lastSample_MTM1M3_logevent_powerWarning.auxPowerNetworkAOutputMismatch;
   data->auxPowerNetworkBOutputMismatch = lastSample_MTM1M3_logevent_powerWarning.auxPowerNetworkBOutputMismatch;
   data->auxPowerNetworkCOutputMismatch = lastSample_MTM1M3_logevent_powerWarning.auxPowerNetworkCOutputMismatch;
   data->auxPowerNetworkDOutputMismatch = lastSample_MTM1M3_logevent_powerWarning.auxPowerNetworkDOutputMismatch;
   data->priority = lastSample_MTM1M3_logevent_powerWarning.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_powerWarning(MTM1M3_logevent_powerWarningC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_powerWarning_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_powerWarning_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_powerWarning(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_powerWarning_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedAberrationForces_07bb7050 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedAberrationForces");
  }
  MTM1M3::logevent_rejectedAberrationForces_07bb7050DataWriter_var SALWriter = MTM1M3::logevent_rejectedAberrationForces_07bb7050DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("07bb7050");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedAberrationForces_07bb7050 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedAberrationForces_07bb7050DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedAberrationForces_07bb7050Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedAberrationForces");
  }
  MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader_var SALReader = MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedAberrationForces(MTM1M3_logevent_rejectedAberrationForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedAberrationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedAberrationForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedAberrationForces_07bb7050DataWriter_var SALWriter = MTM1M3::logevent_rejectedAberrationForces_07bb7050DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedAberrationForces_07bb7050 Instance;

  Instance.private_revCode = DDS::string_dup("07bb7050");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedAberrationForces_07bb7050 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedAberrationForces_07bb7050DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedAberrationForces(MTM1M3_logevent_rejectedAberrationForcesC *data)
{
  MTM1M3::logevent_rejectedAberrationForces_07bb7050Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedAberrationForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedAberrationForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader_var SALReader = MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedAberrationForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedAberrationForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedAberrationForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedAberrationForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedAberrationForces.my = Instances[j].my;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedAberrationForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedAberrationForces_07bb7050DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedAberrationForces(MTM1M3_logevent_rejectedAberrationForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedAberrationForces(data);
    sal[SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedAberrationForces(MTM1M3_logevent_rejectedAberrationForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedAberrationForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedAberrationForces.timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedAberrationForces.zForces[iseq];}
   data->fz = lastSample_MTM1M3_logevent_rejectedAberrationForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedAberrationForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedAberrationForces.my;
   data->priority = lastSample_MTM1M3_logevent_rejectedAberrationForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedAberrationForces(MTM1M3_logevent_rejectedAberrationForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedAberrationForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedAccelerationForces_b8520238 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedAccelerationForces");
  }
  MTM1M3::logevent_rejectedAccelerationForces_b8520238DataWriter_var SALWriter = MTM1M3::logevent_rejectedAccelerationForces_b8520238DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("b8520238");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedAccelerationForces_b8520238 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedAccelerationForces_b8520238DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedAccelerationForces_b8520238Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedAccelerationForces");
  }
  MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader_var SALReader = MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedAccelerationForces(MTM1M3_logevent_rejectedAccelerationForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedAccelerationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedAccelerationForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedAccelerationForces_b8520238DataWriter_var SALWriter = MTM1M3::logevent_rejectedAccelerationForces_b8520238DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedAccelerationForces_b8520238 Instance;

  Instance.private_revCode = DDS::string_dup("b8520238");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedAccelerationForces_b8520238 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedAccelerationForces_b8520238DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedAccelerationForces(MTM1M3_logevent_rejectedAccelerationForcesC *data)
{
  MTM1M3::logevent_rejectedAccelerationForces_b8520238Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedAccelerationForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedAccelerationForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader_var SALReader = MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedAccelerationForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedAccelerationForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedAccelerationForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedAccelerationForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedAccelerationForces_b8520238DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedAccelerationForces(MTM1M3_logevent_rejectedAccelerationForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedAccelerationForces(data);
    sal[SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedAccelerationForces(MTM1M3_logevent_rejectedAccelerationForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedAccelerationForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedAccelerationForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedAccelerationForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedAccelerationForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedAccelerationForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedAccelerationForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedAccelerationForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedAccelerationForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedAccelerationForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedAccelerationForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedAccelerationForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedAccelerationForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedAccelerationForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedAccelerationForces(MTM1M3_logevent_rejectedAccelerationForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedAccelerationForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedActiveOpticForces_b308b353 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedActiveOpticForces");
  }
  MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataWriter_var SALWriter = MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("b308b353");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedActiveOpticForces_b308b353 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedActiveOpticForces_b308b353Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedActiveOpticForces");
  }
  MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader_var SALReader = MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedActiveOpticForces(MTM1M3_logevent_rejectedActiveOpticForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedActiveOpticForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedActiveOpticForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataWriter_var SALWriter = MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedActiveOpticForces_b308b353 Instance;

  Instance.private_revCode = DDS::string_dup("b308b353");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedActiveOpticForces_b308b353 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedActiveOpticForces(MTM1M3_logevent_rejectedActiveOpticForcesC *data)
{
  MTM1M3::logevent_rejectedActiveOpticForces_b308b353Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedActiveOpticForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedActiveOpticForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader_var SALReader = MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedActiveOpticForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedActiveOpticForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedActiveOpticForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedActiveOpticForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedActiveOpticForces.my = Instances[j].my;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedActiveOpticForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedActiveOpticForces_b308b353DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedActiveOpticForces(MTM1M3_logevent_rejectedActiveOpticForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedActiveOpticForces(data);
    sal[SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedActiveOpticForces(MTM1M3_logevent_rejectedActiveOpticForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedActiveOpticForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedActiveOpticForces.timestamp;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedActiveOpticForces.zForces[iseq];}
   data->fz = lastSample_MTM1M3_logevent_rejectedActiveOpticForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedActiveOpticForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedActiveOpticForces.my;
   data->priority = lastSample_MTM1M3_logevent_rejectedActiveOpticForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedActiveOpticForces(MTM1M3_logevent_rejectedActiveOpticForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedActiveOpticForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedAzimuthForces_e69b5c03 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedAzimuthForces");
  }
  MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataWriter_var SALWriter = MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("e69b5c03");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedAzimuthForces_e69b5c03 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedAzimuthForces_e69b5c03Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedAzimuthForces");
  }
  MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader_var SALReader = MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedAzimuthForces(MTM1M3_logevent_rejectedAzimuthForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedAzimuthForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedAzimuthForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataWriter_var SALWriter = MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedAzimuthForces_e69b5c03 Instance;

  Instance.private_revCode = DDS::string_dup("e69b5c03");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedAzimuthForces_e69b5c03 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedAzimuthForces(MTM1M3_logevent_rejectedAzimuthForcesC *data)
{
  MTM1M3::logevent_rejectedAzimuthForces_e69b5c03Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedAzimuthForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedAzimuthForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader_var SALReader = MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedAzimuthForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedAzimuthForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedAzimuthForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedAzimuthForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedAzimuthForces_e69b5c03DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedAzimuthForces(MTM1M3_logevent_rejectedAzimuthForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedAzimuthForces(data);
    sal[SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedAzimuthForces(MTM1M3_logevent_rejectedAzimuthForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedAzimuthForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedAzimuthForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedAzimuthForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedAzimuthForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedAzimuthForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedAzimuthForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedAzimuthForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedAzimuthForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedAzimuthForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedAzimuthForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedAzimuthForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedAzimuthForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedAzimuthForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedAzimuthForces(MTM1M3_logevent_rejectedAzimuthForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedAzimuthForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedBalanceForces_3d81e3db data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedBalanceForces");
  }
  MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataWriter_var SALWriter = MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("3d81e3db");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedBalanceForces_3d81e3db writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedBalanceForces_3d81e3dbSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedBalanceForces");
  }
  MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader_var SALReader = MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedBalanceForces(MTM1M3_logevent_rejectedBalanceForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedBalanceForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedBalanceForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataWriter_var SALWriter = MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedBalanceForces_3d81e3db Instance;

  Instance.private_revCode = DDS::string_dup("3d81e3db");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedBalanceForces_3d81e3db writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedBalanceForces(MTM1M3_logevent_rejectedBalanceForcesC *data)
{
  MTM1M3::logevent_rejectedBalanceForces_3d81e3dbSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedBalanceForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedBalanceForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader_var SALReader = MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedBalanceForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedBalanceForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedBalanceForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedBalanceForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedBalanceForces_3d81e3dbDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedBalanceForces(MTM1M3_logevent_rejectedBalanceForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedBalanceForces(data);
    sal[SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedBalanceForces(MTM1M3_logevent_rejectedBalanceForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedBalanceForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedBalanceForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedBalanceForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedBalanceForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedBalanceForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedBalanceForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedBalanceForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedBalanceForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedBalanceForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedBalanceForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedBalanceForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedBalanceForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedBalanceForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedBalanceForces(MTM1M3_logevent_rejectedBalanceForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedBalanceForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedCylinderForces_f4002407 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedCylinderForces");
  }
  MTM1M3::logevent_rejectedCylinderForces_f4002407DataWriter_var SALWriter = MTM1M3::logevent_rejectedCylinderForces_f4002407DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("f4002407");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedCylinderForces_f4002407 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedCylinderForces_f4002407DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedCylinderForces_f4002407Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedCylinderForces");
  }
  MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader_var SALReader = MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedCylinderForces(MTM1M3_logevent_rejectedCylinderForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedCylinderForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedCylinderForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedCylinderForces_f4002407DataWriter_var SALWriter = MTM1M3::logevent_rejectedCylinderForces_f4002407DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedCylinderForces_f4002407 Instance;

  Instance.private_revCode = DDS::string_dup("f4002407");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<112;iseq++) {Instance.secondaryCylinderForces[iseq] = data->secondaryCylinderForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.primaryCylinderForces[iseq] = data->primaryCylinderForces[iseq];}
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedCylinderForces_f4002407 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedCylinderForces_f4002407DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedCylinderForces(MTM1M3_logevent_rejectedCylinderForcesC *data)
{
  MTM1M3::logevent_rejectedCylinderForces_f4002407Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedCylinderForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedCylinderForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader_var SALReader = MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedCylinderForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<112;iseq++) {data->secondaryCylinderForces[iseq] = Instances[j].secondaryCylinderForces[iseq];}
    for (int iseq=0;iseq<112;iseq++) {lastSample_MTM1M3_logevent_rejectedCylinderForces.secondaryCylinderForces[iseq] = Instances[j].secondaryCylinderForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->primaryCylinderForces[iseq] = Instances[j].primaryCylinderForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedCylinderForces.primaryCylinderForces[iseq] = Instances[j].primaryCylinderForces[iseq];}
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedCylinderForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedCylinderForces_f4002407DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedCylinderForces(MTM1M3_logevent_rejectedCylinderForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedCylinderForces(data);
    sal[SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedCylinderForces(MTM1M3_logevent_rejectedCylinderForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedCylinderForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedCylinderForces.timestamp;
    for (int iseq=0;iseq<112;iseq++) {data->secondaryCylinderForces[iseq] = lastSample_MTM1M3_logevent_rejectedCylinderForces.secondaryCylinderForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->primaryCylinderForces[iseq] = lastSample_MTM1M3_logevent_rejectedCylinderForces.primaryCylinderForces[iseq];}
   data->priority = lastSample_MTM1M3_logevent_rejectedCylinderForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedCylinderForces(MTM1M3_logevent_rejectedCylinderForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedCylinderForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedElevationForces_bf1221a9 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedElevationForces");
  }
  MTM1M3::logevent_rejectedElevationForces_bf1221a9DataWriter_var SALWriter = MTM1M3::logevent_rejectedElevationForces_bf1221a9DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("bf1221a9");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedElevationForces_bf1221a9 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedElevationForces_bf1221a9DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedElevationForces_bf1221a9Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedElevationForces");
  }
  MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader_var SALReader = MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedElevationForces(MTM1M3_logevent_rejectedElevationForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedElevationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedElevationForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedElevationForces_bf1221a9DataWriter_var SALWriter = MTM1M3::logevent_rejectedElevationForces_bf1221a9DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedElevationForces_bf1221a9 Instance;

  Instance.private_revCode = DDS::string_dup("bf1221a9");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedElevationForces_bf1221a9 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedElevationForces_bf1221a9DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedElevationForces(MTM1M3_logevent_rejectedElevationForcesC *data)
{
  MTM1M3::logevent_rejectedElevationForces_bf1221a9Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedElevationForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedElevationForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader_var SALReader = MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedElevationForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedElevationForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedElevationForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedElevationForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedElevationForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedElevationForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedElevationForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedElevationForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedElevationForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedElevationForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedElevationForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedElevationForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedElevationForces_bf1221a9DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedElevationForces(MTM1M3_logevent_rejectedElevationForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedElevationForces(data);
    sal[SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedElevationForces(MTM1M3_logevent_rejectedElevationForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedElevationForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedElevationForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedElevationForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedElevationForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedElevationForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedElevationForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedElevationForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedElevationForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedElevationForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedElevationForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedElevationForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedElevationForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedElevationForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedElevationForces(MTM1M3_logevent_rejectedElevationForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedElevationForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedForces_7969f67b data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedForces");
  }
  MTM1M3::logevent_rejectedForces_7969f67bDataWriter_var SALWriter = MTM1M3::logevent_rejectedForces_7969f67bDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("7969f67b");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedForces_7969f67b writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedForces_7969f67bDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedForces_7969f67bSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedForces");
  }
  MTM1M3::logevent_rejectedForces_7969f67bDataReader_var SALReader = MTM1M3::logevent_rejectedForces_7969f67bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedForces_7969f67bDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedForces_7969f67bDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedForces_7969f67bDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedForces(MTM1M3_logevent_rejectedForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedForces_7969f67bDataWriter_var SALWriter = MTM1M3::logevent_rejectedForces_7969f67bDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedForces_7969f67b Instance;

  Instance.private_revCode = DDS::string_dup("7969f67b");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedForces_7969f67b writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedForces_7969f67bDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedForces(MTM1M3_logevent_rejectedForcesC *data)
{
  MTM1M3::logevent_rejectedForces_7969f67bSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedForces_7969f67bDataReader_var SALReader = MTM1M3::logevent_rejectedForces_7969f67bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedForces_7969f67bDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedForces_7969f67bDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedForces_7969f67bDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedForces(MTM1M3_logevent_rejectedForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedForces(data);
    sal[SAL__MTM1M3_logevent_rejectedForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedForces(MTM1M3_logevent_rejectedForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedForces(MTM1M3_logevent_rejectedForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedOffsetForces_9ae34670 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedOffsetForces");
  }
  MTM1M3::logevent_rejectedOffsetForces_9ae34670DataWriter_var SALWriter = MTM1M3::logevent_rejectedOffsetForces_9ae34670DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("9ae34670");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedOffsetForces_9ae34670 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedOffsetForces_9ae34670DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedOffsetForces_9ae34670Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedOffsetForces");
  }
  MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader_var SALReader = MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedOffsetForces(MTM1M3_logevent_rejectedOffsetForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedOffsetForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedOffsetForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedOffsetForces_9ae34670DataWriter_var SALWriter = MTM1M3::logevent_rejectedOffsetForces_9ae34670DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedOffsetForces_9ae34670 Instance;

  Instance.private_revCode = DDS::string_dup("9ae34670");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedOffsetForces_9ae34670 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedOffsetForces_9ae34670DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedOffsetForces(MTM1M3_logevent_rejectedOffsetForcesC *data)
{
  MTM1M3::logevent_rejectedOffsetForces_9ae34670Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedOffsetForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedOffsetForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader_var SALReader = MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedOffsetForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedOffsetForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedOffsetForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedOffsetForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedOffsetForces_9ae34670DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedOffsetForces(MTM1M3_logevent_rejectedOffsetForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedOffsetForces(data);
    sal[SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedOffsetForces(MTM1M3_logevent_rejectedOffsetForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedOffsetForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedOffsetForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedOffsetForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedOffsetForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedOffsetForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedOffsetForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedOffsetForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedOffsetForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedOffsetForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedOffsetForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedOffsetForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedOffsetForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedOffsetForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedOffsetForces(MTM1M3_logevent_rejectedOffsetForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedOffsetForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedStaticForces_95f4fc51 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedStaticForces");
  }
  MTM1M3::logevent_rejectedStaticForces_95f4fc51DataWriter_var SALWriter = MTM1M3::logevent_rejectedStaticForces_95f4fc51DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("95f4fc51");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedStaticForces_95f4fc51 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedStaticForces_95f4fc51DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedStaticForces_95f4fc51Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedStaticForces");
  }
  MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader_var SALReader = MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedStaticForces(MTM1M3_logevent_rejectedStaticForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedStaticForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedStaticForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedStaticForces_95f4fc51DataWriter_var SALWriter = MTM1M3::logevent_rejectedStaticForces_95f4fc51DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedStaticForces_95f4fc51 Instance;

  Instance.private_revCode = DDS::string_dup("95f4fc51");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedStaticForces_95f4fc51 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedStaticForces_95f4fc51DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedStaticForces(MTM1M3_logevent_rejectedStaticForcesC *data)
{
  MTM1M3::logevent_rejectedStaticForces_95f4fc51Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedStaticForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedStaticForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader_var SALReader = MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedStaticForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedStaticForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedStaticForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedStaticForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedStaticForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedStaticForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedStaticForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedStaticForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedStaticForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedStaticForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedStaticForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedStaticForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedStaticForces_95f4fc51DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedStaticForces(MTM1M3_logevent_rejectedStaticForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedStaticForces(data);
    sal[SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedStaticForces(MTM1M3_logevent_rejectedStaticForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedStaticForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedStaticForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedStaticForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedStaticForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedStaticForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedStaticForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedStaticForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedStaticForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedStaticForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedStaticForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedStaticForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedStaticForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedStaticForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedStaticForces(MTM1M3_logevent_rejectedStaticForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedStaticForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedThermalForces_bda7bbdd data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedThermalForces");
  }
  MTM1M3::logevent_rejectedThermalForces_bda7bbddDataWriter_var SALWriter = MTM1M3::logevent_rejectedThermalForces_bda7bbddDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("bda7bbdd");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedThermalForces_bda7bbdd writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedThermalForces_bda7bbddDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedThermalForces_bda7bbddSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedThermalForces");
  }
  MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader_var SALReader = MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedThermalForces(MTM1M3_logevent_rejectedThermalForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedThermalForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedThermalForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedThermalForces_bda7bbddDataWriter_var SALWriter = MTM1M3::logevent_rejectedThermalForces_bda7bbddDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedThermalForces_bda7bbdd Instance;

  Instance.private_revCode = DDS::string_dup("bda7bbdd");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedThermalForces_bda7bbdd writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedThermalForces_bda7bbddDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedThermalForces(MTM1M3_logevent_rejectedThermalForcesC *data)
{
  MTM1M3::logevent_rejectedThermalForces_bda7bbddSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedThermalForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedThermalForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader_var SALReader = MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedThermalForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedThermalForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedThermalForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedThermalForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedThermalForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedThermalForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedThermalForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedThermalForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedThermalForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedThermalForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedThermalForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedThermalForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedThermalForces_bda7bbddDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedThermalForces(MTM1M3_logevent_rejectedThermalForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedThermalForces(data);
    sal[SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedThermalForces(MTM1M3_logevent_rejectedThermalForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedThermalForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedThermalForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedThermalForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedThermalForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedThermalForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedThermalForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedThermalForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedThermalForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedThermalForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedThermalForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedThermalForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedThermalForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedThermalForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedThermalForces(MTM1M3_logevent_rejectedThermalForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedThermalForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_rejectedVelocityForces_9e4d8b9f data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedVelocityForces");
  }
  MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataWriter_var SALWriter = MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("9e4d8b9f");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedVelocityForces_9e4d8b9f writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedVelocityForces");
  }
  MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader_var SALReader = MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_rejectedVelocityForces(MTM1M3_logevent_rejectedVelocityForcesC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_rejectedVelocityForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_rejectedVelocityForces");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataWriter_var SALWriter = MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_rejectedVelocityForces_9e4d8b9f Instance;

  Instance.private_revCode = DDS::string_dup("9e4d8b9f");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}
    Instance.fx = data->fx;
    Instance.fy = data->fy;
    Instance.fz = data->fz;
    Instance.mx = data->mx;
    Instance.my = data->my;
    Instance.mz = data->mz;
    Instance.forceMagnitude = data->forceMagnitude;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_rejectedVelocityForces_9e4d8b9f writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_rejectedVelocityForces(MTM1M3_logevent_rejectedVelocityForcesC *data)
{
  MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_rejectedVelocityForces");
  }
  int actorIdx = SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_rejectedVelocityForces");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader_var SALReader = MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_logevent_rejectedVelocityForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_logevent_rejectedVelocityForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_logevent_rejectedVelocityForces.zForces[iseq] = Instances[j].zForces[iseq];}
    data->fx = Instances[j].fx;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.fx = Instances[j].fx;
    data->fy = Instances[j].fy;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.fy = Instances[j].fy;
    data->fz = Instances[j].fz;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.fz = Instances[j].fz;
    data->mx = Instances[j].mx;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.mx = Instances[j].mx;
    data->my = Instances[j].my;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.my = Instances[j].my;
    data->mz = Instances[j].mz;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.mz = Instances[j].mz;
    data->forceMagnitude = Instances[j].forceMagnitude;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.forceMagnitude = Instances[j].forceMagnitude;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_rejectedVelocityForces.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_rejectedVelocityForces_9e4d8b9fDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_rejectedVelocityForces(MTM1M3_logevent_rejectedVelocityForcesC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_rejectedVelocityForces(data);
    sal[SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_rejectedVelocityForces(MTM1M3_logevent_rejectedVelocityForcesC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_rejectedVelocityForces(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_logevent_rejectedVelocityForces.timestamp;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = lastSample_MTM1M3_logevent_rejectedVelocityForces.xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = lastSample_MTM1M3_logevent_rejectedVelocityForces.yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = lastSample_MTM1M3_logevent_rejectedVelocityForces.zForces[iseq];}
   data->fx = lastSample_MTM1M3_logevent_rejectedVelocityForces.fx;
   data->fy = lastSample_MTM1M3_logevent_rejectedVelocityForces.fy;
   data->fz = lastSample_MTM1M3_logevent_rejectedVelocityForces.fz;
   data->mx = lastSample_MTM1M3_logevent_rejectedVelocityForces.mx;
   data->my = lastSample_MTM1M3_logevent_rejectedVelocityForces.my;
   data->mz = lastSample_MTM1M3_logevent_rejectedVelocityForces.mz;
   data->forceMagnitude = lastSample_MTM1M3_logevent_rejectedVelocityForces.forceMagnitude;
   data->priority = lastSample_MTM1M3_logevent_rejectedVelocityForces.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_rejectedVelocityForces(MTM1M3_logevent_rejectedVelocityForcesC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_rejectedVelocityForces(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_settingVersions_679fb179 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_settingVersions");
  }
  MTM1M3::logevent_settingVersions_679fb179DataWriter_var SALWriter = MTM1M3::logevent_settingVersions_679fb179DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("679fb179");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_settingVersions_679fb179 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_settingVersions_679fb179DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_settingVersions_679fb179Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_settingVersions");
  }
  MTM1M3::logevent_settingVersions_679fb179DataReader_var SALReader = MTM1M3::logevent_settingVersions_679fb179DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_settingVersions_679fb179DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_settingVersions_679fb179DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_settingVersions_679fb179DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_settingVersions(MTM1M3_logevent_settingVersionsC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_settingVersions_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_settingVersions");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_settingVersions");
  }
    if ( data->recommendedSettingsVersion.length() > 128 ) {
       throw std::length_error("Item recommendedSettingsVersion exceeds string length");
    }
    if ( data->recommendedSettingsLabels.length() > 128 ) {
       throw std::length_error("Item recommendedSettingsLabels exceeds string length");
    }
    if ( data->settingsUrl.length() > 128 ) {
       throw std::length_error("Item settingsUrl exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_settingVersions_679fb179DataWriter_var SALWriter = MTM1M3::logevent_settingVersions_679fb179DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_settingVersions_679fb179 Instance;

  Instance.private_revCode = DDS::string_dup("679fb179");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.recommendedSettingsVersion = DDS::string_dup(data->recommendedSettingsVersion.c_str());
    Instance.recommendedSettingsLabels = DDS::string_dup(data->recommendedSettingsLabels.c_str());
    Instance.settingsUrl = DDS::string_dup(data->settingsUrl.c_str());
    Instance.timestamp = data->timestamp;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_settingVersions_679fb179 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_settingVersions_679fb179DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_settingVersions(MTM1M3_logevent_settingVersionsC *data)
{
  MTM1M3::logevent_settingVersions_679fb179Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_settingVersions");
  }
  int actorIdx = SAL__MTM1M3_logevent_settingVersions_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_settingVersions");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_settingVersions_679fb179DataReader_var SALReader = MTM1M3::logevent_settingVersions_679fb179DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_settingVersions_679fb179DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_settingVersions_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_settingVersions_679fb179DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->recommendedSettingsVersion=Instances[j].recommendedSettingsVersion.m_ptr;
    lastSample_MTM1M3_logevent_settingVersions.recommendedSettingsVersion=Instances[j].recommendedSettingsVersion.m_ptr;
    data->recommendedSettingsLabels=Instances[j].recommendedSettingsLabels.m_ptr;
    lastSample_MTM1M3_logevent_settingVersions.recommendedSettingsLabels=Instances[j].recommendedSettingsLabels.m_ptr;
    data->settingsUrl=Instances[j].settingsUrl.m_ptr;
    lastSample_MTM1M3_logevent_settingVersions.settingsUrl=Instances[j].settingsUrl.m_ptr;
    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_settingVersions.timestamp = Instances[j].timestamp;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_settingVersions.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_settingVersions_679fb179DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_settingVersions(MTM1M3_logevent_settingVersionsC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_settingVersions_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_settingVersions_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_settingVersions(data);
    sal[SAL__MTM1M3_logevent_settingVersions_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_settingVersions(MTM1M3_logevent_settingVersionsC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_settingVersions(data);
    if (istatus == SAL__NO_UPDATES) {
   data->recommendedSettingsVersion = lastSample_MTM1M3_logevent_settingVersions.recommendedSettingsVersion;
   data->recommendedSettingsLabels = lastSample_MTM1M3_logevent_settingVersions.recommendedSettingsLabels;
   data->settingsUrl = lastSample_MTM1M3_logevent_settingVersions.settingsUrl;
   data->timestamp = lastSample_MTM1M3_logevent_settingVersions.timestamp;
   data->priority = lastSample_MTM1M3_logevent_settingVersions.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_settingVersions(MTM1M3_logevent_settingVersionsC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_settingVersions_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_settingVersions_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_settingVersions(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_settingVersions_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_settingsApplied_61b4dd6e data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_settingsApplied");
  }
  MTM1M3::logevent_settingsApplied_61b4dd6eDataWriter_var SALWriter = MTM1M3::logevent_settingsApplied_61b4dd6eDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("61b4dd6e");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_settingsApplied_61b4dd6e writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_settingsApplied_61b4dd6eDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_settingsApplied_61b4dd6eSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_settingsApplied");
  }
  MTM1M3::logevent_settingsApplied_61b4dd6eDataReader_var SALReader = MTM1M3::logevent_settingsApplied_61b4dd6eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_settingsApplied_61b4dd6eDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_settingsApplied_61b4dd6eDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_settingsApplied_61b4dd6eDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_settingsApplied(MTM1M3_logevent_settingsAppliedC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_settingsApplied_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_settingsApplied");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_settingsApplied");
  }
    if ( data->settingsVersion.length() > 256 ) {
       throw std::length_error("Item settingsVersion exceeds string length");
    }
    if ( data->otherSettingsEvents.length() > 128 ) {
       throw std::length_error("Item otherSettingsEvents exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_settingsApplied_61b4dd6eDataWriter_var SALWriter = MTM1M3::logevent_settingsApplied_61b4dd6eDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_settingsApplied_61b4dd6e Instance;

  Instance.private_revCode = DDS::string_dup("61b4dd6e");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.settingsVersion = DDS::string_dup(data->settingsVersion.c_str());
    Instance.otherSettingsEvents = DDS::string_dup(data->otherSettingsEvents.c_str());
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_settingsApplied_61b4dd6e writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_settingsApplied_61b4dd6eDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_settingsApplied(MTM1M3_logevent_settingsAppliedC *data)
{
  MTM1M3::logevent_settingsApplied_61b4dd6eSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_settingsApplied");
  }
  int actorIdx = SAL__MTM1M3_logevent_settingsApplied_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_settingsApplied");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_settingsApplied_61b4dd6eDataReader_var SALReader = MTM1M3::logevent_settingsApplied_61b4dd6eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_settingsApplied_61b4dd6eDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_settingsApplied_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_settingsApplied_61b4dd6eDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->settingsVersion=Instances[j].settingsVersion.m_ptr;
    lastSample_MTM1M3_logevent_settingsApplied.settingsVersion=Instances[j].settingsVersion.m_ptr;
    data->otherSettingsEvents=Instances[j].otherSettingsEvents.m_ptr;
    lastSample_MTM1M3_logevent_settingsApplied.otherSettingsEvents=Instances[j].otherSettingsEvents.m_ptr;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_settingsApplied.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_settingsApplied_61b4dd6eDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_settingsApplied(MTM1M3_logevent_settingsAppliedC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_settingsApplied_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_settingsApplied_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_settingsApplied(data);
    sal[SAL__MTM1M3_logevent_settingsApplied_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_settingsApplied(MTM1M3_logevent_settingsAppliedC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_settingsApplied(data);
    if (istatus == SAL__NO_UPDATES) {
   data->settingsVersion = lastSample_MTM1M3_logevent_settingsApplied.settingsVersion;
   data->otherSettingsEvents = lastSample_MTM1M3_logevent_settingsApplied.otherSettingsEvents;
   data->priority = lastSample_MTM1M3_logevent_settingsApplied.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_settingsApplied(MTM1M3_logevent_settingsAppliedC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_settingsApplied_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_settingsApplied_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_settingsApplied(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_settingsApplied_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_simulationMode_a613ee19 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_simulationMode");
  }
  MTM1M3::logevent_simulationMode_a613ee19DataWriter_var SALWriter = MTM1M3::logevent_simulationMode_a613ee19DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("a613ee19");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_simulationMode_a613ee19 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_simulationMode_a613ee19DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_simulationMode_a613ee19Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_simulationMode");
  }
  MTM1M3::logevent_simulationMode_a613ee19DataReader_var SALReader = MTM1M3::logevent_simulationMode_a613ee19DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_simulationMode_a613ee19DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_simulationMode_a613ee19DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_simulationMode_a613ee19DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_simulationMode(MTM1M3_logevent_simulationModeC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_simulationMode_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_simulationMode");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_simulationMode");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_simulationMode_a613ee19DataWriter_var SALWriter = MTM1M3::logevent_simulationMode_a613ee19DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_simulationMode_a613ee19 Instance;

  Instance.private_revCode = DDS::string_dup("a613ee19");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.mode = data->mode;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_simulationMode_a613ee19 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_simulationMode_a613ee19DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_simulationMode(MTM1M3_logevent_simulationModeC *data)
{
  MTM1M3::logevent_simulationMode_a613ee19Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_simulationMode");
  }
  int actorIdx = SAL__MTM1M3_logevent_simulationMode_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_simulationMode");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_simulationMode_a613ee19DataReader_var SALReader = MTM1M3::logevent_simulationMode_a613ee19DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_simulationMode_a613ee19DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_simulationMode_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_simulationMode_a613ee19DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->mode = Instances[j].mode;
    lastSample_MTM1M3_logevent_simulationMode.mode = Instances[j].mode;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_simulationMode.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_simulationMode_a613ee19DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_simulationMode(MTM1M3_logevent_simulationModeC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_simulationMode_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_simulationMode_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_simulationMode(data);
    sal[SAL__MTM1M3_logevent_simulationMode_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_simulationMode(MTM1M3_logevent_simulationModeC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_simulationMode(data);
    if (istatus == SAL__NO_UPDATES) {
   data->mode = lastSample_MTM1M3_logevent_simulationMode.mode;
   data->priority = lastSample_MTM1M3_logevent_simulationMode.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_simulationMode(MTM1M3_logevent_simulationModeC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_simulationMode_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_simulationMode_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_simulationMode(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_simulationMode_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_softwareVersions_ed013250 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_softwareVersions");
  }
  MTM1M3::logevent_softwareVersions_ed013250DataWriter_var SALWriter = MTM1M3::logevent_softwareVersions_ed013250DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("ed013250");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_softwareVersions_ed013250 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_softwareVersions_ed013250DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_softwareVersions_ed013250Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_softwareVersions");
  }
  MTM1M3::logevent_softwareVersions_ed013250DataReader_var SALReader = MTM1M3::logevent_softwareVersions_ed013250DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_softwareVersions_ed013250DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_softwareVersions_ed013250DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_softwareVersions_ed013250DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_softwareVersions(MTM1M3_logevent_softwareVersionsC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_softwareVersions_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_softwareVersions");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_softwareVersions");
  }
    if ( data->salVersion.length() > 16 ) {
       throw std::length_error("Item salVersion exceeds string length");
    }
    if ( data->xmlVersion.length() > 16 ) {
       throw std::length_error("Item xmlVersion exceeds string length");
    }
    if ( data->openSpliceVersion.length() > 16 ) {
       throw std::length_error("Item openSpliceVersion exceeds string length");
    }
    if ( data->cscVersion.length() > 16 ) {
       throw std::length_error("Item cscVersion exceeds string length");
    }
    if ( data->subsystemVersions.length() > 128 ) {
       throw std::length_error("Item subsystemVersions exceeds string length");
    }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_softwareVersions_ed013250DataWriter_var SALWriter = MTM1M3::logevent_softwareVersions_ed013250DataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_softwareVersions_ed013250 Instance;

  Instance.private_revCode = DDS::string_dup("ed013250");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.salVersion = DDS::string_dup(data->salVersion.c_str());
    Instance.xmlVersion = DDS::string_dup(data->xmlVersion.c_str());
    Instance.openSpliceVersion = DDS::string_dup(data->openSpliceVersion.c_str());
    Instance.cscVersion = DDS::string_dup(data->cscVersion.c_str());
    Instance.subsystemVersions = DDS::string_dup(data->subsystemVersions.c_str());
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_softwareVersions_ed013250 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_softwareVersions_ed013250DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_softwareVersions(MTM1M3_logevent_softwareVersionsC *data)
{
  MTM1M3::logevent_softwareVersions_ed013250Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_softwareVersions");
  }
  int actorIdx = SAL__MTM1M3_logevent_softwareVersions_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_softwareVersions");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_softwareVersions_ed013250DataReader_var SALReader = MTM1M3::logevent_softwareVersions_ed013250DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_softwareVersions_ed013250DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_softwareVersions_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_softwareVersions_ed013250DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->salVersion=Instances[j].salVersion.m_ptr;
    lastSample_MTM1M3_logevent_softwareVersions.salVersion=Instances[j].salVersion.m_ptr;
    data->xmlVersion=Instances[j].xmlVersion.m_ptr;
    lastSample_MTM1M3_logevent_softwareVersions.xmlVersion=Instances[j].xmlVersion.m_ptr;
    data->openSpliceVersion=Instances[j].openSpliceVersion.m_ptr;
    lastSample_MTM1M3_logevent_softwareVersions.openSpliceVersion=Instances[j].openSpliceVersion.m_ptr;
    data->cscVersion=Instances[j].cscVersion.m_ptr;
    lastSample_MTM1M3_logevent_softwareVersions.cscVersion=Instances[j].cscVersion.m_ptr;
    data->subsystemVersions=Instances[j].subsystemVersions.m_ptr;
    lastSample_MTM1M3_logevent_softwareVersions.subsystemVersions=Instances[j].subsystemVersions.m_ptr;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_softwareVersions.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_softwareVersions_ed013250DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_softwareVersions(MTM1M3_logevent_softwareVersionsC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_softwareVersions_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_softwareVersions_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_softwareVersions(data);
    sal[SAL__MTM1M3_logevent_softwareVersions_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_softwareVersions(MTM1M3_logevent_softwareVersionsC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_softwareVersions(data);
    if (istatus == SAL__NO_UPDATES) {
   data->salVersion = lastSample_MTM1M3_logevent_softwareVersions.salVersion;
   data->xmlVersion = lastSample_MTM1M3_logevent_softwareVersions.xmlVersion;
   data->openSpliceVersion = lastSample_MTM1M3_logevent_softwareVersions.openSpliceVersion;
   data->cscVersion = lastSample_MTM1M3_logevent_softwareVersions.cscVersion;
   data->subsystemVersions = lastSample_MTM1M3_logevent_softwareVersions.subsystemVersions;
   data->priority = lastSample_MTM1M3_logevent_softwareVersions.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_softwareVersions(MTM1M3_logevent_softwareVersionsC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_softwareVersions_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_softwareVersions_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_softwareVersions(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_softwareVersions_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::logevent_summaryState_f936f3fc data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_summaryState");
  }
  MTM1M3::logevent_summaryState_f936f3fcDataWriter_var SALWriter = MTM1M3::logevent_summaryState_f936f3fcDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("f936f3fc");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_summaryState_f936f3fc writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::logevent_summaryState_f936f3fcDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::logevent_summaryState_f936f3fcSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_summaryState");
  }
  MTM1M3::logevent_summaryState_f936f3fcDataReader_var SALReader = MTM1M3::logevent_summaryState_f936f3fcDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_summaryState_f936f3fcDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_summaryState_f936f3fcDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::logevent_summaryState_f936f3fcDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_logevent_summaryState(MTM1M3_logevent_summaryStateC *data)
{
  int actorIdx = SAL__MTM1M3_logevent_summaryState_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_logevent_summaryState");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_logevent_summaryState");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_summaryState_f936f3fcDataWriter_var SALWriter = MTM1M3::logevent_summaryState_f936f3fcDataWriter::_narrow(dwriter.in());
  MTM1M3::logevent_summaryState_f936f3fc Instance;

  Instance.private_revCode = DDS::string_dup("f936f3fc");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.summaryState = data->summaryState;
    Instance.timestamp = data->timestamp;
    Instance.priority = data->priority;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::logevent_summaryState_f936f3fc writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::logevent_summaryState_f936f3fcDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_logevent_summaryState(MTM1M3_logevent_summaryStateC *data)
{
  MTM1M3::logevent_summaryState_f936f3fcSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_logevent_summaryState");
  }
  int actorIdx = SAL__MTM1M3_logevent_summaryState_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_logevent_summaryState");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::logevent_summaryState_f936f3fcDataReader_var SALReader = MTM1M3::logevent_summaryState_f936f3fcDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::logevent_summaryState_f936f3fcDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_logevent_summaryState_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::logevent_summaryState_f936f3fcDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->summaryState = Instances[j].summaryState;
    lastSample_MTM1M3_logevent_summaryState.summaryState = Instances[j].summaryState;
    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_logevent_summaryState.timestamp = Instances[j].timestamp;
    data->priority = Instances[j].priority;
    lastSample_MTM1M3_logevent_summaryState.priority = Instances[j].priority;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::logevent_summaryState_f936f3fcDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_logevent_summaryState(MTM1M3_logevent_summaryStateC *data)
{
    int saveMax = sal[SAL__MTM1M3_logevent_summaryState_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_logevent_summaryState_ACTOR].maxSamples = 1;
    istatus = getSample_logevent_summaryState(data);
    sal[SAL__MTM1M3_logevent_summaryState_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_logevent_summaryState(MTM1M3_logevent_summaryStateC *data)
{
    salReturn istatus = -1;
    istatus = getSample_logevent_summaryState(data);
    if (istatus == SAL__NO_UPDATES) {
   data->summaryState = lastSample_MTM1M3_logevent_summaryState.summaryState;
   data->timestamp = lastSample_MTM1M3_logevent_summaryState.timestamp;
   data->priority = lastSample_MTM1M3_logevent_summaryState.priority;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_logevent_summaryState(MTM1M3_logevent_summaryStateC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_logevent_summaryState_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_logevent_summaryState_ACTOR].sampleAge = -1.0;
    istatus = getSample_logevent_summaryState(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_logevent_summaryState_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::outerLoopData_0cb4c7ed data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_outerLoopData");
  }
  MTM1M3::outerLoopData_0cb4c7edDataWriter_var SALWriter = MTM1M3::outerLoopData_0cb4c7edDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("0cb4c7ed");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::outerLoopData_0cb4c7ed writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::outerLoopData_0cb4c7edDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::outerLoopData_0cb4c7edSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_outerLoopData");
  }
  MTM1M3::outerLoopData_0cb4c7edDataReader_var SALReader = MTM1M3::outerLoopData_0cb4c7edDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::outerLoopData_0cb4c7edDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::outerLoopData_0cb4c7edDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::outerLoopData_0cb4c7edDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_outerLoopData(MTM1M3_outerLoopDataC *data)
{
  int actorIdx = SAL__MTM1M3_outerLoopData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_outerLoopData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_outerLoopData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::outerLoopData_0cb4c7edDataWriter_var SALWriter = MTM1M3::outerLoopData_0cb4c7edDataWriter::_narrow(dwriter.in());
  MTM1M3::outerLoopData_0cb4c7ed Instance;

  Instance.private_revCode = DDS::string_dup("0cb4c7ed");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.broadcastCounter = data->broadcastCounter;
    Instance.slewFlag = data->slewFlag;
    Instance.executionTime = data->executionTime;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::outerLoopData_0cb4c7ed writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::outerLoopData_0cb4c7edDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_outerLoopData(MTM1M3_outerLoopDataC *data)
{
  MTM1M3::outerLoopData_0cb4c7edSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_outerLoopData");
  }
  int actorIdx = SAL__MTM1M3_outerLoopData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_outerLoopData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::outerLoopData_0cb4c7edDataReader_var SALReader = MTM1M3::outerLoopData_0cb4c7edDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::outerLoopData_0cb4c7edDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_outerLoopData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::outerLoopData_0cb4c7edDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_outerLoopData.timestamp = Instances[j].timestamp;
    data->broadcastCounter = Instances[j].broadcastCounter;
    lastSample_MTM1M3_outerLoopData.broadcastCounter = Instances[j].broadcastCounter;
    data->slewFlag = Instances[j].slewFlag;
    lastSample_MTM1M3_outerLoopData.slewFlag = Instances[j].slewFlag;
    data->executionTime = Instances[j].executionTime;
    lastSample_MTM1M3_outerLoopData.executionTime = Instances[j].executionTime;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::outerLoopData_0cb4c7edDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_outerLoopData(MTM1M3_outerLoopDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_outerLoopData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_outerLoopData_ACTOR].maxSamples = 1;
    istatus = getSample_outerLoopData(data);
    sal[SAL__MTM1M3_outerLoopData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_outerLoopData(MTM1M3_outerLoopDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_outerLoopData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_outerLoopData.timestamp;
   data->broadcastCounter = lastSample_MTM1M3_outerLoopData.broadcastCounter;
   data->slewFlag = lastSample_MTM1M3_outerLoopData.slewFlag;
   data->executionTime = lastSample_MTM1M3_outerLoopData.executionTime;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_outerLoopData(MTM1M3_outerLoopDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_outerLoopData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_outerLoopData_ACTOR].sampleAge = -1.0;
    istatus = getSample_outerLoopData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_outerLoopData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::pidData_0bd588ed data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_pidData");
  }
  MTM1M3::pidData_0bd588edDataWriter_var SALWriter = MTM1M3::pidData_0bd588edDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("0bd588ed");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::pidData_0bd588ed writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::pidData_0bd588edDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::pidData_0bd588edSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_pidData");
  }
  MTM1M3::pidData_0bd588edDataReader_var SALReader = MTM1M3::pidData_0bd588edDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::pidData_0bd588edDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::pidData_0bd588edDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::pidData_0bd588edDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_pidData(MTM1M3_pidDataC *data)
{
  int actorIdx = SAL__MTM1M3_pidData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_pidData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_pidData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::pidData_0bd588edDataWriter_var SALWriter = MTM1M3::pidData_0bd588edDataWriter::_narrow(dwriter.in());
  MTM1M3::pidData_0bd588ed Instance;

  Instance.private_revCode = DDS::string_dup("0bd588ed");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    for (int iseq=0;iseq<6;iseq++) {Instance.setpoint[iseq] = data->setpoint[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.measuredPID[iseq] = data->measuredPID[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.error[iseq] = data->error[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.errorT1[iseq] = data->errorT1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.errorT2[iseq] = data->errorT2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.control[iseq] = data->control[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.controlT1[iseq] = data->controlT1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {Instance.controlT2[iseq] = data->controlT2[iseq];}


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::pidData_0bd588ed writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::pidData_0bd588edDataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_pidData(MTM1M3_pidDataC *data)
{
  MTM1M3::pidData_0bd588edSeq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_pidData");
  }
  int actorIdx = SAL__MTM1M3_pidData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_pidData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::pidData_0bd588edDataReader_var SALReader = MTM1M3::pidData_0bd588edDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::pidData_0bd588edDataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_pidData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::pidData_0bd588edDataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_pidData.timestamp = Instances[j].timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->setpoint[iseq] = Instances[j].setpoint[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_pidData.setpoint[iseq] = Instances[j].setpoint[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->measuredPID[iseq] = Instances[j].measuredPID[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_pidData.measuredPID[iseq] = Instances[j].measuredPID[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->error[iseq] = Instances[j].error[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_pidData.error[iseq] = Instances[j].error[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->errorT1[iseq] = Instances[j].errorT1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_pidData.errorT1[iseq] = Instances[j].errorT1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->errorT2[iseq] = Instances[j].errorT2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_pidData.errorT2[iseq] = Instances[j].errorT2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->control[iseq] = Instances[j].control[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_pidData.control[iseq] = Instances[j].control[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->controlT1[iseq] = Instances[j].controlT1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_pidData.controlT1[iseq] = Instances[j].controlT1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->controlT2[iseq] = Instances[j].controlT2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_pidData.controlT2[iseq] = Instances[j].controlT2[iseq];}
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::pidData_0bd588edDataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_pidData(MTM1M3_pidDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_pidData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_pidData_ACTOR].maxSamples = 1;
    istatus = getSample_pidData(data);
    sal[SAL__MTM1M3_pidData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_pidData(MTM1M3_pidDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_pidData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_pidData.timestamp;
    for (int iseq=0;iseq<6;iseq++) {data->setpoint[iseq] = lastSample_MTM1M3_pidData.setpoint[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->measuredPID[iseq] = lastSample_MTM1M3_pidData.measuredPID[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->error[iseq] = lastSample_MTM1M3_pidData.error[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->errorT1[iseq] = lastSample_MTM1M3_pidData.errorT1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->errorT2[iseq] = lastSample_MTM1M3_pidData.errorT2[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->control[iseq] = lastSample_MTM1M3_pidData.control[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->controlT1[iseq] = lastSample_MTM1M3_pidData.controlT1[iseq];}
    for (int iseq=0;iseq<6;iseq++) {data->controlT2[iseq] = lastSample_MTM1M3_pidData.controlT2[iseq];}

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_pidData(MTM1M3_pidDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_pidData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_pidData_ACTOR].sampleAge = -1.0;
    istatus = getSample_pidData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_pidData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::powerSupplyData_daf67bc2 data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_powerSupplyData");
  }
  MTM1M3::powerSupplyData_daf67bc2DataWriter_var SALWriter = MTM1M3::powerSupplyData_daf67bc2DataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("daf67bc2");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::powerSupplyData_daf67bc2 writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::powerSupplyData_daf67bc2DataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::powerSupplyData_daf67bc2Seq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_powerSupplyData");
  }
  MTM1M3::powerSupplyData_daf67bc2DataReader_var SALReader = MTM1M3::powerSupplyData_daf67bc2DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::powerSupplyData_daf67bc2DataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::powerSupplyData_daf67bc2DataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::powerSupplyData_daf67bc2DataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_MTM1M3::putSample_powerSupplyData(MTM1M3_powerSupplyDataC *data)
{
  int actorIdx = SAL__MTM1M3_powerSupplyData_ACTOR;
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for putSample_powerSupplyData");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_powerSupplyData");
  }

#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::powerSupplyData_daf67bc2DataWriter_var SALWriter = MTM1M3::powerSupplyData_daf67bc2DataWriter::_narrow(dwriter.in());
  MTM1M3::powerSupplyData_daf67bc2 Instance;

  Instance.private_revCode = DDS::string_dup("daf67bc2");
  Instance.private_sndStamp = getCurrentTime();
  sal[actorIdx].sndStamp = Instance.private_sndStamp;
  Instance.private_origin = getpid();
  Instance.private_host = ddsIPaddress;
  Instance.private_seqNum = sndSeqNum;
  Instance.private_host = 1;
   
    Instance.timestamp = data->timestamp;
    Instance.powerNetworkACurrent = data->powerNetworkACurrent;
    Instance.powerNetworkBCurrent = data->powerNetworkBCurrent;
    Instance.powerNetworkCCurrent = data->powerNetworkCCurrent;
    Instance.powerNetworkDCurrent = data->powerNetworkDCurrent;
    Instance.lightPowerNetworkCurrent = data->lightPowerNetworkCurrent;
    Instance.controlsPowerNetworkCurrent = data->controlsPowerNetworkCurrent;


  sndSeqNum++;
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::powerSupplyData_daf67bc2 writing a message containing :" << endl;
    cout << "    revCode  : " << Instance.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   Instance.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(Instance);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, dataHandle);
  checkStatus(status, "MTM1M3::powerSupplyData_daf67bc2DataWriter::write");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  return status;
}

salReturn SAL_MTM1M3::getSample_powerSupplyData(MTM1M3_powerSupplyDataC *data)
{
  MTM1M3::powerSupplyData_daf67bc2Seq Instances;
  SampleInfoSeq_var info = new SampleInfoSeq;
  ReturnCode_t status = -1;
  salReturn istatus = -1;
  unsigned int numsamp = 0;

  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for getSample_powerSupplyData");
  }
  int actorIdx = SAL__MTM1M3_powerSupplyData_ACTOR;
  DataReader_var dreader = getReader(actorIdx);
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_powerSupplyData");
  }
#ifdef SAL_BUILD_FOR_PYTHON
  Py_BEGIN_ALLOW_THREADS
#endif
  MTM1M3::powerSupplyData_daf67bc2DataReader_var SALReader = MTM1M3::powerSupplyData_daf67bc2DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::powerSupplyData_daf67bc2DataReader::_narrow");
  status = SALReader->take(Instances, info, sal[SAL__MTM1M3_powerSupplyData_ACTOR].maxSamples , NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::powerSupplyData_daf67bc2DataReader::take");
  numsamp = Instances.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if (debugLevel > 8) {
      cout << "=== [GetSample] message received :" << numsamp << endl;
      cout << "    revCode  : " << Instances[j].private_revCode << endl;
      cout << "    sndStamp  : " << Instances[j].private_sndStamp << endl;
      cout << "    origin  : " << Instances[j].private_origin << endl;
      cout << "    host  : " << Instances[j].private_host << endl;
    }
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge && (Instances[j].private_origin != 0)) {

    data->timestamp = Instances[j].timestamp;
    lastSample_MTM1M3_powerSupplyData.timestamp = Instances[j].timestamp;
    data->powerNetworkACurrent = Instances[j].powerNetworkACurrent;
    lastSample_MTM1M3_powerSupplyData.powerNetworkACurrent = Instances[j].powerNetworkACurrent;
    data->powerNetworkBCurrent = Instances[j].powerNetworkBCurrent;
    lastSample_MTM1M3_powerSupplyData.powerNetworkBCurrent = Instances[j].powerNetworkBCurrent;
    data->powerNetworkCCurrent = Instances[j].powerNetworkCCurrent;
    lastSample_MTM1M3_powerSupplyData.powerNetworkCCurrent = Instances[j].powerNetworkCCurrent;
    data->powerNetworkDCurrent = Instances[j].powerNetworkDCurrent;
    lastSample_MTM1M3_powerSupplyData.powerNetworkDCurrent = Instances[j].powerNetworkDCurrent;
    data->lightPowerNetworkCurrent = Instances[j].lightPowerNetworkCurrent;
    lastSample_MTM1M3_powerSupplyData.lightPowerNetworkCurrent = Instances[j].lightPowerNetworkCurrent;
    data->controlsPowerNetworkCurrent = Instances[j].controlsPowerNetworkCurrent;
    lastSample_MTM1M3_powerSupplyData.controlsPowerNetworkCurrent = Instances[j].controlsPowerNetworkCurrent;
     istatus = SAL__OK;

   } else {
     istatus = SAL__NO_UPDATES;
   }
  }
  status = SALReader->return_loan(Instances, info);
  checkStatus(status, "MTM1M3::powerSupplyData_daf67bc2DataReader::return_loan");
#ifdef SAL_BUILD_FOR_PYTHON
  Py_END_ALLOW_THREADS
#endif
  if ( numsamp == 0 ) {
     istatus = SAL__NO_UPDATES;
     return istatus;
  }
  return istatus;
}

salReturn SAL_MTM1M3::getNextSample_powerSupplyData(MTM1M3_powerSupplyDataC *data)
{
    int saveMax = sal[SAL__MTM1M3_powerSupplyData_ACTOR].maxSamples;
    salReturn istatus = -1;
    sal[SAL__MTM1M3_powerSupplyData_ACTOR].maxSamples = 1;
    istatus = getSample_powerSupplyData(data);
    sal[SAL__MTM1M3_powerSupplyData_ACTOR].maxSamples = saveMax;
    return istatus;
}

salReturn SAL_MTM1M3::getLastSample_powerSupplyData(MTM1M3_powerSupplyDataC *data)
{
    salReturn istatus = -1;
    istatus = getSample_powerSupplyData(data);
    if (istatus == SAL__NO_UPDATES) {
   data->timestamp = lastSample_MTM1M3_powerSupplyData.timestamp;
   data->powerNetworkACurrent = lastSample_MTM1M3_powerSupplyData.powerNetworkACurrent;
   data->powerNetworkBCurrent = lastSample_MTM1M3_powerSupplyData.powerNetworkBCurrent;
   data->powerNetworkCCurrent = lastSample_MTM1M3_powerSupplyData.powerNetworkCCurrent;
   data->powerNetworkDCurrent = lastSample_MTM1M3_powerSupplyData.powerNetworkDCurrent;
   data->lightPowerNetworkCurrent = lastSample_MTM1M3_powerSupplyData.lightPowerNetworkCurrent;
   data->controlsPowerNetworkCurrent = lastSample_MTM1M3_powerSupplyData.controlsPowerNetworkCurrent;

    }
    return SAL__OK;
}


salReturn SAL_MTM1M3::flushSamples_powerSupplyData(MTM1M3_powerSupplyDataC *data)
{
    salReturn istatus;
    sal[SAL__MTM1M3_powerSupplyData_ACTOR].maxSamples = LENGTH_UNLIMITED;
    sal[SAL__MTM1M3_powerSupplyData_ACTOR].sampleAge = -1.0;
    istatus = getSample_powerSupplyData(data);
    if (debugLevel > 8) {
        cout << "=== [flushSamples] getSample returns :" << istatus << endl;
    }
    sal[SAL__MTM1M3_powerSupplyData_ACTOR].sampleAge = 1.0e20;
    return SAL__OK;
}


salReturn SAL_MTM1M3::putSample(MTM1M3::ackcmd_004df1cb data)
{
  DataWriter_var dwriter = getWriter();
  if ( dwriter == NULL ) {
     throw std::runtime_error("No DataWriter for putSample_ackcmd");
  }
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("004df1cb");
  if (debugLevel > 0) {
    cout << "=== [putSample] MTM1M3::ackcmd_004df1cb writing a message containing :" << endl;
    cout << "    revCode  : " << data.private_revCode << endl;
  }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   data.MTM1M3ID = subsystemID;
   InstanceHandle_t dataHandle = SALWriter->register_instance(data);
#else
   InstanceHandle_t dataHandle = HANDLE_NIL;
#endif
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, dataHandle);
  checkStatus(status, "MTM1M3::ackcmd_004df1cbDataWriter::write");
  return status;
}

salReturn SAL_MTM1M3::getSample(MTM1M3::ackcmd_004df1cbSeq data)
{
  SampleInfoSeq_var infoSeq = new SampleInfoSeq;
  ReturnCode_t status =  - 1;
  unsigned int numsamp = 0;
  DataReader_var dreader = getReader();
  if ( dreader == NULL ) {
     throw std::runtime_error("No DataReader for getSample_ackcmd");
  }
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  status = SALReader->take(data, infoSeq, LENGTH_UNLIMITED, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "MTM1M3::ackcmd_004df1cbDataReader::take");
  numsamp = data.length();
  for (DDS::ULong j = 0; j < numsamp; j++)
  {
    rcvdTime = getCurrentTime();
    if (data[j].private_origin != 0) {
      cout << "=== [GetSample] message received :" << endl;
      cout << "    revCode  : " << data[j].private_revCode << endl;
    }
  }
  status = SALReader->return_loan(data, infoSeq);
  checkStatus(status, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  if (numsamp == 0) {
     status = SAL__NO_UPDATES;
  }
  return status;
}

int SAL_MTM1M3::issueCommand_raiseM1M3( MTM1M3_command_raiseM1M3C *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_raiseM1M3");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_raiseM1M3_f0a54745 Instance;
  int actorIdx = SAL__MTM1M3_command_raiseM1M3_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_raiseM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_raiseM1M3_f0a54745DataWriter_var SALWriter = MTM1M3::command_raiseM1M3_f0a54745DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("f0a54745");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.raiseM1M3 = data->raiseM1M3;
    Instance.bypassReferencePosition = data->bypassReferencePosition;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_raiseM1M3] writing a command containing :" << endl;
    cout << "    raiseM1M3 : " << data->raiseM1M3 << endl;
    cout << "    bypassReferencePosition : " << data->bypassReferencePosition << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_raiseM1M3_f0a54745DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_raiseM1M3( MTM1M3_command_raiseM1M3C *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_raiseM1M3_f0a54745Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_raiseM1M3_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_raiseM1M3");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_raiseM1M3");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_raiseM1M3_f0a54745DataReader_var SALReader = MTM1M3::command_raiseM1M3_f0a54745DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_raiseM1M3_f0a54745DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_raiseM1M3_f0a54745DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC raiseM1M3] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->raiseM1M3 = Instances[j].raiseM1M3;
    lastSample_MTM1M3_command_raiseM1M3.raiseM1M3 = Instances[j].raiseM1M3;
    data->bypassReferencePosition = Instances[j].bypassReferencePosition;
    lastSample_MTM1M3_command_raiseM1M3.bypassReferencePosition = Instances[j].bypassReferencePosition;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_raiseM1M3_f0a54745DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_raiseM1M3( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_raiseM1M3_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_raiseM1M3(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_raiseM1M3] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_raiseM1M3] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_raiseM1M3(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_raiseM1M3_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_raiseM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_raiseM1M3] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_raiseM1M3C(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_raiseM1M3_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_raiseM1M3");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_raiseM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_raiseM1M3C] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_raiseM1M3( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_raiseM1M3_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_raiseM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_raiseM1M3C(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_raiseM1M3_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_raiseM1M3");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_raiseM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_abortRaiseM1M3( MTM1M3_command_abortRaiseM1M3C *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_abortRaiseM1M3");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_abortRaiseM1M3_7afaba9d Instance;
  int actorIdx = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_abortRaiseM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter_var SALWriter = MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("7afaba9d");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.abortRaiseM1M3 = data->abortRaiseM1M3;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_abortRaiseM1M3] writing a command containing :" << endl;
    cout << "    abortRaiseM1M3 : " << data->abortRaiseM1M3 << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_abortRaiseM1M3( MTM1M3_command_abortRaiseM1M3C *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_abortRaiseM1M3_7afaba9dSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_abortRaiseM1M3");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_abortRaiseM1M3");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader_var SALReader = MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC abortRaiseM1M3] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->abortRaiseM1M3 = Instances[j].abortRaiseM1M3;
    lastSample_MTM1M3_command_abortRaiseM1M3.abortRaiseM1M3 = Instances[j].abortRaiseM1M3;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_abortRaiseM1M3_7afaba9dDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_abortRaiseM1M3( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_abortRaiseM1M3(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_abortRaiseM1M3] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_abortRaiseM1M3] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_abortRaiseM1M3(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_abortRaiseM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_abortRaiseM1M3] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_abortRaiseM1M3C(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_abortRaiseM1M3");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_abortRaiseM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_abortRaiseM1M3C] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_abortRaiseM1M3( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_abortRaiseM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_abortRaiseM1M3C(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_abortRaiseM1M3_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_abortRaiseM1M3");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_abortRaiseM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_lowerM1M3( MTM1M3_command_lowerM1M3C *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_lowerM1M3");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_lowerM1M3_69afda69 Instance;
  int actorIdx = SAL__MTM1M3_command_lowerM1M3_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_lowerM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_lowerM1M3_69afda69DataWriter_var SALWriter = MTM1M3::command_lowerM1M3_69afda69DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("69afda69");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.lowerM1M3 = data->lowerM1M3;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_lowerM1M3] writing a command containing :" << endl;
    cout << "    lowerM1M3 : " << data->lowerM1M3 << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_lowerM1M3_69afda69DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_lowerM1M3( MTM1M3_command_lowerM1M3C *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_lowerM1M3_69afda69Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_lowerM1M3_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_lowerM1M3");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_lowerM1M3");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_lowerM1M3_69afda69DataReader_var SALReader = MTM1M3::command_lowerM1M3_69afda69DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_lowerM1M3_69afda69DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_lowerM1M3_69afda69DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC lowerM1M3] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->lowerM1M3 = Instances[j].lowerM1M3;
    lastSample_MTM1M3_command_lowerM1M3.lowerM1M3 = Instances[j].lowerM1M3;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_lowerM1M3_69afda69DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_lowerM1M3( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_lowerM1M3_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_lowerM1M3(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_lowerM1M3] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_lowerM1M3] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_lowerM1M3(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_lowerM1M3_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_lowerM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_lowerM1M3] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_lowerM1M3C(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_lowerM1M3_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_lowerM1M3");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_lowerM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_lowerM1M3C] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_lowerM1M3( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_lowerM1M3_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_lowerM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_lowerM1M3C(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_lowerM1M3_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_lowerM1M3");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_lowerM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_enterEngineering( MTM1M3_command_enterEngineeringC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_enterEngineering");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_enterEngineering_89e1ff1c Instance;
  int actorIdx = SAL__MTM1M3_command_enterEngineering_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_enterEngineering");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_enterEngineering_89e1ff1cDataWriter_var SALWriter = MTM1M3::command_enterEngineering_89e1ff1cDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("89e1ff1c");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.enterEngineering = data->enterEngineering;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_enterEngineering] writing a command containing :" << endl;
    cout << "    enterEngineering : " << data->enterEngineering << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_enterEngineering_89e1ff1cDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_enterEngineering( MTM1M3_command_enterEngineeringC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_enterEngineering_89e1ff1cSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_enterEngineering_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_enterEngineering");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_enterEngineering");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_enterEngineering_89e1ff1cDataReader_var SALReader = MTM1M3::command_enterEngineering_89e1ff1cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enterEngineering_89e1ff1cDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_enterEngineering_89e1ff1cDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC enterEngineering] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->enterEngineering = Instances[j].enterEngineering;
    lastSample_MTM1M3_command_enterEngineering.enterEngineering = Instances[j].enterEngineering;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_enterEngineering_89e1ff1cDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_enterEngineering( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_enterEngineering_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_enterEngineering(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enterEngineering] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enterEngineering] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_enterEngineering(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enterEngineering_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enterEngineering] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enterEngineering] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_enterEngineeringC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enterEngineering_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_enterEngineering");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enterEngineering] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enterEngineeringC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_enterEngineering( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enterEngineering_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enterEngineering] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_enterEngineeringC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enterEngineering_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_enterEngineering");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enterEngineering] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_exitEngineering( MTM1M3_command_exitEngineeringC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_exitEngineering");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_exitEngineering_01073d21 Instance;
  int actorIdx = SAL__MTM1M3_command_exitEngineering_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_exitEngineering");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_exitEngineering_01073d21DataWriter_var SALWriter = MTM1M3::command_exitEngineering_01073d21DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("01073d21");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.exitEngineering = data->exitEngineering;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_exitEngineering] writing a command containing :" << endl;
    cout << "    exitEngineering : " << data->exitEngineering << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_exitEngineering_01073d21DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_exitEngineering( MTM1M3_command_exitEngineeringC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_exitEngineering_01073d21Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_exitEngineering_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_exitEngineering");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_exitEngineering");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_exitEngineering_01073d21DataReader_var SALReader = MTM1M3::command_exitEngineering_01073d21DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_exitEngineering_01073d21DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_exitEngineering_01073d21DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC exitEngineering] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->exitEngineering = Instances[j].exitEngineering;
    lastSample_MTM1M3_command_exitEngineering.exitEngineering = Instances[j].exitEngineering;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_exitEngineering_01073d21DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_exitEngineering( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_exitEngineering_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_exitEngineering(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_exitEngineering] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_exitEngineering] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_exitEngineering(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_exitEngineering_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_exitEngineering] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_exitEngineering] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_exitEngineeringC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_exitEngineering_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_exitEngineering");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_exitEngineering] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_exitEngineeringC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_exitEngineering( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_exitEngineering_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_exitEngineering] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_exitEngineeringC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_exitEngineering_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_exitEngineering");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_exitEngineering] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_turnAirOn( MTM1M3_command_turnAirOnC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_turnAirOn");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_turnAirOn_acc6807c Instance;
  int actorIdx = SAL__MTM1M3_command_turnAirOn_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_turnAirOn");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_turnAirOn_acc6807cDataWriter_var SALWriter = MTM1M3::command_turnAirOn_acc6807cDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("acc6807c");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.turnAirOn = data->turnAirOn;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_turnAirOn] writing a command containing :" << endl;
    cout << "    turnAirOn : " << data->turnAirOn << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_turnAirOn_acc6807cDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_turnAirOn( MTM1M3_command_turnAirOnC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_turnAirOn_acc6807cSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_turnAirOn_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_turnAirOn");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_turnAirOn");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_turnAirOn_acc6807cDataReader_var SALReader = MTM1M3::command_turnAirOn_acc6807cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnAirOn_acc6807cDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_turnAirOn_acc6807cDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC turnAirOn] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->turnAirOn = Instances[j].turnAirOn;
    lastSample_MTM1M3_command_turnAirOn.turnAirOn = Instances[j].turnAirOn;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_turnAirOn_acc6807cDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_turnAirOn( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_turnAirOn_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_turnAirOn(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnAirOn] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnAirOn] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_turnAirOn(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnAirOn_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnAirOn] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnAirOn] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_turnAirOnC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnAirOn_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_turnAirOn");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnAirOn] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnAirOnC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_turnAirOn( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnAirOn_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnAirOn] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_turnAirOnC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnAirOn_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_turnAirOn");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnAirOn] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_turnAirOff( MTM1M3_command_turnAirOffC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_turnAirOff");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_turnAirOff_1054819e Instance;
  int actorIdx = SAL__MTM1M3_command_turnAirOff_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_turnAirOff");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_turnAirOff_1054819eDataWriter_var SALWriter = MTM1M3::command_turnAirOff_1054819eDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("1054819e");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.turnAirOff = data->turnAirOff;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_turnAirOff] writing a command containing :" << endl;
    cout << "    turnAirOff : " << data->turnAirOff << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_turnAirOff_1054819eDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_turnAirOff( MTM1M3_command_turnAirOffC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_turnAirOff_1054819eSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_turnAirOff_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_turnAirOff");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_turnAirOff");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_turnAirOff_1054819eDataReader_var SALReader = MTM1M3::command_turnAirOff_1054819eDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnAirOff_1054819eDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_turnAirOff_1054819eDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC turnAirOff] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->turnAirOff = Instances[j].turnAirOff;
    lastSample_MTM1M3_command_turnAirOff.turnAirOff = Instances[j].turnAirOff;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_turnAirOff_1054819eDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_turnAirOff( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_turnAirOff_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_turnAirOff(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnAirOff] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnAirOff] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_turnAirOff(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnAirOff_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnAirOff] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnAirOff] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_turnAirOffC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnAirOff_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_turnAirOff");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnAirOff] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnAirOffC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_turnAirOff( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnAirOff_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnAirOff] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_turnAirOffC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnAirOff_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_turnAirOff");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnAirOff] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_testAir( MTM1M3_command_testAirC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_testAir");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_testAir_37cd327c Instance;
  int actorIdx = SAL__MTM1M3_command_testAir_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_testAir");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_testAir_37cd327cDataWriter_var SALWriter = MTM1M3::command_testAir_37cd327cDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("37cd327c");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.testAir = data->testAir;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_testAir] writing a command containing :" << endl;
    cout << "    testAir : " << data->testAir << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_testAir_37cd327cDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_testAir( MTM1M3_command_testAirC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_testAir_37cd327cSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_testAir_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_testAir");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_testAir");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_testAir_37cd327cDataReader_var SALReader = MTM1M3::command_testAir_37cd327cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testAir_37cd327cDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_testAir_37cd327cDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC testAir] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->testAir = Instances[j].testAir;
    lastSample_MTM1M3_command_testAir.testAir = Instances[j].testAir;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_testAir_37cd327cDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_testAir( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_testAir_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_testAir(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_testAir] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_testAir] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_testAir(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_testAir_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_testAir] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_testAir] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_testAirC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_testAir_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_testAir");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_testAir] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_testAirC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_testAir( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_testAir_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_testAir] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_testAirC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_testAir_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_testAir");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_testAir] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_moveHardpointActuators( MTM1M3_command_moveHardpointActuatorsC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_moveHardpointActuators");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_moveHardpointActuators_4d114fab Instance;
  int actorIdx = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_moveHardpointActuators");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_moveHardpointActuators_4d114fabDataWriter_var SALWriter = MTM1M3::command_moveHardpointActuators_4d114fabDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("4d114fab");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    for (int iseq=0;iseq<6;iseq++) {Instance.steps[iseq] = data->steps[iseq];}

  if (debugLevel > 0) {
    cout << "=== [issueCommand_moveHardpointActuators] writing a command containing :" << endl;
       cout << "    steps : " << data->steps[0] << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_moveHardpointActuators_4d114fabDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_moveHardpointActuators( MTM1M3_command_moveHardpointActuatorsC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_moveHardpointActuators_4d114fabSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_moveHardpointActuators");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_moveHardpointActuators");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_moveHardpointActuators_4d114fabDataReader_var SALReader = MTM1M3::command_moveHardpointActuators_4d114fabDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC moveHardpointActuators] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    for (int iseq=0;iseq<6;iseq++) {data->steps[iseq] = Instances[j].steps[iseq];}
    for (int iseq=0;iseq<6;iseq++) {lastSample_MTM1M3_command_moveHardpointActuators.steps[iseq] = Instances[j].steps[iseq];}

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_moveHardpointActuators_4d114fabDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_moveHardpointActuators( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_moveHardpointActuators(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_moveHardpointActuators] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_moveHardpointActuators] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_moveHardpointActuators(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_moveHardpointActuators] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_moveHardpointActuators] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_moveHardpointActuatorsC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_moveHardpointActuators");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_moveHardpointActuators] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_moveHardpointActuatorsC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_moveHardpointActuators( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_moveHardpointActuators] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_moveHardpointActuatorsC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_moveHardpointActuators_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_moveHardpointActuators");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_moveHardpointActuators] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_stopHardpointMotion( MTM1M3_command_stopHardpointMotionC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_stopHardpointMotion");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_stopHardpointMotion_727b2152 Instance;
  int actorIdx = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_stopHardpointMotion");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_stopHardpointMotion_727b2152DataWriter_var SALWriter = MTM1M3::command_stopHardpointMotion_727b2152DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("727b2152");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.stopHardpointMotion = data->stopHardpointMotion;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_stopHardpointMotion] writing a command containing :" << endl;
    cout << "    stopHardpointMotion : " << data->stopHardpointMotion << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_stopHardpointMotion_727b2152DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_stopHardpointMotion( MTM1M3_command_stopHardpointMotionC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_stopHardpointMotion_727b2152Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_stopHardpointMotion");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_stopHardpointMotion");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_stopHardpointMotion_727b2152DataReader_var SALReader = MTM1M3::command_stopHardpointMotion_727b2152DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_stopHardpointMotion_727b2152DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_stopHardpointMotion_727b2152DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC stopHardpointMotion] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->stopHardpointMotion = Instances[j].stopHardpointMotion;
    lastSample_MTM1M3_command_stopHardpointMotion.stopHardpointMotion = Instances[j].stopHardpointMotion;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_stopHardpointMotion_727b2152DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_stopHardpointMotion( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_stopHardpointMotion(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_stopHardpointMotion] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_stopHardpointMotion] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_stopHardpointMotion(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_stopHardpointMotion] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_stopHardpointMotion] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_stopHardpointMotionC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_stopHardpointMotion");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_stopHardpointMotion] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_stopHardpointMotionC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_stopHardpointMotion( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_stopHardpointMotion] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_stopHardpointMotionC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_stopHardpointMotion_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_stopHardpointMotion");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_stopHardpointMotion] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_testHardpoint( MTM1M3_command_testHardpointC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_testHardpoint");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_testHardpoint_3736f433 Instance;
  int actorIdx = SAL__MTM1M3_command_testHardpoint_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_testHardpoint");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_testHardpoint_3736f433DataWriter_var SALWriter = MTM1M3::command_testHardpoint_3736f433DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("3736f433");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.hardpointActuator = data->hardpointActuator;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_testHardpoint] writing a command containing :" << endl;
    cout << "    hardpointActuator : " << data->hardpointActuator << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_testHardpoint_3736f433DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_testHardpoint( MTM1M3_command_testHardpointC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_testHardpoint_3736f433Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_testHardpoint_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_testHardpoint");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_testHardpoint");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_testHardpoint_3736f433DataReader_var SALReader = MTM1M3::command_testHardpoint_3736f433DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testHardpoint_3736f433DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_testHardpoint_3736f433DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC testHardpoint] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->hardpointActuator = Instances[j].hardpointActuator;
    lastSample_MTM1M3_command_testHardpoint.hardpointActuator = Instances[j].hardpointActuator;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_testHardpoint_3736f433DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_testHardpoint( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_testHardpoint_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_testHardpoint(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_testHardpoint] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_testHardpoint] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_testHardpoint(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_testHardpoint_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_testHardpoint] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_testHardpoint] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_testHardpointC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_testHardpoint_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_testHardpoint");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_testHardpoint] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_testHardpointC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_testHardpoint( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_testHardpoint_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_testHardpoint] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_testHardpointC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_testHardpoint_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_testHardpoint");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_testHardpoint] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_enableHardpointChase( MTM1M3_command_enableHardpointChaseC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_enableHardpointChase");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_enableHardpointChase_49c0d4e1 Instance;
  int actorIdx = SAL__MTM1M3_command_enableHardpointChase_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_enableHardpointChase");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter_var SALWriter = MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("49c0d4e1");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.hardpointActuator = data->hardpointActuator;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_enableHardpointChase] writing a command containing :" << endl;
    cout << "    hardpointActuator : " << data->hardpointActuator << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_enableHardpointChase_49c0d4e1DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_enableHardpointChase( MTM1M3_command_enableHardpointChaseC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_enableHardpointChase_49c0d4e1Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_enableHardpointChase_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_enableHardpointChase");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_enableHardpointChase");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_enableHardpointChase_49c0d4e1DataReader_var SALReader = MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC enableHardpointChase] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->hardpointActuator = Instances[j].hardpointActuator;
    lastSample_MTM1M3_command_enableHardpointChase.hardpointActuator = Instances[j].hardpointActuator;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_enableHardpointChase_49c0d4e1DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_enableHardpointChase( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_enableHardpointChase_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_enableHardpointChase(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enableHardpointChase] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enableHardpointChase] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_enableHardpointChase(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enableHardpointChase_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enableHardpointChase] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enableHardpointChase] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_enableHardpointChaseC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enableHardpointChase_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_enableHardpointChase");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enableHardpointChase] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enableHardpointChaseC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_enableHardpointChase( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enableHardpointChase_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enableHardpointChase] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_enableHardpointChaseC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enableHardpointChase_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_enableHardpointChase");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enableHardpointChase] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_disableHardpointChase( MTM1M3_command_disableHardpointChaseC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_disableHardpointChase");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_disableHardpointChase_dbe9a16b Instance;
  int actorIdx = SAL__MTM1M3_command_disableHardpointChase_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_disableHardpointChase");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter_var SALWriter = MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("dbe9a16b");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.hardpointActuator = data->hardpointActuator;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_disableHardpointChase] writing a command containing :" << endl;
    cout << "    hardpointActuator : " << data->hardpointActuator << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_disableHardpointChase_dbe9a16bDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_disableHardpointChase( MTM1M3_command_disableHardpointChaseC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_disableHardpointChase_dbe9a16bSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_disableHardpointChase_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_disableHardpointChase");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_disableHardpointChase");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_disableHardpointChase_dbe9a16bDataReader_var SALReader = MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC disableHardpointChase] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->hardpointActuator = Instances[j].hardpointActuator;
    lastSample_MTM1M3_command_disableHardpointChase.hardpointActuator = Instances[j].hardpointActuator;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_disableHardpointChase_dbe9a16bDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_disableHardpointChase( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_disableHardpointChase_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_disableHardpointChase(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_disableHardpointChase] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_disableHardpointChase] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_disableHardpointChase(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_disableHardpointChase_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_disableHardpointChase] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_disableHardpointChase] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_disableHardpointChaseC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_disableHardpointChase_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_disableHardpointChase");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_disableHardpointChase] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_disableHardpointChaseC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_disableHardpointChase( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_disableHardpointChase_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_disableHardpointChase] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_disableHardpointChaseC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_disableHardpointChase_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_disableHardpointChase");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_disableHardpointChase] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_testForceActuator( MTM1M3_command_testForceActuatorC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_testForceActuator");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_testForceActuator_f1a37131 Instance;
  int actorIdx = SAL__MTM1M3_command_testForceActuator_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_testForceActuator");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_testForceActuator_f1a37131DataWriter_var SALWriter = MTM1M3::command_testForceActuator_f1a37131DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("f1a37131");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.forceActuator = data->forceActuator;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_testForceActuator] writing a command containing :" << endl;
    cout << "    forceActuator : " << data->forceActuator << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_testForceActuator_f1a37131DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_testForceActuator( MTM1M3_command_testForceActuatorC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_testForceActuator_f1a37131Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_testForceActuator_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_testForceActuator");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_testForceActuator");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_testForceActuator_f1a37131DataReader_var SALReader = MTM1M3::command_testForceActuator_f1a37131DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_testForceActuator_f1a37131DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_testForceActuator_f1a37131DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC testForceActuator] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->forceActuator = Instances[j].forceActuator;
    lastSample_MTM1M3_command_testForceActuator.forceActuator = Instances[j].forceActuator;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_testForceActuator_f1a37131DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_testForceActuator( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_testForceActuator_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_testForceActuator(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_testForceActuator] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_testForceActuator] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_testForceActuator(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_testForceActuator_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_testForceActuator] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_testForceActuator] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_testForceActuatorC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_testForceActuator_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_testForceActuator");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_testForceActuator] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_testForceActuatorC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_testForceActuator( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_testForceActuator_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_testForceActuator] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_testForceActuatorC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_testForceActuator_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_testForceActuator");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_testForceActuator] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_applyOffsetForces( MTM1M3_command_applyOffsetForcesC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_applyOffsetForces");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_applyOffsetForces_c715c535 Instance;
  int actorIdx = SAL__MTM1M3_command_applyOffsetForces_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_applyOffsetForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_applyOffsetForces_c715c535DataWriter_var SALWriter = MTM1M3::command_applyOffsetForces_c715c535DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("c715c535");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    for (int iseq=0;iseq<12;iseq++) {Instance.xForces[iseq] = data->xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {Instance.yForces[iseq] = data->yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}

  if (debugLevel > 0) {
    cout << "=== [issueCommand_applyOffsetForces] writing a command containing :" << endl;
       cout << "    xForces : " << data->xForces[0] << endl;
       cout << "    yForces : " << data->yForces[0] << endl;
       cout << "    zForces : " << data->zForces[0] << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_applyOffsetForces_c715c535DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_applyOffsetForces( MTM1M3_command_applyOffsetForcesC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_applyOffsetForces_c715c535Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_applyOffsetForces_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_applyOffsetForces");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_applyOffsetForces");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_applyOffsetForces_c715c535DataReader_var SALReader = MTM1M3::command_applyOffsetForces_c715c535DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyOffsetForces_c715c535DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_applyOffsetForces_c715c535DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC applyOffsetForces] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    for (int iseq=0;iseq<12;iseq++) {data->xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<12;iseq++) {lastSample_MTM1M3_command_applyOffsetForces.xForces[iseq] = Instances[j].xForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {data->yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<100;iseq++) {lastSample_MTM1M3_command_applyOffsetForces.yForces[iseq] = Instances[j].yForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_command_applyOffsetForces.zForces[iseq] = Instances[j].zForces[iseq];}

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_applyOffsetForces_c715c535DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_applyOffsetForces( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_applyOffsetForces_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_applyOffsetForces(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyOffsetForces] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyOffsetForces] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_applyOffsetForces(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyOffsetForces_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyOffsetForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyOffsetForces] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_applyOffsetForcesC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyOffsetForces_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_applyOffsetForces");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyOffsetForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyOffsetForcesC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_applyOffsetForces( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyOffsetForces_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyOffsetForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_applyOffsetForcesC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyOffsetForces_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_applyOffsetForces");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyOffsetForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_shutdown( MTM1M3_command_shutdownC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_shutdown");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_shutdown_46d06e01 Instance;
  int actorIdx = SAL__MTM1M3_command_shutdown_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_shutdown");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_shutdown_46d06e01DataWriter_var SALWriter = MTM1M3::command_shutdown_46d06e01DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("46d06e01");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.shutdown = data->shutdown;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_shutdown] writing a command containing :" << endl;
    cout << "    shutdown : " << data->shutdown << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_shutdown_46d06e01DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_shutdown( MTM1M3_command_shutdownC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_shutdown_46d06e01Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_shutdown_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_shutdown");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_shutdown");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_shutdown_46d06e01DataReader_var SALReader = MTM1M3::command_shutdown_46d06e01DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_shutdown_46d06e01DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_shutdown_46d06e01DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC shutdown] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->shutdown = Instances[j].shutdown;
    lastSample_MTM1M3_command_shutdown.shutdown = Instances[j].shutdown;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_shutdown_46d06e01DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_shutdown( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_shutdown_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_shutdown(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_shutdown] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_shutdown] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_shutdown(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_shutdown_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_shutdown] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_shutdown] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_shutdownC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_shutdown_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_shutdown");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_shutdown] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_shutdownC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_shutdown( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_shutdown_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_shutdown] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_shutdownC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_shutdown_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_shutdown");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_shutdown] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_translateM1M3( MTM1M3_command_translateM1M3C *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_translateM1M3");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_translateM1M3_4d0dfbfe Instance;
  int actorIdx = SAL__MTM1M3_command_translateM1M3_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_translateM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_translateM1M3_4d0dfbfeDataWriter_var SALWriter = MTM1M3::command_translateM1M3_4d0dfbfeDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("4d0dfbfe");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.xTranslation = data->xTranslation;
    Instance.yTranslation = data->yTranslation;
    Instance.zTranslation = data->zTranslation;
    Instance.xRotation = data->xRotation;
    Instance.yRotation = data->yRotation;
    Instance.zRotation = data->zRotation;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_translateM1M3] writing a command containing :" << endl;
    cout << "    xTranslation : " << data->xTranslation << endl;
    cout << "    yTranslation : " << data->yTranslation << endl;
    cout << "    zTranslation : " << data->zTranslation << endl;
    cout << "    xRotation : " << data->xRotation << endl;
    cout << "    yRotation : " << data->yRotation << endl;
    cout << "    zRotation : " << data->zRotation << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_translateM1M3_4d0dfbfeDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_translateM1M3( MTM1M3_command_translateM1M3C *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_translateM1M3_4d0dfbfeSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_translateM1M3_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_translateM1M3");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_translateM1M3");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_translateM1M3_4d0dfbfeDataReader_var SALReader = MTM1M3::command_translateM1M3_4d0dfbfeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC translateM1M3] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->xTranslation = Instances[j].xTranslation;
    lastSample_MTM1M3_command_translateM1M3.xTranslation = Instances[j].xTranslation;
    data->yTranslation = Instances[j].yTranslation;
    lastSample_MTM1M3_command_translateM1M3.yTranslation = Instances[j].yTranslation;
    data->zTranslation = Instances[j].zTranslation;
    lastSample_MTM1M3_command_translateM1M3.zTranslation = Instances[j].zTranslation;
    data->xRotation = Instances[j].xRotation;
    lastSample_MTM1M3_command_translateM1M3.xRotation = Instances[j].xRotation;
    data->yRotation = Instances[j].yRotation;
    lastSample_MTM1M3_command_translateM1M3.yRotation = Instances[j].yRotation;
    data->zRotation = Instances[j].zRotation;
    lastSample_MTM1M3_command_translateM1M3.zRotation = Instances[j].zRotation;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_translateM1M3_4d0dfbfeDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_translateM1M3( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_translateM1M3_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_translateM1M3(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_translateM1M3] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_translateM1M3] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_translateM1M3(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_translateM1M3_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_translateM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_translateM1M3] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_translateM1M3C(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_translateM1M3_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_translateM1M3");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_translateM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_translateM1M3C] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_translateM1M3( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_translateM1M3_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_translateM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_translateM1M3C(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_translateM1M3_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_translateM1M3");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_translateM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_clearOffsetForces( MTM1M3_command_clearOffsetForcesC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_clearOffsetForces");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_clearOffsetForces_0d7f285d Instance;
  int actorIdx = SAL__MTM1M3_command_clearOffsetForces_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_clearOffsetForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_clearOffsetForces_0d7f285dDataWriter_var SALWriter = MTM1M3::command_clearOffsetForces_0d7f285dDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("0d7f285d");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.clearOffsetForces = data->clearOffsetForces;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_clearOffsetForces] writing a command containing :" << endl;
    cout << "    clearOffsetForces : " << data->clearOffsetForces << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_clearOffsetForces_0d7f285dDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_clearOffsetForces( MTM1M3_command_clearOffsetForcesC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_clearOffsetForces_0d7f285dSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_clearOffsetForces_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_clearOffsetForces");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_clearOffsetForces");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_clearOffsetForces_0d7f285dDataReader_var SALReader = MTM1M3::command_clearOffsetForces_0d7f285dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC clearOffsetForces] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->clearOffsetForces = Instances[j].clearOffsetForces;
    lastSample_MTM1M3_command_clearOffsetForces.clearOffsetForces = Instances[j].clearOffsetForces;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_clearOffsetForces_0d7f285dDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_clearOffsetForces( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_clearOffsetForces_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_clearOffsetForces(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_clearOffsetForces] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_clearOffsetForces] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_clearOffsetForces(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_clearOffsetForces_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_clearOffsetForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_clearOffsetForces] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_clearOffsetForcesC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_clearOffsetForces_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_clearOffsetForces");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_clearOffsetForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_clearOffsetForcesC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_clearOffsetForces( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_clearOffsetForces_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_clearOffsetForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_clearOffsetForcesC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_clearOffsetForces_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_clearOffsetForces");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_clearOffsetForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_applyAberrationForcesByBendingModes( MTM1M3_command_applyAberrationForcesByBendingModesC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_applyAberrationForcesByBendingModes");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53d Instance;
  int actorIdx = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_applyAberrationForcesByBendingModes");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter_var SALWriter = MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("ef2ea53d");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    for (int iseq=0;iseq<22;iseq++) {Instance.coefficients[iseq] = data->coefficients[iseq];}

  if (debugLevel > 0) {
    cout << "=== [issueCommand_applyAberrationForcesByBendingModes] writing a command containing :" << endl;
       cout << "    coefficients : " << data->coefficients[0] << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_applyAberrationForcesByBendingModes( MTM1M3_command_applyAberrationForcesByBendingModesC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_applyAberrationForcesByBendingModes");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_applyAberrationForcesByBendingModes");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader_var SALReader = MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC applyAberrationForcesByBendingModes] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    for (int iseq=0;iseq<22;iseq++) {data->coefficients[iseq] = Instances[j].coefficients[iseq];}
    for (int iseq=0;iseq<22;iseq++) {lastSample_MTM1M3_command_applyAberrationForcesByBendingModes.coefficients[iseq] = Instances[j].coefficients[iseq];}

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_applyAberrationForcesByBendingModes_ef2ea53dDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_applyAberrationForcesByBendingModes( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_applyAberrationForcesByBendingModes(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyAberrationForcesByBendingModes] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyAberrationForcesByBendingModes] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_applyAberrationForcesByBendingModes(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyAberrationForcesByBendingModes] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyAberrationForcesByBendingModes] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_applyAberrationForcesByBendingModesC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_applyAberrationForcesByBendingModes");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyAberrationForcesByBendingModes] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyAberrationForcesByBendingModesC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_applyAberrationForcesByBendingModes( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyAberrationForcesByBendingModes] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_applyAberrationForcesByBendingModesC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyAberrationForcesByBendingModes_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_applyAberrationForcesByBendingModes");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyAberrationForcesByBendingModes] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_applyAberrationForces( MTM1M3_command_applyAberrationForcesC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_applyAberrationForces");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_applyAberrationForces_4f7ead34 Instance;
  int actorIdx = SAL__MTM1M3_command_applyAberrationForces_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_applyAberrationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_applyAberrationForces_4f7ead34DataWriter_var SALWriter = MTM1M3::command_applyAberrationForces_4f7ead34DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("4f7ead34");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}

  if (debugLevel > 0) {
    cout << "=== [issueCommand_applyAberrationForces] writing a command containing :" << endl;
       cout << "    zForces : " << data->zForces[0] << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_applyAberrationForces_4f7ead34DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_applyAberrationForces( MTM1M3_command_applyAberrationForcesC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_applyAberrationForces_4f7ead34Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_applyAberrationForces_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_applyAberrationForces");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_applyAberrationForces");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_applyAberrationForces_4f7ead34DataReader_var SALReader = MTM1M3::command_applyAberrationForces_4f7ead34DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC applyAberrationForces] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_command_applyAberrationForces.zForces[iseq] = Instances[j].zForces[iseq];}

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_applyAberrationForces_4f7ead34DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_applyAberrationForces( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_applyAberrationForces_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_applyAberrationForces(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyAberrationForces] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyAberrationForces] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_applyAberrationForces(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyAberrationForces_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyAberrationForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyAberrationForces] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_applyAberrationForcesC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyAberrationForces_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_applyAberrationForces");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyAberrationForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyAberrationForcesC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_applyAberrationForces( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyAberrationForces_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyAberrationForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_applyAberrationForcesC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyAberrationForces_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_applyAberrationForces");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyAberrationForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_clearAberrationForces( MTM1M3_command_clearAberrationForcesC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_clearAberrationForces");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_clearAberrationForces_58d2b112 Instance;
  int actorIdx = SAL__MTM1M3_command_clearAberrationForces_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_clearAberrationForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_clearAberrationForces_58d2b112DataWriter_var SALWriter = MTM1M3::command_clearAberrationForces_58d2b112DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("58d2b112");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.clearAberrationForces = data->clearAberrationForces;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_clearAberrationForces] writing a command containing :" << endl;
    cout << "    clearAberrationForces : " << data->clearAberrationForces << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_clearAberrationForces_58d2b112DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_clearAberrationForces( MTM1M3_command_clearAberrationForcesC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_clearAberrationForces_58d2b112Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_clearAberrationForces_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_clearAberrationForces");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_clearAberrationForces");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_clearAberrationForces_58d2b112DataReader_var SALReader = MTM1M3::command_clearAberrationForces_58d2b112DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearAberrationForces_58d2b112DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_clearAberrationForces_58d2b112DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC clearAberrationForces] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->clearAberrationForces = Instances[j].clearAberrationForces;
    lastSample_MTM1M3_command_clearAberrationForces.clearAberrationForces = Instances[j].clearAberrationForces;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_clearAberrationForces_58d2b112DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_clearAberrationForces( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_clearAberrationForces_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_clearAberrationForces(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_clearAberrationForces] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_clearAberrationForces] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_clearAberrationForces(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_clearAberrationForces_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_clearAberrationForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_clearAberrationForces] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_clearAberrationForcesC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_clearAberrationForces_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_clearAberrationForces");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_clearAberrationForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_clearAberrationForcesC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_clearAberrationForces( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_clearAberrationForces_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_clearAberrationForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_clearAberrationForcesC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_clearAberrationForces_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_clearAberrationForces");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_clearAberrationForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_applyActiveOpticForcesByBendingModes( MTM1M3_command_applyActiveOpticForcesByBendingModesC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_applyActiveOpticForcesByBendingModes");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5b Instance;
  int actorIdx = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_applyActiveOpticForcesByBendingModes");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter_var SALWriter = MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("3b76ff5b");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    for (int iseq=0;iseq<22;iseq++) {Instance.coefficients[iseq] = data->coefficients[iseq];}

  if (debugLevel > 0) {
    cout << "=== [issueCommand_applyActiveOpticForcesByBendingModes] writing a command containing :" << endl;
       cout << "    coefficients : " << data->coefficients[0] << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_applyActiveOpticForcesByBendingModes( MTM1M3_command_applyActiveOpticForcesByBendingModesC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_applyActiveOpticForcesByBendingModes");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_applyActiveOpticForcesByBendingModes");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader_var SALReader = MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC applyActiveOpticForcesByBendingModes] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    for (int iseq=0;iseq<22;iseq++) {data->coefficients[iseq] = Instances[j].coefficients[iseq];}
    for (int iseq=0;iseq<22;iseq++) {lastSample_MTM1M3_command_applyActiveOpticForcesByBendingModes.coefficients[iseq] = Instances[j].coefficients[iseq];}

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_applyActiveOpticForcesByBendingModes_3b76ff5bDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_applyActiveOpticForcesByBendingModes( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_applyActiveOpticForcesByBendingModes(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyActiveOpticForcesByBendingModes] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyActiveOpticForcesByBendingModes] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_applyActiveOpticForcesByBendingModes(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyActiveOpticForcesByBendingModes] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyActiveOpticForcesByBendingModes] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_applyActiveOpticForcesByBendingModesC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_applyActiveOpticForcesByBendingModes");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyActiveOpticForcesByBendingModes] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyActiveOpticForcesByBendingModesC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_applyActiveOpticForcesByBendingModes( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyActiveOpticForcesByBendingModes] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_applyActiveOpticForcesByBendingModesC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyActiveOpticForcesByBendingModes_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_applyActiveOpticForcesByBendingModes");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyActiveOpticForcesByBendingModes] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_applyActiveOpticForces( MTM1M3_command_applyActiveOpticForcesC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_applyActiveOpticForces");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_applyActiveOpticForces_c79b863f Instance;
  int actorIdx = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_applyActiveOpticForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter_var SALWriter = MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("c79b863f");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    for (int iseq=0;iseq<156;iseq++) {Instance.zForces[iseq] = data->zForces[iseq];}

  if (debugLevel > 0) {
    cout << "=== [issueCommand_applyActiveOpticForces] writing a command containing :" << endl;
       cout << "    zForces : " << data->zForces[0] << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_applyActiveOpticForces_c79b863fDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_applyActiveOpticForces( MTM1M3_command_applyActiveOpticForcesC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_applyActiveOpticForces_c79b863fSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_applyActiveOpticForces");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_applyActiveOpticForces");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_applyActiveOpticForces_c79b863fDataReader_var SALReader = MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC applyActiveOpticForces] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    for (int iseq=0;iseq<156;iseq++) {data->zForces[iseq] = Instances[j].zForces[iseq];}
    for (int iseq=0;iseq<156;iseq++) {lastSample_MTM1M3_command_applyActiveOpticForces.zForces[iseq] = Instances[j].zForces[iseq];}

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_applyActiveOpticForces_c79b863fDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_applyActiveOpticForces( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_applyActiveOpticForces(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyActiveOpticForces] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyActiveOpticForces] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_applyActiveOpticForces(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyActiveOpticForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyActiveOpticForces] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_applyActiveOpticForcesC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_applyActiveOpticForces");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyActiveOpticForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyActiveOpticForcesC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_applyActiveOpticForces( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyActiveOpticForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_applyActiveOpticForcesC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyActiveOpticForces_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_applyActiveOpticForces");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyActiveOpticForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_clearActiveOpticForces( MTM1M3_command_clearActiveOpticForcesC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_clearActiveOpticForces");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_clearActiveOpticForces_d4ffa42c Instance;
  int actorIdx = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_clearActiveOpticForces");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter_var SALWriter = MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("d4ffa42c");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.clearActiveOpticForces = data->clearActiveOpticForces;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_clearActiveOpticForces] writing a command containing :" << endl;
    cout << "    clearActiveOpticForces : " << data->clearActiveOpticForces << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_clearActiveOpticForces( MTM1M3_command_clearActiveOpticForcesC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_clearActiveOpticForces_d4ffa42cSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_clearActiveOpticForces");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_clearActiveOpticForces");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader_var SALReader = MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC clearActiveOpticForces] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->clearActiveOpticForces = Instances[j].clearActiveOpticForces;
    lastSample_MTM1M3_command_clearActiveOpticForces.clearActiveOpticForces = Instances[j].clearActiveOpticForces;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_clearActiveOpticForces_d4ffa42cDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_clearActiveOpticForces( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_clearActiveOpticForces(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_clearActiveOpticForces] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_clearActiveOpticForces] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_clearActiveOpticForces(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_clearActiveOpticForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_clearActiveOpticForces] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_clearActiveOpticForcesC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_clearActiveOpticForces");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_clearActiveOpticForces] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_clearActiveOpticForcesC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_clearActiveOpticForces( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_clearActiveOpticForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_clearActiveOpticForcesC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_clearActiveOpticForces_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_clearActiveOpticForces");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_clearActiveOpticForces] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_positionM1M3( MTM1M3_command_positionM1M3C *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_positionM1M3");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_positionM1M3_fa7ca786 Instance;
  int actorIdx = SAL__MTM1M3_command_positionM1M3_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_positionM1M3");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_positionM1M3_fa7ca786DataWriter_var SALWriter = MTM1M3::command_positionM1M3_fa7ca786DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("fa7ca786");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.xPosition = data->xPosition;
    Instance.yPosition = data->yPosition;
    Instance.zPosition = data->zPosition;
    Instance.xRotation = data->xRotation;
    Instance.yRotation = data->yRotation;
    Instance.zRotation = data->zRotation;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_positionM1M3] writing a command containing :" << endl;
    cout << "    xPosition : " << data->xPosition << endl;
    cout << "    yPosition : " << data->yPosition << endl;
    cout << "    zPosition : " << data->zPosition << endl;
    cout << "    xRotation : " << data->xRotation << endl;
    cout << "    yRotation : " << data->yRotation << endl;
    cout << "    zRotation : " << data->zRotation << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_positionM1M3_fa7ca786DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_positionM1M3( MTM1M3_command_positionM1M3C *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_positionM1M3_fa7ca786Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_positionM1M3_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_positionM1M3");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_positionM1M3");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_positionM1M3_fa7ca786DataReader_var SALReader = MTM1M3::command_positionM1M3_fa7ca786DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_positionM1M3_fa7ca786DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_positionM1M3_fa7ca786DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC positionM1M3] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->xPosition = Instances[j].xPosition;
    lastSample_MTM1M3_command_positionM1M3.xPosition = Instances[j].xPosition;
    data->yPosition = Instances[j].yPosition;
    lastSample_MTM1M3_command_positionM1M3.yPosition = Instances[j].yPosition;
    data->zPosition = Instances[j].zPosition;
    lastSample_MTM1M3_command_positionM1M3.zPosition = Instances[j].zPosition;
    data->xRotation = Instances[j].xRotation;
    lastSample_MTM1M3_command_positionM1M3.xRotation = Instances[j].xRotation;
    data->yRotation = Instances[j].yRotation;
    lastSample_MTM1M3_command_positionM1M3.yRotation = Instances[j].yRotation;
    data->zRotation = Instances[j].zRotation;
    lastSample_MTM1M3_command_positionM1M3.zRotation = Instances[j].zRotation;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_positionM1M3_fa7ca786DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_positionM1M3( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_positionM1M3_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_positionM1M3(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_positionM1M3] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_positionM1M3] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_positionM1M3(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_positionM1M3_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_positionM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_positionM1M3] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_positionM1M3C(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_positionM1M3_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_positionM1M3");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_positionM1M3] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_positionM1M3C] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_positionM1M3( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_positionM1M3_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_positionM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_positionM1M3C(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_positionM1M3_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_positionM1M3");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_positionM1M3] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_turnLightsOn( MTM1M3_command_turnLightsOnC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_turnLightsOn");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_turnLightsOn_89e80426 Instance;
  int actorIdx = SAL__MTM1M3_command_turnLightsOn_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_turnLightsOn");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_turnLightsOn_89e80426DataWriter_var SALWriter = MTM1M3::command_turnLightsOn_89e80426DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("89e80426");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.turnLightsOn = data->turnLightsOn;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_turnLightsOn] writing a command containing :" << endl;
    cout << "    turnLightsOn : " << data->turnLightsOn << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_turnLightsOn_89e80426DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_turnLightsOn( MTM1M3_command_turnLightsOnC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_turnLightsOn_89e80426Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_turnLightsOn_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_turnLightsOn");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_turnLightsOn");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_turnLightsOn_89e80426DataReader_var SALReader = MTM1M3::command_turnLightsOn_89e80426DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnLightsOn_89e80426DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_turnLightsOn_89e80426DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC turnLightsOn] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->turnLightsOn = Instances[j].turnLightsOn;
    lastSample_MTM1M3_command_turnLightsOn.turnLightsOn = Instances[j].turnLightsOn;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_turnLightsOn_89e80426DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_turnLightsOn( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_turnLightsOn_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_turnLightsOn(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnLightsOn] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnLightsOn] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_turnLightsOn(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnLightsOn_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnLightsOn] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnLightsOn] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_turnLightsOnC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnLightsOn_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_turnLightsOn");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnLightsOn] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnLightsOnC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_turnLightsOn( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnLightsOn_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnLightsOn] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_turnLightsOnC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnLightsOn_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_turnLightsOn");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnLightsOn] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_turnLightsOff( MTM1M3_command_turnLightsOffC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_turnLightsOff");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_turnLightsOff_08b6e5a2 Instance;
  int actorIdx = SAL__MTM1M3_command_turnLightsOff_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_turnLightsOff");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_turnLightsOff_08b6e5a2DataWriter_var SALWriter = MTM1M3::command_turnLightsOff_08b6e5a2DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("08b6e5a2");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.turnLightsOff = data->turnLightsOff;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_turnLightsOff] writing a command containing :" << endl;
    cout << "    turnLightsOff : " << data->turnLightsOff << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_turnLightsOff_08b6e5a2DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_turnLightsOff( MTM1M3_command_turnLightsOffC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_turnLightsOff_08b6e5a2Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_turnLightsOff_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_turnLightsOff");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_turnLightsOff");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_turnLightsOff_08b6e5a2DataReader_var SALReader = MTM1M3::command_turnLightsOff_08b6e5a2DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC turnLightsOff] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->turnLightsOff = Instances[j].turnLightsOff;
    lastSample_MTM1M3_command_turnLightsOff.turnLightsOff = Instances[j].turnLightsOff;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_turnLightsOff_08b6e5a2DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_turnLightsOff( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_turnLightsOff_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_turnLightsOff(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnLightsOff] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnLightsOff] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_turnLightsOff(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnLightsOff_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnLightsOff] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnLightsOff] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_turnLightsOffC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnLightsOff_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_turnLightsOff");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnLightsOff] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnLightsOffC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_turnLightsOff( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnLightsOff_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnLightsOff] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_turnLightsOffC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnLightsOff_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_turnLightsOff");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnLightsOff] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_turnPowerOn( MTM1M3_command_turnPowerOnC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_turnPowerOn");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_turnPowerOn_7c3fbe06 Instance;
  int actorIdx = SAL__MTM1M3_command_turnPowerOn_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_turnPowerOn");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_turnPowerOn_7c3fbe06DataWriter_var SALWriter = MTM1M3::command_turnPowerOn_7c3fbe06DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("7c3fbe06");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.turnPowerNetworkAOn = data->turnPowerNetworkAOn;
    Instance.turnPowerNetworkBOn = data->turnPowerNetworkBOn;
    Instance.turnPowerNetworkCOn = data->turnPowerNetworkCOn;
    Instance.turnPowerNetworkDOn = data->turnPowerNetworkDOn;
    Instance.turnAuxPowerNetworkAOn = data->turnAuxPowerNetworkAOn;
    Instance.turnAuxPowerNetworkBOn = data->turnAuxPowerNetworkBOn;
    Instance.turnAuxPowerNetworkCOn = data->turnAuxPowerNetworkCOn;
    Instance.turnAuxPowerNetworkDOn = data->turnAuxPowerNetworkDOn;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_turnPowerOn] writing a command containing :" << endl;
    cout << "    turnPowerNetworkAOn : " << data->turnPowerNetworkAOn << endl;
    cout << "    turnPowerNetworkBOn : " << data->turnPowerNetworkBOn << endl;
    cout << "    turnPowerNetworkCOn : " << data->turnPowerNetworkCOn << endl;
    cout << "    turnPowerNetworkDOn : " << data->turnPowerNetworkDOn << endl;
    cout << "    turnAuxPowerNetworkAOn : " << data->turnAuxPowerNetworkAOn << endl;
    cout << "    turnAuxPowerNetworkBOn : " << data->turnAuxPowerNetworkBOn << endl;
    cout << "    turnAuxPowerNetworkCOn : " << data->turnAuxPowerNetworkCOn << endl;
    cout << "    turnAuxPowerNetworkDOn : " << data->turnAuxPowerNetworkDOn << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_turnPowerOn_7c3fbe06DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_turnPowerOn( MTM1M3_command_turnPowerOnC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_turnPowerOn_7c3fbe06Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_turnPowerOn_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_turnPowerOn");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_turnPowerOn");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_turnPowerOn_7c3fbe06DataReader_var SALReader = MTM1M3::command_turnPowerOn_7c3fbe06DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC turnPowerOn] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->turnPowerNetworkAOn = Instances[j].turnPowerNetworkAOn;
    lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkAOn = Instances[j].turnPowerNetworkAOn;
    data->turnPowerNetworkBOn = Instances[j].turnPowerNetworkBOn;
    lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkBOn = Instances[j].turnPowerNetworkBOn;
    data->turnPowerNetworkCOn = Instances[j].turnPowerNetworkCOn;
    lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkCOn = Instances[j].turnPowerNetworkCOn;
    data->turnPowerNetworkDOn = Instances[j].turnPowerNetworkDOn;
    lastSample_MTM1M3_command_turnPowerOn.turnPowerNetworkDOn = Instances[j].turnPowerNetworkDOn;
    data->turnAuxPowerNetworkAOn = Instances[j].turnAuxPowerNetworkAOn;
    lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkAOn = Instances[j].turnAuxPowerNetworkAOn;
    data->turnAuxPowerNetworkBOn = Instances[j].turnAuxPowerNetworkBOn;
    lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkBOn = Instances[j].turnAuxPowerNetworkBOn;
    data->turnAuxPowerNetworkCOn = Instances[j].turnAuxPowerNetworkCOn;
    lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkCOn = Instances[j].turnAuxPowerNetworkCOn;
    data->turnAuxPowerNetworkDOn = Instances[j].turnAuxPowerNetworkDOn;
    lastSample_MTM1M3_command_turnPowerOn.turnAuxPowerNetworkDOn = Instances[j].turnAuxPowerNetworkDOn;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_turnPowerOn_7c3fbe06DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_turnPowerOn( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_turnPowerOn_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_turnPowerOn(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnPowerOn] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnPowerOn] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_turnPowerOn(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnPowerOn_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnPowerOn] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnPowerOn] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_turnPowerOnC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnPowerOn_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_turnPowerOn");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnPowerOn] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnPowerOnC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_turnPowerOn( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnPowerOn_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnPowerOn] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_turnPowerOnC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnPowerOn_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_turnPowerOn");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnPowerOn] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_turnPowerOff( MTM1M3_command_turnPowerOffC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_turnPowerOff");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_turnPowerOff_41dde1fd Instance;
  int actorIdx = SAL__MTM1M3_command_turnPowerOff_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_turnPowerOff");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_turnPowerOff_41dde1fdDataWriter_var SALWriter = MTM1M3::command_turnPowerOff_41dde1fdDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("41dde1fd");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.turnPowerNetworkAOff = data->turnPowerNetworkAOff;
    Instance.turnPowerNetworkBOff = data->turnPowerNetworkBOff;
    Instance.turnPowerNetworkCOff = data->turnPowerNetworkCOff;
    Instance.turnPowerNetworkDOff = data->turnPowerNetworkDOff;
    Instance.turnAuxPowerNetworkAOff = data->turnAuxPowerNetworkAOff;
    Instance.turnAuxPowerNetworkBOff = data->turnAuxPowerNetworkBOff;
    Instance.turnAuxPowerNetworkCOff = data->turnAuxPowerNetworkCOff;
    Instance.turnAuxPowerNetworkDOff = data->turnAuxPowerNetworkDOff;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_turnPowerOff] writing a command containing :" << endl;
    cout << "    turnPowerNetworkAOff : " << data->turnPowerNetworkAOff << endl;
    cout << "    turnPowerNetworkBOff : " << data->turnPowerNetworkBOff << endl;
    cout << "    turnPowerNetworkCOff : " << data->turnPowerNetworkCOff << endl;
    cout << "    turnPowerNetworkDOff : " << data->turnPowerNetworkDOff << endl;
    cout << "    turnAuxPowerNetworkAOff : " << data->turnAuxPowerNetworkAOff << endl;
    cout << "    turnAuxPowerNetworkBOff : " << data->turnAuxPowerNetworkBOff << endl;
    cout << "    turnAuxPowerNetworkCOff : " << data->turnAuxPowerNetworkCOff << endl;
    cout << "    turnAuxPowerNetworkDOff : " << data->turnAuxPowerNetworkDOff << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_turnPowerOff_41dde1fdDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_turnPowerOff( MTM1M3_command_turnPowerOffC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_turnPowerOff_41dde1fdSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_turnPowerOff_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_turnPowerOff");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_turnPowerOff");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_turnPowerOff_41dde1fdDataReader_var SALReader = MTM1M3::command_turnPowerOff_41dde1fdDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_turnPowerOff_41dde1fdDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_turnPowerOff_41dde1fdDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC turnPowerOff] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->turnPowerNetworkAOff = Instances[j].turnPowerNetworkAOff;
    lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkAOff = Instances[j].turnPowerNetworkAOff;
    data->turnPowerNetworkBOff = Instances[j].turnPowerNetworkBOff;
    lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkBOff = Instances[j].turnPowerNetworkBOff;
    data->turnPowerNetworkCOff = Instances[j].turnPowerNetworkCOff;
    lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkCOff = Instances[j].turnPowerNetworkCOff;
    data->turnPowerNetworkDOff = Instances[j].turnPowerNetworkDOff;
    lastSample_MTM1M3_command_turnPowerOff.turnPowerNetworkDOff = Instances[j].turnPowerNetworkDOff;
    data->turnAuxPowerNetworkAOff = Instances[j].turnAuxPowerNetworkAOff;
    lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkAOff = Instances[j].turnAuxPowerNetworkAOff;
    data->turnAuxPowerNetworkBOff = Instances[j].turnAuxPowerNetworkBOff;
    lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkBOff = Instances[j].turnAuxPowerNetworkBOff;
    data->turnAuxPowerNetworkCOff = Instances[j].turnAuxPowerNetworkCOff;
    lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkCOff = Instances[j].turnAuxPowerNetworkCOff;
    data->turnAuxPowerNetworkDOff = Instances[j].turnAuxPowerNetworkDOff;
    lastSample_MTM1M3_command_turnPowerOff.turnAuxPowerNetworkDOff = Instances[j].turnAuxPowerNetworkDOff;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_turnPowerOff_41dde1fdDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_turnPowerOff( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_turnPowerOff_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_turnPowerOff(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnPowerOff] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_turnPowerOff] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_turnPowerOff(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnPowerOff_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnPowerOff] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnPowerOff] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_turnPowerOffC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_turnPowerOff_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_turnPowerOff");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_turnPowerOff] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_turnPowerOffC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_turnPowerOff( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnPowerOff_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnPowerOff] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_turnPowerOffC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_turnPowerOff_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_turnPowerOff");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_turnPowerOff] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_enableHardpointCorrections( MTM1M3_command_enableHardpointCorrectionsC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_enableHardpointCorrections");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_enableHardpointCorrections_dae9c1ec Instance;
  int actorIdx = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_enableHardpointCorrections");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter_var SALWriter = MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("dae9c1ec");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.enableHardpointCorrections = data->enableHardpointCorrections;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_enableHardpointCorrections] writing a command containing :" << endl;
    cout << "    enableHardpointCorrections : " << data->enableHardpointCorrections << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_enableHardpointCorrections( MTM1M3_command_enableHardpointCorrectionsC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_enableHardpointCorrections_dae9c1ecSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_enableHardpointCorrections");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_enableHardpointCorrections");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader_var SALReader = MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC enableHardpointCorrections] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->enableHardpointCorrections = Instances[j].enableHardpointCorrections;
    lastSample_MTM1M3_command_enableHardpointCorrections.enableHardpointCorrections = Instances[j].enableHardpointCorrections;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_enableHardpointCorrections_dae9c1ecDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_enableHardpointCorrections( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_enableHardpointCorrections(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enableHardpointCorrections] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enableHardpointCorrections] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_enableHardpointCorrections(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enableHardpointCorrections] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enableHardpointCorrections] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_enableHardpointCorrectionsC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_enableHardpointCorrections");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enableHardpointCorrections] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enableHardpointCorrectionsC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_enableHardpointCorrections( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enableHardpointCorrections] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_enableHardpointCorrectionsC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enableHardpointCorrections_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_enableHardpointCorrections");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enableHardpointCorrections] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_disableHardpointCorrections( MTM1M3_command_disableHardpointCorrectionsC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_disableHardpointCorrections");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_disableHardpointCorrections_07d1f2ea Instance;
  int actorIdx = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_disableHardpointCorrections");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter_var SALWriter = MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("07d1f2ea");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.disableHardpointCorrections = data->disableHardpointCorrections;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_disableHardpointCorrections] writing a command containing :" << endl;
    cout << "    disableHardpointCorrections : " << data->disableHardpointCorrections << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_disableHardpointCorrections( MTM1M3_command_disableHardpointCorrectionsC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_disableHardpointCorrections_07d1f2eaSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_disableHardpointCorrections");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_disableHardpointCorrections");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader_var SALReader = MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC disableHardpointCorrections] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->disableHardpointCorrections = Instances[j].disableHardpointCorrections;
    lastSample_MTM1M3_command_disableHardpointCorrections.disableHardpointCorrections = Instances[j].disableHardpointCorrections;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_disableHardpointCorrections_07d1f2eaDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_disableHardpointCorrections( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_disableHardpointCorrections(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_disableHardpointCorrections] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_disableHardpointCorrections] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_disableHardpointCorrections(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_disableHardpointCorrections] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_disableHardpointCorrections] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_disableHardpointCorrectionsC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_disableHardpointCorrections");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_disableHardpointCorrections] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_disableHardpointCorrectionsC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_disableHardpointCorrections( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_disableHardpointCorrections] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_disableHardpointCorrectionsC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_disableHardpointCorrections_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_disableHardpointCorrections");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_disableHardpointCorrections] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_runMirrorForceProfile( MTM1M3_command_runMirrorForceProfileC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_runMirrorForceProfile");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_runMirrorForceProfile_33f2be6c Instance;
  int actorIdx = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_runMirrorForceProfile");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter_var SALWriter = MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("33f2be6c");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    for (int iseq=0;iseq<1000;iseq++) {Instance.xForce[iseq] = data->xForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.yForce[iseq] = data->yForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.zForce[iseq] = data->zForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.xMoment[iseq] = data->xMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.yMoment[iseq] = data->yMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {Instance.zMoment[iseq] = data->zMoment[iseq];}

  if (debugLevel > 0) {
    cout << "=== [issueCommand_runMirrorForceProfile] writing a command containing :" << endl;
       cout << "    xForce : " << data->xForce[0] << endl;
       cout << "    yForce : " << data->yForce[0] << endl;
       cout << "    zForce : " << data->zForce[0] << endl;
       cout << "    xMoment : " << data->xMoment[0] << endl;
       cout << "    yMoment : " << data->yMoment[0] << endl;
       cout << "    zMoment : " << data->zMoment[0] << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_runMirrorForceProfile( MTM1M3_command_runMirrorForceProfileC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_runMirrorForceProfile_33f2be6cSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_runMirrorForceProfile");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_runMirrorForceProfile");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader_var SALReader = MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC runMirrorForceProfile] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    for (int iseq=0;iseq<1000;iseq++) {data->xForce[iseq] = Instances[j].xForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.xForce[iseq] = Instances[j].xForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->yForce[iseq] = Instances[j].yForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.yForce[iseq] = Instances[j].yForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->zForce[iseq] = Instances[j].zForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.zForce[iseq] = Instances[j].zForce[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->xMoment[iseq] = Instances[j].xMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.xMoment[iseq] = Instances[j].xMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->yMoment[iseq] = Instances[j].yMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.yMoment[iseq] = Instances[j].yMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {data->zMoment[iseq] = Instances[j].zMoment[iseq];}
    for (int iseq=0;iseq<1000;iseq++) {lastSample_MTM1M3_command_runMirrorForceProfile.zMoment[iseq] = Instances[j].zMoment[iseq];}

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_runMirrorForceProfile_33f2be6cDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_runMirrorForceProfile( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_runMirrorForceProfile(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_runMirrorForceProfile] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_runMirrorForceProfile] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_runMirrorForceProfile(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_runMirrorForceProfile] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_runMirrorForceProfile] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_runMirrorForceProfileC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_runMirrorForceProfile");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_runMirrorForceProfile] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_runMirrorForceProfileC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_runMirrorForceProfile( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_runMirrorForceProfile] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_runMirrorForceProfileC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_runMirrorForceProfile_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_runMirrorForceProfile");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_runMirrorForceProfile] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_abortProfile( MTM1M3_command_abortProfileC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_abortProfile");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_abortProfile_88b2fb6a Instance;
  int actorIdx = SAL__MTM1M3_command_abortProfile_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_abortProfile");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_abortProfile_88b2fb6aDataWriter_var SALWriter = MTM1M3::command_abortProfile_88b2fb6aDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("88b2fb6a");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.abortProfile = data->abortProfile;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_abortProfile] writing a command containing :" << endl;
    cout << "    abortProfile : " << data->abortProfile << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_abortProfile_88b2fb6aDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_abortProfile( MTM1M3_command_abortProfileC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_abortProfile_88b2fb6aSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_abortProfile_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_abortProfile");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_abortProfile");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_abortProfile_88b2fb6aDataReader_var SALReader = MTM1M3::command_abortProfile_88b2fb6aDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abortProfile_88b2fb6aDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_abortProfile_88b2fb6aDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC abortProfile] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->abortProfile = Instances[j].abortProfile;
    lastSample_MTM1M3_command_abortProfile.abortProfile = Instances[j].abortProfile;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_abortProfile_88b2fb6aDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_abortProfile( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_abortProfile_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_abortProfile(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_abortProfile] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_abortProfile] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_abortProfile(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_abortProfile_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_abortProfile] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_abortProfile] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_abortProfileC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_abortProfile_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_abortProfile");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_abortProfile] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_abortProfileC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_abortProfile( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_abortProfile_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_abortProfile] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_abortProfileC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_abortProfile_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_abortProfile");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_abortProfile] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_applyOffsetForcesByMirrorForce( MTM1M3_command_applyOffsetForcesByMirrorForceC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_applyOffsetForcesByMirrorForce");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953 Instance;
  int actorIdx = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_applyOffsetForcesByMirrorForce");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter_var SALWriter = MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("4d09c953");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.xForce = data->xForce;
    Instance.yForce = data->yForce;
    Instance.zForce = data->zForce;
    Instance.xMoment = data->xMoment;
    Instance.yMoment = data->yMoment;
    Instance.zMoment = data->zMoment;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_applyOffsetForcesByMirrorForce] writing a command containing :" << endl;
    cout << "    xForce : " << data->xForce << endl;
    cout << "    yForce : " << data->yForce << endl;
    cout << "    zForce : " << data->zForce << endl;
    cout << "    xMoment : " << data->xMoment << endl;
    cout << "    yMoment : " << data->yMoment << endl;
    cout << "    zMoment : " << data->zMoment << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_applyOffsetForcesByMirrorForce( MTM1M3_command_applyOffsetForcesByMirrorForceC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_applyOffsetForcesByMirrorForce");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_applyOffsetForcesByMirrorForce");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader_var SALReader = MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC applyOffsetForcesByMirrorForce] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->xForce = Instances[j].xForce;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.xForce = Instances[j].xForce;
    data->yForce = Instances[j].yForce;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.yForce = Instances[j].yForce;
    data->zForce = Instances[j].zForce;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.zForce = Instances[j].zForce;
    data->xMoment = Instances[j].xMoment;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.xMoment = Instances[j].xMoment;
    data->yMoment = Instances[j].yMoment;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.yMoment = Instances[j].yMoment;
    data->zMoment = Instances[j].zMoment;
    lastSample_MTM1M3_command_applyOffsetForcesByMirrorForce.zMoment = Instances[j].zMoment;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_applyOffsetForcesByMirrorForce_4d09c953DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_applyOffsetForcesByMirrorForce( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_applyOffsetForcesByMirrorForce(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyOffsetForcesByMirrorForce] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_applyOffsetForcesByMirrorForce] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_applyOffsetForcesByMirrorForce(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyOffsetForcesByMirrorForce] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyOffsetForcesByMirrorForce] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_applyOffsetForcesByMirrorForceC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_applyOffsetForcesByMirrorForce");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_applyOffsetForcesByMirrorForce] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_applyOffsetForcesByMirrorForceC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_applyOffsetForcesByMirrorForce( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyOffsetForcesByMirrorForce] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_applyOffsetForcesByMirrorForceC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_applyOffsetForcesByMirrorForce_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_applyOffsetForcesByMirrorForce");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_applyOffsetForcesByMirrorForce] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_updatePID( MTM1M3_command_updatePIDC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_updatePID");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_updatePID_6e2af9f8 Instance;
  int actorIdx = SAL__MTM1M3_command_updatePID_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_updatePID");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_updatePID_6e2af9f8DataWriter_var SALWriter = MTM1M3::command_updatePID_6e2af9f8DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("6e2af9f8");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.pid = data->pid;
    Instance.timestep = data->timestep;
    Instance.p = data->p;
    Instance.i = data->i;
    Instance.d = data->d;
    Instance.n = data->n;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_updatePID] writing a command containing :" << endl;
    cout << "    pid : " << data->pid << endl;
    cout << "    timestep : " << data->timestep << endl;
    cout << "    p : " << data->p << endl;
    cout << "    i : " << data->i << endl;
    cout << "    d : " << data->d << endl;
    cout << "    n : " << data->n << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_updatePID_6e2af9f8DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_updatePID( MTM1M3_command_updatePIDC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_updatePID_6e2af9f8Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_updatePID_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_updatePID");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_updatePID");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_updatePID_6e2af9f8DataReader_var SALReader = MTM1M3::command_updatePID_6e2af9f8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_updatePID_6e2af9f8DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_updatePID_6e2af9f8DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC updatePID] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->pid = Instances[j].pid;
    lastSample_MTM1M3_command_updatePID.pid = Instances[j].pid;
    data->timestep = Instances[j].timestep;
    lastSample_MTM1M3_command_updatePID.timestep = Instances[j].timestep;
    data->p = Instances[j].p;
    lastSample_MTM1M3_command_updatePID.p = Instances[j].p;
    data->i = Instances[j].i;
    lastSample_MTM1M3_command_updatePID.i = Instances[j].i;
    data->d = Instances[j].d;
    lastSample_MTM1M3_command_updatePID.d = Instances[j].d;
    data->n = Instances[j].n;
    lastSample_MTM1M3_command_updatePID.n = Instances[j].n;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_updatePID_6e2af9f8DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_updatePID( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_updatePID_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_updatePID(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_updatePID] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_updatePID] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_updatePID(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_updatePID_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_updatePID] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_updatePID] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_updatePIDC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_updatePID_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_updatePID");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_updatePID] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_updatePIDC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_updatePID( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_updatePID_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_updatePID] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_updatePIDC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_updatePID_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_updatePID");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_updatePID] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_resetPID( MTM1M3_command_resetPIDC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_resetPID");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_resetPID_bc5508ce Instance;
  int actorIdx = SAL__MTM1M3_command_resetPID_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_resetPID");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_resetPID_bc5508ceDataWriter_var SALWriter = MTM1M3::command_resetPID_bc5508ceDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("bc5508ce");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.pid = data->pid;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_resetPID] writing a command containing :" << endl;
    cout << "    pid : " << data->pid << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_resetPID_bc5508ceDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_resetPID( MTM1M3_command_resetPIDC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_resetPID_bc5508ceSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_resetPID_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_resetPID");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_resetPID");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_resetPID_bc5508ceDataReader_var SALReader = MTM1M3::command_resetPID_bc5508ceDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_resetPID_bc5508ceDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_resetPID_bc5508ceDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC resetPID] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->pid = Instances[j].pid;
    lastSample_MTM1M3_command_resetPID.pid = Instances[j].pid;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_resetPID_bc5508ceDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_resetPID( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_resetPID_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_resetPID(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_resetPID] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_resetPID] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_resetPID(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_resetPID_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_resetPID] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_resetPID] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_resetPIDC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_resetPID_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_resetPID");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_resetPID] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_resetPIDC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_resetPID( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_resetPID_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_resetPID] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_resetPIDC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_resetPID_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_resetPID");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_resetPID] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_setThermalSetpoint( MTM1M3_command_setThermalSetpointC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_setThermalSetpoint");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_setThermalSetpoint_ca5041e8 Instance;
  int actorIdx = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_setThermalSetpoint");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter_var SALWriter = MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("ca5041e8");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.setpoint = data->setpoint;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_setThermalSetpoint] writing a command containing :" << endl;
    cout << "    setpoint : " << data->setpoint << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_setThermalSetpoint_ca5041e8DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_setThermalSetpoint( MTM1M3_command_setThermalSetpointC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_setThermalSetpoint_ca5041e8Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_setThermalSetpoint");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_setThermalSetpoint");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_setThermalSetpoint_ca5041e8DataReader_var SALReader = MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC setThermalSetpoint] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->setpoint = Instances[j].setpoint;
    lastSample_MTM1M3_command_setThermalSetpoint.setpoint = Instances[j].setpoint;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_setThermalSetpoint_ca5041e8DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_setThermalSetpoint( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_setThermalSetpoint(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_setThermalSetpoint] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_setThermalSetpoint] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_setThermalSetpoint(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_setThermalSetpoint] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_setThermalSetpoint] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_setThermalSetpointC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_setThermalSetpoint");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_setThermalSetpoint] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_setThermalSetpointC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_setThermalSetpoint( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_setThermalSetpoint] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_setThermalSetpointC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_setThermalSetpoint_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_setThermalSetpoint");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_setThermalSetpoint] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_programILC( MTM1M3_command_programILCC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_programILC");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_programILC_7dde50ee Instance;
  int actorIdx = SAL__MTM1M3_command_programILC_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_programILC");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_programILC_7dde50eeDataWriter_var SALWriter = MTM1M3::command_programILC_7dde50eeDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("7dde50ee");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.actuatorId = data->actuatorId;
    Instance.filePath = DDS::string_dup(data->filePath.c_str());

  if (debugLevel > 0) {
    cout << "=== [issueCommand_programILC] writing a command containing :" << endl;
    cout << "    actuatorId : " << data->actuatorId << endl;
    cout << "    filePath : " << data->filePath << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_programILC_7dde50eeDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_programILC( MTM1M3_command_programILCC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_programILC_7dde50eeSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_programILC_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_programILC");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_programILC");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_programILC_7dde50eeDataReader_var SALReader = MTM1M3::command_programILC_7dde50eeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_programILC_7dde50eeDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_programILC_7dde50eeDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC programILC] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->actuatorId = Instances[j].actuatorId;
    lastSample_MTM1M3_command_programILC.actuatorId = Instances[j].actuatorId;
    data->filePath=Instances[j].filePath.m_ptr;
    lastSample_MTM1M3_command_programILC.filePath=Instances[j].filePath.m_ptr;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_programILC_7dde50eeDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_programILC( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_programILC_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_programILC(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_programILC] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_programILC] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_programILC(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_programILC_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_programILC] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_programILC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_programILCC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_programILC_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_programILC");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_programILC] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_programILCC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_programILC( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_programILC_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_programILC] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_programILCC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_programILC_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_programILC");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_programILC] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_modbusTransmit( MTM1M3_command_modbusTransmitC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_modbusTransmit");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_modbusTransmit_a3c81bde Instance;
  int actorIdx = SAL__MTM1M3_command_modbusTransmit_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_modbusTransmit");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_modbusTransmit_a3c81bdeDataWriter_var SALWriter = MTM1M3::command_modbusTransmit_a3c81bdeDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("a3c81bde");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.actuatorId = data->actuatorId;
    Instance.functionCode = data->functionCode;
    for (int iseq=0;iseq<252;iseq++) {Instance.data[iseq] = data->data[iseq];}
    Instance.dataLength = data->dataLength;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_modbusTransmit] writing a command containing :" << endl;
    cout << "    actuatorId : " << data->actuatorId << endl;
    cout << "    functionCode : " << data->functionCode << endl;
       cout << "    data : " << data->data[0] << endl;
    cout << "    dataLength : " << data->dataLength << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_modbusTransmit_a3c81bdeDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_modbusTransmit( MTM1M3_command_modbusTransmitC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_modbusTransmit_a3c81bdeSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_modbusTransmit_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_modbusTransmit");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_modbusTransmit");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_modbusTransmit_a3c81bdeDataReader_var SALReader = MTM1M3::command_modbusTransmit_a3c81bdeDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC modbusTransmit] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->actuatorId = Instances[j].actuatorId;
    lastSample_MTM1M3_command_modbusTransmit.actuatorId = Instances[j].actuatorId;
    data->functionCode = Instances[j].functionCode;
    lastSample_MTM1M3_command_modbusTransmit.functionCode = Instances[j].functionCode;
    for (int iseq=0;iseq<252;iseq++) {data->data[iseq] = Instances[j].data[iseq];}
    for (int iseq=0;iseq<252;iseq++) {lastSample_MTM1M3_command_modbusTransmit.data[iseq] = Instances[j].data[iseq];}
    data->dataLength = Instances[j].dataLength;
    lastSample_MTM1M3_command_modbusTransmit.dataLength = Instances[j].dataLength;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_modbusTransmit_a3c81bdeDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_modbusTransmit( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_modbusTransmit_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_modbusTransmit(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_modbusTransmit] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_modbusTransmit] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_modbusTransmit(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_modbusTransmit_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_modbusTransmit] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_modbusTransmit] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_modbusTransmitC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_modbusTransmit_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_modbusTransmit");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_modbusTransmit] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_modbusTransmitC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_modbusTransmit( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_modbusTransmit_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_modbusTransmit] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_modbusTransmitC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_modbusTransmit_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_modbusTransmit");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_modbusTransmit] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_abort( MTM1M3_command_abortC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_abort");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_abort_62d3a8d0 Instance;
  int actorIdx = SAL__MTM1M3_command_abort_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_abort");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_abort_62d3a8d0DataWriter_var SALWriter = MTM1M3::command_abort_62d3a8d0DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("62d3a8d0");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.value = data->value;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_abort] writing a command containing :" << endl;
    cout << "    value : " << data->value << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_abort_62d3a8d0DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_abort( MTM1M3_command_abortC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_abort_62d3a8d0Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_abort_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_abort");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_abort");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_abort_62d3a8d0DataReader_var SALReader = MTM1M3::command_abort_62d3a8d0DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_abort_62d3a8d0DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_abort_62d3a8d0DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC abort] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->value = Instances[j].value;
    lastSample_MTM1M3_command_abort.value = Instances[j].value;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_abort_62d3a8d0DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_abort( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_abort_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_abort(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_abort] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_abort] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_abort(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_abort_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_abort] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_abort] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_abortC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_abort_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_abort");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_abort] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_abortC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_abort( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_abort_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_abort] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_abortC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_abort_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_abort");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_abort] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_enable( MTM1M3_command_enableC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_enable");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_enable_c128bf47 Instance;
  int actorIdx = SAL__MTM1M3_command_enable_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_enable");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_enable_c128bf47DataWriter_var SALWriter = MTM1M3::command_enable_c128bf47DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("c128bf47");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.value = data->value;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_enable] writing a command containing :" << endl;
    cout << "    value : " << data->value << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_enable_c128bf47DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_enable( MTM1M3_command_enableC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_enable_c128bf47Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_enable_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_enable");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_enable");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_enable_c128bf47DataReader_var SALReader = MTM1M3::command_enable_c128bf47DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enable_c128bf47DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_enable_c128bf47DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC enable] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->value = Instances[j].value;
    lastSample_MTM1M3_command_enable.value = Instances[j].value;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_enable_c128bf47DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_enable( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_enable_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_enable(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enable] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enable] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_enable(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enable_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enable] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enable] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_enableC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enable_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_enable");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enable] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enableC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_enable( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enable_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enable] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_enableC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enable_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_enable");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enable] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_disable( MTM1M3_command_disableC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_disable");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_disable_04faa884 Instance;
  int actorIdx = SAL__MTM1M3_command_disable_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_disable");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_disable_04faa884DataWriter_var SALWriter = MTM1M3::command_disable_04faa884DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("04faa884");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.value = data->value;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_disable] writing a command containing :" << endl;
    cout << "    value : " << data->value << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_disable_04faa884DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_disable( MTM1M3_command_disableC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_disable_04faa884Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_disable_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_disable");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_disable");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_disable_04faa884DataReader_var SALReader = MTM1M3::command_disable_04faa884DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_disable_04faa884DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_disable_04faa884DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC disable] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->value = Instances[j].value;
    lastSample_MTM1M3_command_disable.value = Instances[j].value;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_disable_04faa884DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_disable( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_disable_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_disable(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_disable] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_disable] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_disable(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_disable_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_disable] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_disable] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_disableC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_disable_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_disable");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_disable] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_disableC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_disable( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_disable_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_disable] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_disableC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_disable_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_disable");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_disable] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_standby( MTM1M3_command_standbyC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_standby");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_standby_9b43256c Instance;
  int actorIdx = SAL__MTM1M3_command_standby_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_standby");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_standby_9b43256cDataWriter_var SALWriter = MTM1M3::command_standby_9b43256cDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("9b43256c");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.value = data->value;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_standby] writing a command containing :" << endl;
    cout << "    value : " << data->value << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_standby_9b43256cDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_standby( MTM1M3_command_standbyC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_standby_9b43256cSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_standby_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_standby");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_standby");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_standby_9b43256cDataReader_var SALReader = MTM1M3::command_standby_9b43256cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_standby_9b43256cDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_standby_9b43256cDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC standby] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->value = Instances[j].value;
    lastSample_MTM1M3_command_standby.value = Instances[j].value;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_standby_9b43256cDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_standby( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_standby_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_standby(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_standby] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_standby] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_standby(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_standby_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_standby] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_standby] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_standbyC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_standby_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_standby");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_standby] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_standbyC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_standby( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_standby_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_standby] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_standbyC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_standby_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_standby");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_standby] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_exitControl( MTM1M3_command_exitControlC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_exitControl");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_exitControl_e2ea247d Instance;
  int actorIdx = SAL__MTM1M3_command_exitControl_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_exitControl");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_exitControl_e2ea247dDataWriter_var SALWriter = MTM1M3::command_exitControl_e2ea247dDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("e2ea247d");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.value = data->value;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_exitControl] writing a command containing :" << endl;
    cout << "    value : " << data->value << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_exitControl_e2ea247dDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_exitControl( MTM1M3_command_exitControlC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_exitControl_e2ea247dSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_exitControl_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_exitControl");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_exitControl");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_exitControl_e2ea247dDataReader_var SALReader = MTM1M3::command_exitControl_e2ea247dDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_exitControl_e2ea247dDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_exitControl_e2ea247dDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC exitControl] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->value = Instances[j].value;
    lastSample_MTM1M3_command_exitControl.value = Instances[j].value;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_exitControl_e2ea247dDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_exitControl( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_exitControl_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_exitControl(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_exitControl] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_exitControl] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_exitControl(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_exitControl_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_exitControl] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_exitControl] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_exitControlC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_exitControl_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_exitControl");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_exitControl] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_exitControlC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_exitControl( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_exitControl_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_exitControl] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_exitControlC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_exitControl_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_exitControl");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_exitControl] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_start( MTM1M3_command_startC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_start");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_start_63435b30 Instance;
  int actorIdx = SAL__MTM1M3_command_start_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_start");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_start_63435b30DataWriter_var SALWriter = MTM1M3::command_start_63435b30DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("63435b30");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.settingsToApply = DDS::string_dup(data->settingsToApply.c_str());

  if (debugLevel > 0) {
    cout << "=== [issueCommand_start] writing a command containing :" << endl;
    cout << "    settingsToApply : " << data->settingsToApply << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_start_63435b30DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_start( MTM1M3_command_startC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_start_63435b30Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_start_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_start");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_start");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_start_63435b30DataReader_var SALReader = MTM1M3::command_start_63435b30DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_start_63435b30DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_start_63435b30DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC start] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->settingsToApply=Instances[j].settingsToApply.m_ptr;
    lastSample_MTM1M3_command_start.settingsToApply=Instances[j].settingsToApply.m_ptr;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_start_63435b30DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_start( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_start_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_start(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_start] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_start] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_start(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_start_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_start] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_start] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_startC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_start_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_start");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_start] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_startC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_start( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_start_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_start] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_startC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_start_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_start");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_start] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_enterControl( MTM1M3_command_enterControlC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_enterControl");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_enterControl_417c941a Instance;
  int actorIdx = SAL__MTM1M3_command_enterControl_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_enterControl");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_enterControl_417c941aDataWriter_var SALWriter = MTM1M3::command_enterControl_417c941aDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("417c941a");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.value = data->value;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_enterControl] writing a command containing :" << endl;
    cout << "    value : " << data->value << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_enterControl_417c941aDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_enterControl( MTM1M3_command_enterControlC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_enterControl_417c941aSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_enterControl_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_enterControl");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_enterControl");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_enterControl_417c941aDataReader_var SALReader = MTM1M3::command_enterControl_417c941aDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_enterControl_417c941aDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_enterControl_417c941aDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC enterControl] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->value = Instances[j].value;
    lastSample_MTM1M3_command_enterControl.value = Instances[j].value;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_enterControl_417c941aDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_enterControl( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_enterControl_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_enterControl(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enterControl] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_enterControl] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_enterControl(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enterControl_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enterControl] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enterControl] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_enterControlC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_enterControl_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_enterControl");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_enterControl] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_enterControlC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_enterControl( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enterControl_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enterControl] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_enterControlC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_enterControl_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_enterControl");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_enterControl] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_setLogLevel( MTM1M3_command_setLogLevelC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_setLogLevel");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_setLogLevel_346fd770 Instance;
  int actorIdx = SAL__MTM1M3_command_setLogLevel_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_setLogLevel");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_setLogLevel_346fd770DataWriter_var SALWriter = MTM1M3::command_setLogLevel_346fd770DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("346fd770");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.level = data->level;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_setLogLevel] writing a command containing :" << endl;
    cout << "    level : " << data->level << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_setLogLevel_346fd770DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_setLogLevel( MTM1M3_command_setLogLevelC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_setLogLevel_346fd770Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_setLogLevel_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_setLogLevel");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_setLogLevel");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_setLogLevel_346fd770DataReader_var SALReader = MTM1M3::command_setLogLevel_346fd770DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setLogLevel_346fd770DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_setLogLevel_346fd770DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC setLogLevel] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->level = Instances[j].level;
    lastSample_MTM1M3_command_setLogLevel.level = Instances[j].level;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_setLogLevel_346fd770DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_setLogLevel( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_setLogLevel_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_setLogLevel(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_setLogLevel] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_setLogLevel] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_setLogLevel(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_setLogLevel_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_setLogLevel] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_setLogLevel] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_setLogLevelC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_setLogLevel_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_setLogLevel");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_setLogLevel] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_setLogLevelC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_setLogLevel( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_setLogLevel_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_setLogLevel] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_setLogLevelC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_setLogLevel_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_setLogLevel");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_setLogLevel] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_setSimulationMode( MTM1M3_command_setSimulationModeC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_setSimulationMode");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_setSimulationMode_dccc3b3c Instance;
  int actorIdx = SAL__MTM1M3_command_setSimulationMode_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_setSimulationMode");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_setSimulationMode_dccc3b3cDataWriter_var SALWriter = MTM1M3::command_setSimulationMode_dccc3b3cDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("dccc3b3c");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.mode = data->mode;

  if (debugLevel > 0) {
    cout << "=== [issueCommand_setSimulationMode] writing a command containing :" << endl;
    cout << "    mode : " << data->mode << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_setSimulationMode_dccc3b3cDataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_setSimulationMode( MTM1M3_command_setSimulationModeC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_setSimulationMode_dccc3b3cSeq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_setSimulationMode_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_setSimulationMode");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_setSimulationMode");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_setSimulationMode_dccc3b3cDataReader_var SALReader = MTM1M3::command_setSimulationMode_dccc3b3cDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC setSimulationMode] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->mode = Instances[j].mode;
    lastSample_MTM1M3_command_setSimulationMode.mode = Instances[j].mode;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_setSimulationMode_dccc3b3cDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_setSimulationMode( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_setSimulationMode_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_setSimulationMode(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_setSimulationMode] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_setSimulationMode] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_setSimulationMode(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_setSimulationMode_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_setSimulationMode] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_setSimulationMode] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_setSimulationModeC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_setSimulationMode_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_setSimulationMode");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_setSimulationMode] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_setSimulationModeC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_setSimulationMode( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_setSimulationMode_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_setSimulationMode] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_setSimulationModeC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_setSimulationMode_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_setSimulationMode");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_setSimulationMode] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::issueCommand_setValue( MTM1M3_command_setValueC *data )
{
  
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for issueCommand_setValue");
  }
  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  MTM1M3::command_setValue_56638307 Instance;
  int actorIdx = SAL__MTM1M3_command_setValue_ACTOR;
  // create DataWriter :
  if (sal[actorIdx].isCommand == false) {
     throw std::runtime_error("No commander for issueCommand_setValue");
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  MTM1M3::command_setValue_56638307DataWriter_var SALWriter = MTM1M3::command_setValue_56638307DataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.MTM1M3ID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("56638307");
  Instance.private_sndStamp = getCurrentTime();
  Instance.private_origin =   getpid();
  Instance.private_seqNum =   sal[actorIdx].sndSeqNum;
  Instance.private_host =     ddsIPaddress;
    Instance.parametersAndValues = DDS::string_dup(data->parametersAndValues.c_str());

  if (debugLevel > 0) {
    cout << "=== [issueCommand_setValue] writing a command containing :" << endl;
    cout << "    parametersAndValues : " << data->parametersAndValues << endl;

  }
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sal[actorIdx].sndSeqNum++;
//  if(sal[actorIdx].sndSeqNum >= 32768*(actorIdx+1) ) {
//     sal[actorIdx].sndSeqNum = 32768*actorIdx + 1;
//  }
  checkStatus(status, "MTM1M3::command_setValue_56638307DataWriter::write");  
//    SALWriter->unregister_instance(Instance, cmdHandle);
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sal[actorIdx].sndSeqNum-1);
}


int SAL_MTM1M3::acceptCommand_setValue( MTM1M3_command_setValueC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   MTM1M3::command_setValue_56638307Seq Instances;
   MTM1M3::ackcmd_004df1cb ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_command_setValue_ACTOR;
   int j=0;
   if ( data == NULL ) {
      throw std::runtime_error("NULL pointer for acceptCommand_setValue");
   }

  // create DataWriter :
  if (sal[actorIdx].isProcessor == false) {
      throw std::runtime_error("No controller for acceptCommand_setValue");
  }
  DataWriter_var dwriter = getWriter2(SAL__MTM1M3_ackcmd_ACTOR);
  MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader(actorIdx);
  MTM1M3::command_setValue_56638307DataReader_var SALReader = MTM1M3::command_setValue_56638307DataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::command_setValue_56638307DataReader::_narrow");
  istatus = SALReader->take(Instances, info, 1,NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  checkStatus(istatus, "MTM1M3::command_setValue_56638307DataReader::take");
  if (Instances.length() > 0) {
   j = Instances.length()-1;
   if (info[j].valid_data) {
    if (debugLevel > 8) {
      cout << "=== [acceptCommandC setValue] reading a command containing :" << endl;
      cout << "    seqNum   : " << Instances[j].private_seqNum << endl;
      cout << "    host     : " << Instances[j].private_host << endl;
      cout << "    origin   : " << Instances[j].private_origin << endl;
      cout << "    sample-state   : " << info[j].sample_state << endl;
      cout << "    view-state     : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.origin = Instances[j].private_origin;
    ackdata.host = Instances[j].private_host;
    ackdata.private_seqNum = Instances[j].private_seqNum;
    ackdata.cmdtype = actorIdx;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = Instances[j].private_seqNum;
    rcvdTime = getCurrentTime();
    sal[actorIdx].rcvStamp = rcvdTime;
    sal[actorIdx].sndStamp = Instances[j].private_sndStamp;
    if ( (rcvdTime - Instances[j].private_sndStamp) < sal[actorIdx].sampleAge ) {
      rcvSeqNum = status;
      rcvOrigin = Instances[j].private_origin;
      sal[actorIdx].activehost = Instances[j].private_host;
      sal[actorIdx].activeorigin = Instances[j].private_origin;
      sal[actorIdx].activecmdid = Instances[j].private_seqNum;
      ackdata.ack = SAL__CMD_ACK;
    data->parametersAndValues=Instances[j].parametersAndValues.m_ptr;
    lastSample_MTM1M3_command_setValue.parametersAndValues=Instances[j].parametersAndValues.m_ptr;

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.MTM1M3ID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::write");

//    SALWriter->unregister_instance(ackdata, ackHandle);
     } else {
        if (debugLevel > 8) {
          cout << "    Old command ignored : " << status << ":" << int(rcvdTime) << endl;
        }
        status = 0;
     }
   }
  } else {
    status = 0;
  }
  istatus = SALReader->return_loan(Instances, info);
  checkStatus(istatus, "MTM1M3::command_setValue_56638307DataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::waitForCompletion_setValue( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout*100;
   MTM1M3::ackcmd_004df1cbSeq response;
   int actorIdx = SAL__MTM1M3_command_setValue_ACTOR;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse_setValue(response);
      if (status != SAL__CMD_NOACK) {
        if (sal[actorIdx].rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_setValue] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion_setValue] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }
   return status;
}


salReturn SAL_MTM1M3::getResponse_setValue(MTM1M3::ackcmd_004df1cbSeq data)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_setValue_ACTOR;
  SampleInfoSeq info;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmd_004df1cbDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_setValue] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].ack;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_setValue] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::getResponse_setValueC(MTM1M3_ackcmdC *response)
{
  int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
  int actorIdxCmd = SAL__MTM1M3_command_setValue_ACTOR;
  SampleInfoSeq info;
  MTM1M3::ackcmd_004df1cbSeq data;
  ReturnCode_t status = SAL__CMD_NOACK;
  ReturnCode_t istatus =  -1;
  int j=0;
  if ( response == NULL ) {
     throw std::runtime_error("NULL pointer for getResponse_setValue");
  }
  DataReader_var dreader = getReader2(actorIdx);
  MTM1M3::ackcmd_004df1cbDataReader_var SALReader = MTM1M3::ackcmd_004df1cbDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "MTM1M3::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1, NOT_READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
  sal[actorIdxCmd].rcvSeqNum = 0;
  sal[actorIdxCmd].rcvOrigin = 0;
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::take");
  if (data.length() > 0) {
   j = data.length()-1;
   if (data[j].private_seqNum > 0) {
    if (debugLevel > 8) {
      cout << "=== [getResponse_setValue] reading a message containing :" << endl;
      cout << "    seqNum   : " << data[j].private_seqNum << endl;
      cout << "    error    : " << data[j].error << endl;
      cout << "    ack      : " << data[j].ack << endl;
      cout << "    result   : " << data[j].result << endl;
      cout << "    sample-state : " << info[j].sample_state << endl;
      cout << "    view-state : " << info[j].view_state << endl;
      cout << "    instance-state : " << info[j].instance_state << endl;
    }
// check origin, host , cmdtype here
    status = data[j].private_seqNum;;
    rcvdTime = getCurrentTime();
    sal[actorIdxCmd].rcvStamp = rcvdTime;
    sal[actorIdxCmd].sndStamp = data[j].private_sndStamp;
    sal[actorIdxCmd].rcvSeqNum = data[j].private_seqNum;
    sal[actorIdxCmd].rcvOrigin = data[j].private_origin;
    sal[actorIdxCmd].ack = data[j].ack;
    sal[actorIdxCmd].error = data[j].error;
    strcpy(sal[actorIdxCmd].result,DDS::string_dup(data[j].result));
    response->ack = data[j].ack;
    response->error = data[j].error;
    response->host = data[j].host;
    response->origin = data[j].origin;
    response->cmdtype = data[j].cmdtype;
    response->timeout = data[j].timeout;
    response->result= DDS::string_dup(data[j].result);
   } else {
      if (debugLevel > 8) {
         cout << "=== [getResponse_setValueC] No ack yet!" << endl;
      }
      status = SAL__CMD_NOACK;
   }
  }
  istatus = SALReader->return_loan(data, info);
  checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataReader::return_loan");
  return status;
}


salReturn SAL_MTM1M3::ackCommand_setValue( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_setValue_ACTOR;

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = cmdId;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_setValue] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


salReturn SAL_MTM1M3::ackCommand_setValueC(MTM1M3_ackcmdC *response )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;
   int actorIdx = SAL__MTM1M3_ackcmd_ACTOR;
   int actorIdxCmd = SAL__MTM1M3_command_setValue_ACTOR;
   if ( response == NULL ) {
      throw std::runtime_error("NULL pointer for ackCommand_setValue");
   }

   MTM1M3::ackcmd_004df1cb ackdata;
   DataWriter_var dwriter = getWriter2(actorIdx);
   MTM1M3::ackcmd_004df1cbDataWriter_var SALWriter = MTM1M3::ackcmd_004df1cbDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = getpid();
   ackdata.private_seqNum = sal[actorIdxCmd].activecmdid;
   ackdata.private_host = ddsIPaddress;
   ackdata.error = response->error;
   ackdata.ack = response->ack;
   ackdata.result = DDS::string_dup(response->result.c_str());
   ackdata.host = sal[actorIdxCmd].activehost;
   ackdata.origin = sal[actorIdxCmd].activeorigin;
   ackdata.cmdtype = actorIdxCmd;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.MTM1M3ID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand_setValue] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    host     : " << ackdata.host << endl;
      cout << "    origin    : " << ackdata.origin << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.MTM1M3ID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "MTM1M3::ackcmd_004df1cbDataWriter::return_loan");
//    SALWriter->unregister_instance(ackdata, ackHandle);
   return SAL__OK;
}


int SAL_MTM1M3::getEvent_detailedState(MTM1M3_logevent_detailedStateC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_detailedState";
  int actorIdx = SAL__MTM1M3_logevent_detailedState_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_detailedState(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_detailedState( MTM1M3_logevent_detailedStateC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_detailedState");
  }
  data->priority=priority;
  status = putSample_logevent_detailedState(data);
  return status;
}


int SAL_MTM1M3::getEvent_hardpointActuatorInfo(MTM1M3_logevent_hardpointActuatorInfoC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_hardpointActuatorInfo";
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorInfo_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_hardpointActuatorInfo(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_hardpointActuatorInfo( MTM1M3_logevent_hardpointActuatorInfoC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_hardpointActuatorInfo");
  }
  data->priority=priority;
  status = putSample_logevent_hardpointActuatorInfo(data);
  return status;
}


int SAL_MTM1M3::getEvent_forceActuatorInfo(MTM1M3_logevent_forceActuatorInfoC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_forceActuatorInfo";
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorInfo_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_forceActuatorInfo(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_forceActuatorInfo( MTM1M3_logevent_forceActuatorInfoC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_forceActuatorInfo");
  }
  data->priority=priority;
  status = putSample_logevent_forceActuatorInfo(data);
  return status;
}


int SAL_MTM1M3::getEvent_ilcWarning(MTM1M3_logevent_ilcWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_ilcWarning";
  int actorIdx = SAL__MTM1M3_logevent_ilcWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_ilcWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_ilcWarning( MTM1M3_logevent_ilcWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_ilcWarning");
  }
  data->priority=priority;
  status = putSample_logevent_ilcWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_interlockWarning(MTM1M3_logevent_interlockWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_interlockWarning";
  int actorIdx = SAL__MTM1M3_logevent_interlockWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_interlockWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_interlockWarning( MTM1M3_logevent_interlockWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_interlockWarning");
  }
  data->priority=priority;
  status = putSample_logevent_interlockWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_airSupplyStatus(MTM1M3_logevent_airSupplyStatusC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_airSupplyStatus";
  int actorIdx = SAL__MTM1M3_logevent_airSupplyStatus_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_airSupplyStatus(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_airSupplyStatus( MTM1M3_logevent_airSupplyStatusC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_airSupplyStatus");
  }
  data->priority=priority;
  status = putSample_logevent_airSupplyStatus(data);
  return status;
}


int SAL_MTM1M3::getEvent_airSupplyWarning(MTM1M3_logevent_airSupplyWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_airSupplyWarning";
  int actorIdx = SAL__MTM1M3_logevent_airSupplyWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_airSupplyWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_airSupplyWarning( MTM1M3_logevent_airSupplyWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_airSupplyWarning");
  }
  data->priority=priority;
  status = putSample_logevent_airSupplyWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_interlockStatus(MTM1M3_logevent_interlockStatusC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_interlockStatus";
  int actorIdx = SAL__MTM1M3_logevent_interlockStatus_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_interlockStatus(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_interlockStatus( MTM1M3_logevent_interlockStatusC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_interlockStatus");
  }
  data->priority=priority;
  status = putSample_logevent_interlockStatus(data);
  return status;
}


int SAL_MTM1M3::getEvent_displacementSensorWarning(MTM1M3_logevent_displacementSensorWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_displacementSensorWarning";
  int actorIdx = SAL__MTM1M3_logevent_displacementSensorWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_displacementSensorWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_displacementSensorWarning( MTM1M3_logevent_displacementSensorWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_displacementSensorWarning");
  }
  data->priority=priority;
  status = putSample_logevent_displacementSensorWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_inclinometerSensorWarning(MTM1M3_logevent_inclinometerSensorWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_inclinometerSensorWarning";
  int actorIdx = SAL__MTM1M3_logevent_inclinometerSensorWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_inclinometerSensorWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_inclinometerSensorWarning( MTM1M3_logevent_inclinometerSensorWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_inclinometerSensorWarning");
  }
  data->priority=priority;
  status = putSample_logevent_inclinometerSensorWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_accelerometerWarning(MTM1M3_logevent_accelerometerWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_accelerometerWarning";
  int actorIdx = SAL__MTM1M3_logevent_accelerometerWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_accelerometerWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_accelerometerWarning( MTM1M3_logevent_accelerometerWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_accelerometerWarning");
  }
  data->priority=priority;
  status = putSample_logevent_accelerometerWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_forceSetpointWarning(MTM1M3_logevent_forceSetpointWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_forceSetpointWarning";
  int actorIdx = SAL__MTM1M3_logevent_forceSetpointWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_forceSetpointWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_forceSetpointWarning( MTM1M3_logevent_forceSetpointWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_forceSetpointWarning");
  }
  data->priority=priority;
  status = putSample_logevent_forceSetpointWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_forceActuatorState(MTM1M3_logevent_forceActuatorStateC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_forceActuatorState";
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorState_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_forceActuatorState(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_forceActuatorState( MTM1M3_logevent_forceActuatorStateC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_forceActuatorState");
  }
  data->priority=priority;
  status = putSample_logevent_forceActuatorState(data);
  return status;
}


int SAL_MTM1M3::getEvent_hardpointMonitorInfo(MTM1M3_logevent_hardpointMonitorInfoC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_hardpointMonitorInfo";
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorInfo_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_hardpointMonitorInfo(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_hardpointMonitorInfo( MTM1M3_logevent_hardpointMonitorInfoC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_hardpointMonitorInfo");
  }
  data->priority=priority;
  status = putSample_logevent_hardpointMonitorInfo(data);
  return status;
}


int SAL_MTM1M3::getEvent_cellLightStatus(MTM1M3_logevent_cellLightStatusC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_cellLightStatus";
  int actorIdx = SAL__MTM1M3_logevent_cellLightStatus_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_cellLightStatus(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_cellLightStatus( MTM1M3_logevent_cellLightStatusC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_cellLightStatus");
  }
  data->priority=priority;
  status = putSample_logevent_cellLightStatus(data);
  return status;
}


int SAL_MTM1M3::getEvent_cellLightWarning(MTM1M3_logevent_cellLightWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_cellLightWarning";
  int actorIdx = SAL__MTM1M3_logevent_cellLightWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_cellLightWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_cellLightWarning( MTM1M3_logevent_cellLightWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_cellLightWarning");
  }
  data->priority=priority;
  status = putSample_logevent_cellLightWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_powerStatus(MTM1M3_logevent_powerStatusC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_powerStatus";
  int actorIdx = SAL__MTM1M3_logevent_powerStatus_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_powerStatus(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_powerStatus( MTM1M3_logevent_powerStatusC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_powerStatus");
  }
  data->priority=priority;
  status = putSample_logevent_powerStatus(data);
  return status;
}


int SAL_MTM1M3::getEvent_powerWarning(MTM1M3_logevent_powerWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_powerWarning";
  int actorIdx = SAL__MTM1M3_logevent_powerWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_powerWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_powerWarning( MTM1M3_logevent_powerWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_powerWarning");
  }
  data->priority=priority;
  status = putSample_logevent_powerWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_forceActuatorForceWarning(MTM1M3_logevent_forceActuatorForceWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_forceActuatorForceWarning";
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorForceWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_forceActuatorForceWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_forceActuatorForceWarning( MTM1M3_logevent_forceActuatorForceWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_forceActuatorForceWarning");
  }
  data->priority=priority;
  status = putSample_logevent_forceActuatorForceWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_gyroWarning(MTM1M3_logevent_gyroWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_gyroWarning";
  int actorIdx = SAL__MTM1M3_logevent_gyroWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_gyroWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_gyroWarning( MTM1M3_logevent_gyroWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_gyroWarning");
  }
  data->priority=priority;
  status = putSample_logevent_gyroWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_powerSupplyStatus(MTM1M3_logevent_powerSupplyStatusC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_powerSupplyStatus";
  int actorIdx = SAL__MTM1M3_logevent_powerSupplyStatus_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_powerSupplyStatus(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_powerSupplyStatus( MTM1M3_logevent_powerSupplyStatusC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_powerSupplyStatus");
  }
  data->priority=priority;
  status = putSample_logevent_powerSupplyStatus(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedOffsetForces(MTM1M3_logevent_appliedOffsetForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedOffsetForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedOffsetForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedOffsetForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedOffsetForces( MTM1M3_logevent_appliedOffsetForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedOffsetForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedOffsetForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedStaticForces(MTM1M3_logevent_appliedStaticForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedStaticForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedStaticForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedStaticForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedStaticForces( MTM1M3_logevent_appliedStaticForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedStaticForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedStaticForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedActiveOpticForces(MTM1M3_logevent_appliedActiveOpticForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedActiveOpticForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedActiveOpticForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedActiveOpticForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedActiveOpticForces( MTM1M3_logevent_appliedActiveOpticForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedActiveOpticForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedActiveOpticForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedAberrationForces(MTM1M3_logevent_appliedAberrationForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedAberrationForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedAberrationForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedAberrationForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedAberrationForces( MTM1M3_logevent_appliedAberrationForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedAberrationForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedAberrationForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedAzimuthForces(MTM1M3_logevent_appliedAzimuthForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedAzimuthForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedAzimuthForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedAzimuthForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedAzimuthForces( MTM1M3_logevent_appliedAzimuthForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedAzimuthForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedAzimuthForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_commandRejectionWarning(MTM1M3_logevent_commandRejectionWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_commandRejectionWarning";
  int actorIdx = SAL__MTM1M3_logevent_commandRejectionWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_commandRejectionWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_commandRejectionWarning( MTM1M3_logevent_commandRejectionWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_commandRejectionWarning");
  }
  data->priority=priority;
  status = putSample_logevent_commandRejectionWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_pidInfo(MTM1M3_logevent_pidInfoC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_pidInfo";
  int actorIdx = SAL__MTM1M3_logevent_pidInfo_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_pidInfo(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_pidInfo( MTM1M3_logevent_pidInfoC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_pidInfo");
  }
  data->priority=priority;
  status = putSample_logevent_pidInfo(data);
  return status;
}


int SAL_MTM1M3::getEvent_hardpointActuatorWarning(MTM1M3_logevent_hardpointActuatorWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_hardpointActuatorWarning";
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_hardpointActuatorWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_hardpointActuatorWarning( MTM1M3_logevent_hardpointActuatorWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_hardpointActuatorWarning");
  }
  data->priority=priority;
  status = putSample_logevent_hardpointActuatorWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_hardpointMonitorWarning(MTM1M3_logevent_hardpointMonitorWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_hardpointMonitorWarning";
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_hardpointMonitorWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_hardpointMonitorWarning( MTM1M3_logevent_hardpointMonitorWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_hardpointMonitorWarning");
  }
  data->priority=priority;
  status = putSample_logevent_hardpointMonitorWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_hardpointActuatorState(MTM1M3_logevent_hardpointActuatorStateC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_hardpointActuatorState";
  int actorIdx = SAL__MTM1M3_logevent_hardpointActuatorState_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_hardpointActuatorState(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_hardpointActuatorState( MTM1M3_logevent_hardpointActuatorStateC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_hardpointActuatorState");
  }
  data->priority=priority;
  status = putSample_logevent_hardpointActuatorState(data);
  return status;
}


int SAL_MTM1M3::getEvent_hardpointMonitorState(MTM1M3_logevent_hardpointMonitorStateC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_hardpointMonitorState";
  int actorIdx = SAL__MTM1M3_logevent_hardpointMonitorState_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_hardpointMonitorState(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_hardpointMonitorState( MTM1M3_logevent_hardpointMonitorStateC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_hardpointMonitorState");
  }
  data->priority=priority;
  status = putSample_logevent_hardpointMonitorState(data);
  return status;
}


int SAL_MTM1M3::getEvent_forceActuatorWarning(MTM1M3_logevent_forceActuatorWarningC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_forceActuatorWarning";
  int actorIdx = SAL__MTM1M3_logevent_forceActuatorWarning_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_forceActuatorWarning(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_forceActuatorWarning( MTM1M3_logevent_forceActuatorWarningC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_forceActuatorWarning");
  }
  data->priority=priority;
  status = putSample_logevent_forceActuatorWarning(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedStaticForces(MTM1M3_logevent_rejectedStaticForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedStaticForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedStaticForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedStaticForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedStaticForces( MTM1M3_logevent_rejectedStaticForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedStaticForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedStaticForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedElevationForces(MTM1M3_logevent_rejectedElevationForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedElevationForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedElevationForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedElevationForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedElevationForces( MTM1M3_logevent_rejectedElevationForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedElevationForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedElevationForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedAzimuthForces(MTM1M3_logevent_rejectedAzimuthForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedAzimuthForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedAzimuthForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedAzimuthForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedAzimuthForces( MTM1M3_logevent_rejectedAzimuthForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedAzimuthForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedAzimuthForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedThermalForces(MTM1M3_logevent_rejectedThermalForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedThermalForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedThermalForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedThermalForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedThermalForces( MTM1M3_logevent_rejectedThermalForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedThermalForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedThermalForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedActiveOpticForces(MTM1M3_logevent_rejectedActiveOpticForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedActiveOpticForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedActiveOpticForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedActiveOpticForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedActiveOpticForces( MTM1M3_logevent_rejectedActiveOpticForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedActiveOpticForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedActiveOpticForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedAberrationForces(MTM1M3_logevent_rejectedAberrationForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedAberrationForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedAberrationForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedAberrationForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedAberrationForces( MTM1M3_logevent_rejectedAberrationForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedAberrationForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedAberrationForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedBalanceForces(MTM1M3_logevent_rejectedBalanceForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedBalanceForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedBalanceForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedBalanceForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedBalanceForces( MTM1M3_logevent_rejectedBalanceForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedBalanceForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedBalanceForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedVelocityForces(MTM1M3_logevent_rejectedVelocityForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedVelocityForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedVelocityForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedVelocityForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedVelocityForces( MTM1M3_logevent_rejectedVelocityForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedVelocityForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedVelocityForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedAccelerationForces(MTM1M3_logevent_rejectedAccelerationForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedAccelerationForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedAccelerationForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedAccelerationForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedAccelerationForces( MTM1M3_logevent_rejectedAccelerationForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedAccelerationForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedAccelerationForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedOffsetForces(MTM1M3_logevent_rejectedOffsetForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedOffsetForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedOffsetForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedOffsetForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedOffsetForces( MTM1M3_logevent_rejectedOffsetForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedOffsetForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedOffsetForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedForces(MTM1M3_logevent_rejectedForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedForces( MTM1M3_logevent_rejectedForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedElevationForces(MTM1M3_logevent_appliedElevationForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedElevationForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedElevationForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedElevationForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedElevationForces( MTM1M3_logevent_appliedElevationForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedElevationForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedElevationForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedAccelerationForces(MTM1M3_logevent_appliedAccelerationForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedAccelerationForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedAccelerationForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedAccelerationForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedAccelerationForces( MTM1M3_logevent_appliedAccelerationForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedAccelerationForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedAccelerationForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedThermalForces(MTM1M3_logevent_appliedThermalForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedThermalForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedThermalForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedThermalForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedThermalForces( MTM1M3_logevent_appliedThermalForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedThermalForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedThermalForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedVelocityForces(MTM1M3_logevent_appliedVelocityForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedVelocityForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedVelocityForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedVelocityForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedVelocityForces( MTM1M3_logevent_appliedVelocityForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedVelocityForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedVelocityForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedBalanceForces(MTM1M3_logevent_appliedBalanceForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedBalanceForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedBalanceForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedBalanceForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedBalanceForces( MTM1M3_logevent_appliedBalanceForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedBalanceForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedBalanceForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedForces(MTM1M3_logevent_appliedForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedForces( MTM1M3_logevent_appliedForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_rejectedCylinderForces(MTM1M3_logevent_rejectedCylinderForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_rejectedCylinderForces";
  int actorIdx = SAL__MTM1M3_logevent_rejectedCylinderForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_rejectedCylinderForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_rejectedCylinderForces( MTM1M3_logevent_rejectedCylinderForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_rejectedCylinderForces");
  }
  data->priority=priority;
  status = putSample_logevent_rejectedCylinderForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedCylinderForces(MTM1M3_logevent_appliedCylinderForcesC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedCylinderForces";
  int actorIdx = SAL__MTM1M3_logevent_appliedCylinderForces_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedCylinderForces(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedCylinderForces( MTM1M3_logevent_appliedCylinderForcesC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedCylinderForces");
  }
  data->priority=priority;
  status = putSample_logevent_appliedCylinderForces(data);
  return status;
}


int SAL_MTM1M3::getEvent_modbusResponse(MTM1M3_logevent_modbusResponseC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_modbusResponse";
  int actorIdx = SAL__MTM1M3_logevent_modbusResponse_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_modbusResponse(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_modbusResponse( MTM1M3_logevent_modbusResponseC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_modbusResponse");
  }
  data->priority=priority;
  status = putSample_logevent_modbusResponse(data);
  return status;
}


int SAL_MTM1M3::getEvent_settingVersions(MTM1M3_logevent_settingVersionsC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_settingVersions";
  int actorIdx = SAL__MTM1M3_logevent_settingVersions_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_settingVersions(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_settingVersions( MTM1M3_logevent_settingVersionsC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_settingVersions");
  }
  data->priority=priority;
  status = putSample_logevent_settingVersions(data);
  return status;
}


int SAL_MTM1M3::getEvent_errorCode(MTM1M3_logevent_errorCodeC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_errorCode";
  int actorIdx = SAL__MTM1M3_logevent_errorCode_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_errorCode(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_errorCode( MTM1M3_logevent_errorCodeC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_errorCode");
  }
  data->priority=priority;
  status = putSample_logevent_errorCode(data);
  return status;
}


int SAL_MTM1M3::getEvent_summaryState(MTM1M3_logevent_summaryStateC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_summaryState";
  int actorIdx = SAL__MTM1M3_logevent_summaryState_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_summaryState(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_summaryState( MTM1M3_logevent_summaryStateC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_summaryState");
  }
  data->priority=priority;
  status = putSample_logevent_summaryState(data);
  return status;
}


int SAL_MTM1M3::getEvent_appliedSettingsMatchStart(MTM1M3_logevent_appliedSettingsMatchStartC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_appliedSettingsMatchStart";
  int actorIdx = SAL__MTM1M3_logevent_appliedSettingsMatchStart_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_appliedSettingsMatchStart(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_appliedSettingsMatchStart( MTM1M3_logevent_appliedSettingsMatchStartC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_appliedSettingsMatchStart");
  }
  data->priority=priority;
  status = putSample_logevent_appliedSettingsMatchStart(data);
  return status;
}


int SAL_MTM1M3::getEvent_logLevel(MTM1M3_logevent_logLevelC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_logLevel";
  int actorIdx = SAL__MTM1M3_logevent_logLevel_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_logLevel(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_logLevel( MTM1M3_logevent_logLevelC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_logLevel");
  }
  data->priority=priority;
  status = putSample_logevent_logLevel(data);
  return status;
}


int SAL_MTM1M3::getEvent_logMessage(MTM1M3_logevent_logMessageC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_logMessage";
  int actorIdx = SAL__MTM1M3_logevent_logMessage_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_logMessage(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_logMessage( MTM1M3_logevent_logMessageC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_logMessage");
  }
  data->priority=priority;
  status = putSample_logevent_logMessage(data);
  return status;
}


int SAL_MTM1M3::getEvent_settingsApplied(MTM1M3_logevent_settingsAppliedC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_settingsApplied";
  int actorIdx = SAL__MTM1M3_logevent_settingsApplied_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_settingsApplied(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_settingsApplied( MTM1M3_logevent_settingsAppliedC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_settingsApplied");
  }
  data->priority=priority;
  status = putSample_logevent_settingsApplied(data);
  return status;
}


int SAL_MTM1M3::getEvent_simulationMode(MTM1M3_logevent_simulationModeC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_simulationMode";
  int actorIdx = SAL__MTM1M3_logevent_simulationMode_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_simulationMode(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_simulationMode( MTM1M3_logevent_simulationModeC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_simulationMode");
  }
  data->priority=priority;
  status = putSample_logevent_simulationMode(data);
  return status;
}


int SAL_MTM1M3::getEvent_softwareVersions(MTM1M3_logevent_softwareVersionsC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_softwareVersions";
  int actorIdx = SAL__MTM1M3_logevent_softwareVersions_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_softwareVersions(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_softwareVersions( MTM1M3_logevent_softwareVersionsC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_softwareVersions");
  }
  data->priority=priority;
  status = putSample_logevent_softwareVersions(data);
  return status;
}


int SAL_MTM1M3::getEvent_heartbeat(MTM1M3_logevent_heartbeatC *data)
{
  ReturnCode_t status =  -1;
  string stopic="MTM1M3_logevent_heartbeat";
  int actorIdx = SAL__MTM1M3_logevent_heartbeat_ACTOR;
  int maxSample = sal[actorIdx].maxSamples;
  sal[actorIdx].maxSamples=1;
  status = getSample_logevent_heartbeat(data);
  sal[actorIdx].maxSamples = maxSample;
  return status;
}


salReturn SAL_MTM1M3::logEvent_heartbeat( MTM1M3_logevent_heartbeatC *data, int priority )
{
  if ( data == NULL ) {
     throw std::runtime_error("NULL pointer for logEvent_heartbeat");
  }
  data->priority=priority;
  status = putSample_logevent_heartbeat(data);
  return status;
}


salReturn SAL_MTM1M3::salTelemetryPub(char *topicName)
{
  int actorIdx = -1;
  int status = 0;

  actorIdx = getActorIndex(topicName);
  if (actorIdx > -1) {
     status = salTelemetryPub(actorIdx);
  } else {
     status = SAL__ERROR;
     throw std::runtime_error("Unknown topic");
  }
  return status;
}

salReturn SAL_MTM1M3::salTelemetrySub(char *topicName)
{
  int actorIdx = -1;
  int status = 0;

  actorIdx = getActorIndex(topicName);
  if (actorIdx > -1) {
     status = salTelemetrySub(actorIdx);
  } else {
     status = SAL__ERROR;
     throw std::runtime_error("Unknown topic");
  }
  return status;
}
 

salReturn SAL_MTM1M3::salTelemetryPub(int actorIdx)
{
  // create domain participant
  createParticipant(domainName);

  //create type
  salTypeSupport(actorIdx);

  //create Topic
  createTopic(actorIdx);

  //create Publisher
  createPublisher(actorIdx);

  // create DataWriter :
  // If autodispose_unregistered_instances is set to true (default value),
  // you will have to start the subscriber before the publisher
  bool autodispose_unregistered_instances = true;
  createWriter(actorIdx,autodispose_unregistered_instances);
  DataWriter_var dwriter = getWriter(actorIdx);
  sal[actorIdx].isWriter = true;
  return SAL__OK;
}



       
salReturn SAL_MTM1M3::salTelemetrySub(int actorIdx)
{
   // create domain participant
   createParticipant(domainName);

   //create type
   salTypeSupport(actorIdx);

   //create Topic
   createTopic(actorIdx);

   //create Subscriber
   createSubscriber(actorIdx);

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   // Filter expr
   char buf[64];
   sprintf(buf, "MTM1M3ID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
   StringSeq sSeqExpr;
   sSeqExpr.length(0);
   // create topic
   char ftopicName[200];
   sprintf(ftopicName,"%s_%s","filtered",sal[actorIdx].topicHandle);
   createContentFilteredTopic(actorIdx,ftopicName, sFilter.in(), sSeqExpr);
   // create DataReader
   createReader(actorIdx,true);
#else
   createReader(actorIdx,false);
#endif
   sal[actorIdx].isReader = true;
   return SAL__OK;
}



void SAL_MTM1M3::logError(salReturn status) 
{
   cout << "=== ERROR return value = " << status << endl; 
}

/*
using Clock = std::chrono::high_resolution_clock;
using Time_point = Clock::time_point;
using std::chrono::milliseconds;
using std::chrono::duration_cast;

salTIME SAL_MTM1M3::currentTime()
{
    Time_point tp = Clock::now();   
    return (salTIME duration_cast<milliseconds>tp.count());
}
*/


// INSERT CMDALIAS SUPPORT  for issueCommandC and acceptCommandC, acceptAnyCommand   



salReturn SAL_MTM1M3::cancelCommand( int cmdSeqNum )
{
   salReturn status = SAL__OK;
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

salReturn SAL_MTM1M3::abortCommand( int cmdSeqNum )
{
   salReturn status = SAL__OK;
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

salReturn SAL_MTM1M3::setDebugLevel( int level )
{
   debugLevel = level;
   salReturn status = SAL__OK;
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

int SAL_MTM1M3::getDebugLevel( int level )
{
   return debugLevel;
}

int SAL_MTM1M3::getOrigin()
{
   salReturn status = SAL__OK;
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}
      
void SAL_MTM1M3::setMaxSamples(int actorIdx, int n)
{
    if ( n < 0 ) {
       sal[actorIdx].maxSamples = LENGTH_UNLIMITED;
    } else {
       sal[actorIdx].maxSamples = n;
    }
}



int SAL_MTM1M3::getProperty(salCHAR *property, salCHAR *value)
{
   salReturn status = SAL__OK;
   strcpy(value,"UNKNOWN");
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

salReturn SAL_MTM1M3::setProperty(salCHAR *property, salCHAR *value)
{
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}
 


// INSERT EVENTALIAS SUPPORT



salReturn SAL_MTM1M3::salCommand(char *cmdAlias)
{
  time_t sTime;
  int actorIdx = getActorIndex(cmdAlias);
  if (actorIdx < 0) {return SAL__ERROR;}
  string stopic1="keyedCommand";
  string stopic2="keyedResponse";
  string response="MTM1M3_ackcmd";

  // create domain participant
  createParticipant(domainName);

  //create Publisher
  createPublisher(actorIdx);
  salTypeSupport(actorIdx);
  createSubscriber(SAL__MTM1M3_ackcmd_ACTOR);
  createTopic(actorIdx,cmdAlias);

  if (sal[SAL__MTM1M3_ackcmd_ACTOR].isReader == false) {
     //create types
     MTM1M3::ackcmd_004df1cbTypeSupport_var mtr = new MTM1M3::ackcmd_004df1cbTypeSupport();
     registerType2(SAL__MTM1M3_ackcmd_ACTOR,mtr.in());

     //create Topics
     createTopic2(SAL__MTM1M3_ackcmd_ACTOR,const_cast<char*>(response.c_str()));

     //create a reader for responses
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
     // Filter expr
     char buf[64];
     sprintf(buf, "MTM1M3ID = %d", subsystemID);
     DDS::String_var sFilter = DDS::string_dup(buf);
     // Filter expr
     StringSeq sSeqExpr;
     sSeqExpr.length(0);
     // create topic
    createContentFilteredTopic2(SAL__MTM1M3_ackcmd_ACTOR,"filteredResponse", sFilter.in(), sSeqExpr);
    // create DataReader
    createReader2(SAL__MTM1M3_ackcmd_ACTOR,true);
#else
    createReader2(SAL__MTM1M3_ackcmd_ACTOR,false);
#endif
    sal[SAL__MTM1M3_ackcmd_ACTOR].sampleAge = 1.0e20;
    sal[SAL__MTM1M3_ackcmd_ACTOR].isReader = true;
  }

  createWriter(actorIdx,true);
  sal[actorIdx].isCommand = true;
  sal[actorIdx].isWriter = true;
  sal[actorIdx].sndSeqNum = time(&sTime) + 32768*actorIdx;
  return SAL__OK;
}


salReturn SAL_MTM1M3::salProcessor(char *cmdAlias)
{
  int actorIdx = getActorIndex(cmdAlias);
  if (actorIdx < 0) {return SAL__ERROR;}
  string stopic1="keyedCommand";
  string stopic2="keyedResponse";
  string response="MTM1M3_ackcmd";

  // create domain participant
  createParticipant(domainName);

  createSubscriber(actorIdx);

  //create types
  salTypeSupport(actorIdx);
  createTopic(actorIdx,cmdAlias);


  //create Topics

  //create a reader for commands
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  // Filter expr
   char buf[64],buf2[200];
   sprintf(buf, "MTM1M3ID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
  StringSeq sSeqExpr;
  sSeqExpr.length(0);
  // create topic
   sprintf(buf2, "filteredCmd_%s", sal[actorIdx].topicHandle);
  createContentFilteredTopic(actorIdx,buf2, sFilter.in(), sSeqExpr);
 // create DataReader
  createReader(actorIdx,true);
#else
  createReader(actorIdx,false);
#endif
  sal[actorIdx].isProcessor = true;
  sal[actorIdx].isReader = true;
  sal[actorIdx].sampleAge = 1.0e20;


  if ( sal[SAL__MTM1M3_ackcmd_ACTOR].isWriter == false) {
    //create Publisher
    createPublisher(SAL__MTM1M3_ackcmd_ACTOR);
    MTM1M3::ackcmd_004df1cbTypeSupport_var mtr = new MTM1M3::ackcmd_004df1cbTypeSupport();
    registerType2(SAL__MTM1M3_ackcmd_ACTOR,mtr.in());
    createTopic2(SAL__MTM1M3_ackcmd_ACTOR,const_cast<char*>(response.c_str()));
    bool autodispose_unregistered_instances = true;
    createWriter2(SAL__MTM1M3_ackcmd_ACTOR,autodispose_unregistered_instances);
    sal[SAL__MTM1M3_ackcmd_ACTOR].isWriter = true;
  }

  return SAL__OK;
}


salReturn SAL_MTM1M3::salEventPub(char *topicName)
{
  int actorIdx = getActorIndex(topicName);

  if ( actorIdx < 0) {return SAL__ERROR;}
  salTelemetryPub(actorIdx);
  sal[actorIdx].isEventWriter = true;
  return SAL__OK;
}


salReturn SAL_MTM1M3::salEventSub(char *topicName)
{
  int actorIdx = getActorIndex(topicName);

  if ( actorIdx < 0) {return SAL__ERROR;}

  // create domain participant
  createParticipant(domainName);

  //create type
  salTypeSupport(actorIdx);

  //create Topic
  createTopic(actorIdx);
  createSubscriber(actorIdx);

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   // Filter expr
   char buf[64];
   sprintf(buf, "MTM1M3ID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
   StringSeq sSeqExpr;
   sSeqExpr.length(0);
   // create topic
   char ftopicName[200];
   sprintf(ftopicName,"%s_%s","filtered",sal[actorIdx].topicHandle);
   createContentFilteredTopic(actorIdx,ftopicName, sFilter.in(), sSeqExpr);
   // create DataReader
   createReader(actorIdx,true);
#else
   createReader(actorIdx,false);
#endif
   sal[actorIdx].isEventReader = true;
   return SAL__OK;
}


void SAL_MTM1M3::salShutdown()
{
  if (participant != NULL) {
    participant->delete_contained_entities();
    deleteParticipant();
    participant = NULL;
  }
}

void SAL_MTM1M3::createParticipant(const char *partitiontName)
{
  
  if (participant == NULL) {
    domain = DOMAIN_ID_DEFAULT;
    dpf = DomainParticipantFactory::get_instance();
    checkHandle(dpf.in(), "DDS::DomainParticipantFactory::get_instance");
    participant = dpf->create_participant(domain, PARTICIPANT_QOS_DEFAULT, NULL,STATUS_MASK_NONE);
    checkHandle(participant.in(),"DDS::DomainParticipantFactory::create_participant");
    partition = partitiontName;
  }
}

void SAL_MTM1M3::deleteParticipant()
{
   status = dpf->delete_participant(participant.in());
   checkStatus(status, "DDS::DomainParticipant::delete_participant ");
}

void SAL_MTM1M3::registerType(TypeSupport *ts)
{
  typeName = ts->get_type_name();
  status = ts->register_type(participant.in(), typeName);
  checkStatus(status, "register_type");
}

void SAL_MTM1M3::registerType2(TypeSupport *ts)
{
  typeName2 = ts->get_type_name();
  status = ts->register_type(participant.in(), typeName2);
  checkStatus(status, "register_type");
}

void SAL_MTM1M3::registerType(int actorIdx,TypeSupport *ts)
{
  sal[actorIdx].typeName = ts->get_type_name();
  status = ts->register_type(participant.in(), sal[actorIdx].typeName);
  checkStatus(status, "register_type");
}

void SAL_MTM1M3::registerType2(int actorIdx,TypeSupport *ts)
{
  sal[actorIdx].typeName2 = ts->get_type_name();
  status = ts->register_type(participant.in(), sal[actorIdx].typeName2);
  checkStatus(status, "register_type");
}

void SAL_MTM1M3::createTopic(int actorIdx)
{
  status = participant->get_default_topic_qos(sal[actorIdx].reliable_topic_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  if ( sal[actorIdx].tuneableQos) {
    sal[actorIdx].reliable_topic_qos.reliability.kind = RELIABLE_RELIABILITY_QOS;
    sal[actorIdx].reliable_topic_qos.durability.kind = sal[actorIdx].durability;
    sal[actorIdx].reliable_topic_qos.history.kind = KEEP_LAST_HISTORY_QOS;
    sal[actorIdx].reliable_topic_qos.history.depth = sal[actorIdx].historyDepth;
    sal[actorIdx].reliable_topic_qos.durability_service.history_depth = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_samples = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_instances = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_samples_per_instance = sal[actorIdx].historyDepth;

  /* Make the tailored QoS the new default. */
    status = participant->set_default_topic_qos(sal[actorIdx].reliable_topic_qos);
    checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");
  }

  sal[actorIdx].topic = participant->create_topic(sal[actorIdx].topicHandle, sal[actorIdx].typeName, sal[actorIdx].reliable_topic_qos,
    NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].topic.in(), "DDS::DomainParticipant::create_topic ()");
}

void SAL_MTM1M3::createTopic2(int actorIdx)
{
  status = participant->get_default_topic_qos(sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  if ( sal[actorIdx].tuneableQos) {
    sal[actorIdx].reliable_topic_qos2.reliability.kind = RELIABLE_RELIABILITY_QOS;
    sal[actorIdx].reliable_topic_qos2.durability.kind = sal[actorIdx].durability;
    sal[actorIdx].reliable_topic_qos2.history.kind = KEEP_LAST_HISTORY_QOS;
    sal[actorIdx].reliable_topic_qos2.history.depth = sal[actorIdx].historyDepth;
    sal[actorIdx].reliable_topic_qos2.durability_service.history_depth = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_samples = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_instances = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_samples_per_instance = sal[actorIdx].historyDepth;

  /* Make the tailored QoS the new default. */
    status = participant->set_default_topic_qos(sal[actorIdx].reliable_topic_qos2);
    checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");
  }

  sal[actorIdx].topic2 = participant->create_topic(sal[actorIdx].topicHandle, sal[actorIdx].typeName2, sal[actorIdx].reliable_topic_qos2,
    NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].topic2.in(), "DDS::DomainParticipant::create_topic ()");
}

void SAL_MTM1M3::createTopic(int actorIdx, char *topicName)
{
  status = participant->get_default_topic_qos(sal[actorIdx].reliable_topic_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  if ( sal[actorIdx].tuneableQos) {
    sal[actorIdx].reliable_topic_qos.reliability.kind = RELIABLE_RELIABILITY_QOS;
    sal[actorIdx].reliable_topic_qos.durability.kind = sal[actorIdx].durability;
    sal[actorIdx].reliable_topic_qos.history.kind = KEEP_LAST_HISTORY_QOS;
    sal[actorIdx].reliable_topic_qos.history.depth = sal[actorIdx].historyDepth;
    sal[actorIdx].reliable_topic_qos.durability_service.history_depth = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_samples = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_instances = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos.resource_limits.max_samples_per_instance = sal[actorIdx].historyDepth;

  /* Make the tailored QoS the new default. */
    status = participant->set_default_topic_qos(sal[actorIdx].reliable_topic_qos);
    checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");
  }
  sal[actorIdx].topic = participant->create_topic(sal[actorIdx].topicHandle, sal[actorIdx].typeName, sal[actorIdx].reliable_topic_qos,
    NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].topic.in(), "DDS::DomainParticipant::create_topic ()");
}

void SAL_MTM1M3::createTopic2(int actorIdx, char *topicName)
{
  status = participant->get_default_topic_qos(sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  if ( sal[actorIdx].tuneableQos) {
    sal[actorIdx].reliable_topic_qos2.reliability.kind = RELIABLE_RELIABILITY_QOS;
    sal[actorIdx].reliable_topic_qos2.durability.kind = sal[actorIdx].durability;
    sal[actorIdx].reliable_topic_qos2.history.kind = KEEP_LAST_HISTORY_QOS;
    sal[actorIdx].reliable_topic_qos2.history.depth = sal[actorIdx].historyDepth;
    sal[actorIdx].reliable_topic_qos2.durability_service.history_depth = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos2.resource_limits.max_samples = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos2.resource_limits.max_instances = sal[actorIdx].historyDepth;
//    sal[actorIdx].reliable_topic_qos2.resource_limits.max_samples_per_instance = sal[actorIdx].historyDepth;

  /* Make the tailored QoS the new default. */
    status = participant->set_default_topic_qos(sal[actorIdx].reliable_topic_qos2);
    checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");
  }
  sal[actorIdx].topic2 = participant->create_topic(sal[actorIdx].topicHandle, sal[actorIdx].typeName2, sal[actorIdx].reliable_topic_qos2,
    NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].topic2.in(), "DDS::DomainParticipant::create_topic ()");
}


void SAL_MTM1M3::createContentFilteredTopic(const char *topicName, const
  char *filter, const StringSeq &expr)
{
  filteredtopic = participant->create_contentfilteredtopic(topicName, topic,
    filter, expr);
  checkHandle(filteredtopic.in(),
    "DomainParticipant::create_contentfilteredtopic");
}

void SAL_MTM1M3::createContentFilteredTopic2(const char *topicName, const
  char *filter, const StringSeq &expr)
{
  filteredtopic2 = participant->create_contentfilteredtopic(topicName, topic2,
    filter, expr);
  checkHandle(filteredtopic2.in(),
    "DomainParticipant::create_contentfilteredtopic");
}

void SAL_MTM1M3::createContentFilteredTopic(int actorIdx,const char *topicName, const char *filter, const StringSeq &expr)
{
  sal[actorIdx].filteredtopic = participant->create_contentfilteredtopic(topicName, sal[actorIdx].topic,
    filter, expr);
  checkHandle(sal[actorIdx].filteredtopic.in(),
    "DomainParticipant::create_contentfilteredtopic");
}

void SAL_MTM1M3::createContentFilteredTopic2(int actorIdx,const char *topicName, const char *filter, const StringSeq &expr)
{
  sal[actorIdx].filteredtopic2 = participant->create_contentfilteredtopic(topicName, sal[actorIdx].topic2,
    filter, expr);
  checkHandle(sal[actorIdx].filteredtopic2.in(),
    "DomainParticipant::create_contentfilteredtopic");
}


void SAL_MTM1M3::deleteTopics()
{
  if ( filteredtopic != NULL) {
    status = participant->delete_contentfilteredtopic(filteredtopic);
    checkStatus(status, "DDS.DomainParticipant.delete_topic");
  }
  if ( filteredtopic2 != NULL) {
    status = participant->delete_contentfilteredtopic(filteredtopic2);
    checkStatus(status, "DDS.DomainParticipant.delete_topic");
  }
  if ( topic != NULL) {
    status = participant->delete_topic(topic);
    checkStatus(status, "DDS.DomainParticipant.delete_topic");
  }
  if ( topic2 != NULL) {
    status = participant->delete_topic(topic2);
    checkStatus(status, "DDS.DomainParticipant.delete_topic");
  }
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
    if ( sal[i].topic != NULL) {
      status = participant->delete_topic(sal[i].topic);
      checkStatus(status, "DDS.DomainParticipant.delete_topic");
    }
    if ( sal[i].topic2 != NULL) {
      status = participant->delete_topic(sal[i].topic2);
      checkStatus(status, "DDS.DomainParticipant.delete_topic");
    }
    if ( sal[i].filteredtopic != NULL) {
      status = participant->delete_contentfilteredtopic(sal[i].filteredtopic);
      checkStatus(status, "DDS.DomainParticipant.delete_topic");
    }
    if ( sal[i].filteredtopic2 != NULL) {
      status = participant->delete_contentfilteredtopic(sal[i].filteredtopic2);
      checkStatus(status, "DDS.DomainParticipant.delete_topic");
    }
  }  

}


void SAL_MTM1M3::createPublisher()
{
  status = participant->get_default_publisher_qos(pub_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  pub_qos.partition.name.length(1);
  pub_qos.partition.name[0] = partition;

  publisher = participant->create_publisher(pub_qos, NULL, STATUS_MASK_NONE);
  checkHandle(publisher.in(), "DDS::DomainParticipant::create_publisher");
}

void SAL_MTM1M3::createPublisher(int actorIdx)
{
  status = participant->get_default_publisher_qos(sal[actorIdx].pub_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  sal[actorIdx].pub_qos.partition.name.length(1);
  sal[actorIdx].pub_qos.partition.name[0] = partition;

  sal[actorIdx].publisher = participant->create_publisher(sal[actorIdx].pub_qos, NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].publisher.in(), "DDS::DomainParticipant::create_publisher");
}


void SAL_MTM1M3::deletePublisher()
{
    if (publisher != NULL) {
       status = participant->delete_publisher(publisher.in());
       checkStatus(status, "DDS::DomainParticipant::delete_publisher ");
    }
    for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
        if ( sal[i].publisher != NULL) {
       cout << "    deletePublisher : " << i << endl;
          status = participant->delete_publisher(sal[i].publisher.in());
          checkStatus(status, "DDS::DomainParticipant::delete_publisher ");
        }
    }
}



void SAL_MTM1M3::createWriter(int actorIdx,bool autodispose_unregistered_instances)
{
  status = sal[actorIdx].publisher->get_default_datawriter_qos(sal[actorIdx].dw_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  status = sal[actorIdx].publisher->copy_from_topic_qos(sal[actorIdx].dw_qos, sal[actorIdx].reliable_topic_qos);
  checkStatus(status, "DDS::Publisher::copy_from_topic_qos");
  sal[actorIdx].dw_qos.writer_data_lifecycle.autodispose_unregistered_instances = autodispose_unregistered_instances;
  sal[actorIdx].writer = sal[actorIdx].publisher->create_datawriter(sal[actorIdx].topic.in(), sal[actorIdx].dw_qos, NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].writer, "DDS::Publisher::create_datawriter");
  sal[actorIdx].isWriter = true;
  cout << "createWriter : " << sal[actorIdx].topic << " , " << sal[actorIdx].typeName << " , " << sal[actorIdx].topicHandle << endl;
}

void SAL_MTM1M3::createWriter2(int actorIdx,bool autodispose_unregistered_instances)
{
  status = sal[actorIdx].publisher->get_default_datawriter_qos(sal[actorIdx].dw_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  status = sal[actorIdx].publisher->copy_from_topic_qos(sal[actorIdx].dw_qos, sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::Publisher::copy_from_topic_qos");
  sal[actorIdx].dw_qos.writer_data_lifecycle.autodispose_unregistered_instances = autodispose_unregistered_instances;
  sal[actorIdx].writer2 = sal[actorIdx].publisher->create_datawriter(sal[actorIdx].topic2.in(), sal[actorIdx].dw_qos, NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].writer2, "DDS::Publisher::create_datawriter");
  sal[actorIdx].isWriter = true;
  cout << "createWriter2 : " << sal[actorIdx].topic2 << " , "  << sal[actorIdx].typeName2 << " , " << sal[actorIdx].topicHandle << endl;
}

void SAL_MTM1M3::deleteWriter()
{
  if (writer != NULL) {
    status = publisher->delete_datawriter(writer);
    checkStatus(status, "DDS::Publisher::delete_datawriter ");
  }
  if (writer2 != NULL) {
    status = publisher->delete_datawriter(writer2);
    checkStatus(status, "DDS::Publisher::delete_datawriter ");
  }
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
      if ( sal[i].writer != NULL) {
        status = sal[i].publisher->delete_datawriter(sal[i].writer);
        checkStatus(status, "DDS::Publisher::delete_datawriter ");
      }
      if ( sal[i].writer2 != NULL) {
        status = sal[i].publisher->delete_datawriter(sal[i].writer2);
        checkStatus(status, "DDS::Publisher::delete_datawriter ");
      }
  }
}

void SAL_MTM1M3::createSubscriber()
{
  int status = participant->get_default_subscriber_qos(sub_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_subscriber_qos");
  sub_qos.partition.name.length(1);
  sub_qos.partition.name[0] = partition;
  subscriber = participant->create_subscriber(sub_qos, NULL, STATUS_MASK_NONE);
  checkHandle(subscriber.in(), "DDS::DomainParticipant::create_subscriber");
}


void SAL_MTM1M3::createSubscriber(int actorIdx)
{
  int status = participant->get_default_subscriber_qos(sal[actorIdx].sub_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_subscriber_qos");
  sal[actorIdx].sub_qos.partition.name.length(1);
  sal[actorIdx].sub_qos.partition.name[0] = partition;
  sal[actorIdx].subscriber = participant->create_subscriber(sal[actorIdx].sub_qos, NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].subscriber.in(), "DDS::DomainParticipant::create_subscriber");
}


void SAL_MTM1M3::deleteSubscriber()
{
  if (subscriber != NULL) {
     status = participant->delete_subscriber(subscriber);
     checkStatus(status, "DDS::DomainParticipant::delete_subscriber ");
  }
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
    if (sal[i].subscriber != NULL) {
      status = participant->delete_subscriber(sal[i].subscriber);
      checkStatus(status, "DDS::DomainParticipant::delete_subscriber ");
    }
  }
}


void SAL_MTM1M3::createReader(int actorIdx,bool filtered)
{
  status = sal[actorIdx].subscriber->get_default_datareader_qos(sal[actorIdx].dr_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_datareader_qos");
  status = sal[actorIdx].subscriber->copy_from_topic_qos(sal[actorIdx].dr_qos, sal[actorIdx].reliable_topic_qos);
  checkStatus(status, "DDS::Subscriber::copy_from_topic_qos");
  if (filtered) {
    sal[actorIdx].reader = sal[actorIdx].subscriber->create_datareader(sal[actorIdx].filteredtopic.in(),
    DATAREADER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  } else {
    sal[actorIdx].reader = sal[actorIdx].subscriber->create_datareader(sal[actorIdx].topic.in(),
    DATAREADER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  }
  checkHandle(sal[actorIdx].reader, "DDS::Subscriber::create_datareader ()");
  sal[actorIdx].isReader = true;
  DDS::Duration_t a_timeout;
  a_timeout.sec = historySync;
  a_timeout.nanosec = 10000000;
  sal[actorIdx].sampleAge = 1.0e20;
  status = sal[actorIdx].reader->wait_for_historical_data(a_timeout);
  cout << "createReader : " << sal[actorIdx].topic << " , " << sal[actorIdx].typeName << " , "  << sal[actorIdx].topicHandle << endl;
}

void SAL_MTM1M3::createReader2(int actorIdx,bool filtered)
{
  status = sal[actorIdx].subscriber->get_default_datareader_qos(sal[actorIdx].dr_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_datareader_qos");
  status = sal[actorIdx].subscriber->copy_from_topic_qos(sal[actorIdx].dr_qos, sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::Subscriber::copy_from_topic_qos");
  if (filtered) {
    sal[actorIdx].reader2 = sal[actorIdx].subscriber->create_datareader(sal[actorIdx].filteredtopic2.in(),
    sal[actorIdx].dr_qos, NULL, STATUS_MASK_NONE);
  } else {
    sal[actorIdx].reader2 = sal[actorIdx].subscriber->create_datareader(sal[actorIdx].topic2.in(),
    sal[actorIdx].dr_qos, NULL, STATUS_MASK_NONE);
  }
  checkHandle(sal[actorIdx].reader2, "DDS::Subscriber::create_datareader ()");
  sal[actorIdx].isReader = true;
  DDS::Duration_t a_timeout;
  a_timeout.sec = historySync;
  a_timeout.nanosec = 10000000;
  sal[actorIdx].sampleAge = 1.0e20;
  status = sal[actorIdx].reader2->wait_for_historical_data(a_timeout);
  cout << "createReader2 : " << sal[actorIdx].topic2 << " , " << sal[actorIdx].typeName2 << " , " << sal[actorIdx].topicHandle << endl;
}


void SAL_MTM1M3::deleteReader()
{
  if (reader != NULL) {
    status = subscriber->delete_datareader(reader);
    checkStatus(status, "DDS::Subscriber::delete_datareader ");
  }
  if (reader2 != NULL) {
    status = subscriber->delete_datareader(reader2);
    checkStatus(status, "DDS::Subscriber::delete_datareader ");
  }
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
    if (sal[i].reader != NULL) {
      status = sal[i].subscriber->delete_datareader(sal[i].reader);
      checkStatus(status, "DDS::Subscriber::delete_datareader ");
    }
    if (sal[i].reader2 != NULL) {
      status = sal[i].subscriber->delete_datareader(sal[i].reader2);
      checkStatus(status, "DDS::Subscriber::delete_datareader ");
    }
  }
}



DataReader_ptr SAL_MTM1M3::getReader()
{
  return DataReader::_duplicate(reader.in());
}

DataReader_ptr SAL_MTM1M3::getReader2()
{
  return DataReader::_duplicate(reader2.in());
}

DataReader_ptr SAL_MTM1M3::getReader(int actorIdx)
{
  return DataReader::_duplicate(sal[actorIdx].reader.in());
}

DataReader_ptr SAL_MTM1M3::getReader2(int actorIdx)
{
  return DataReader::_duplicate(sal[actorIdx].reader2.in());
}



DataWriter_ptr SAL_MTM1M3::getWriter()
{
  return DataWriter::_duplicate(writer.in());
}

DataWriter_ptr SAL_MTM1M3::getWriter2()
{
  return DataWriter::_duplicate(writer2.in());
}


DataWriter_ptr SAL_MTM1M3::getWriter(int actorIdx)
{
  return DataWriter::_duplicate(sal[actorIdx].writer.in());
}

DataWriter_ptr SAL_MTM1M3::getWriter2(int actorIdx)
{
  return DataWriter::_duplicate(sal[actorIdx].writer2.in());
}



Publisher_ptr SAL_MTM1M3::getPublisher()
{
  return Publisher::_duplicate(publisher.in());
}

Subscriber_ptr SAL_MTM1M3::getSubscriber()
{
  return Subscriber::_duplicate(subscriber.in());
}


Publisher_ptr SAL_MTM1M3::getPublisher(int actorIdx)
{
  return Publisher::_duplicate(sal[actorIdx].publisher.in());
}

Subscriber_ptr SAL_MTM1M3::getSubscriber(int actorIdx)
{
  return Subscriber::_duplicate(sal[actorIdx].subscriber.in());
}


Topic_ptr SAL_MTM1M3::getTopic()
{
  return Topic::_duplicate(topic.in());
}

Topic_ptr SAL_MTM1M3::getTopic(int actorIdx)
{
  return Topic::_duplicate(sal[actorIdx].topic.in());
}

Topic_ptr SAL_MTM1M3::getTopic2(int actorIdx)
{
  return Topic::_duplicate(sal[actorIdx].topic2.in());
}



DomainParticipant_ptr SAL_MTM1M3::getParticipant()
{
  return DomainParticipant::_duplicate(participant.in());
}

SAL_MTM1M3::~SAL_MTM1M3(){
    salShutdown();
}




